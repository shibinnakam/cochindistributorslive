{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.find.js\";\n/* @license\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Euler, EventDispatcher, Matrix3, Spherical, Vector2, Vector3 } from 'three';\nimport { $panElement } from '../features/controls.js';\nimport { clamp } from '../utilities.js';\nimport { Damper, SETTLING_TIME } from './Damper.js';\nconst PAN_SENSITIVITY = 0.018;\nconst TAP_DISTANCE = 2;\nconst TAP_MS = 300;\nconst vector2 = new Vector2();\nconst vector3 = new Vector3();\nexport const DEFAULT_OPTIONS = Object.freeze({\n  minimumRadius: 0,\n  maximumRadius: Infinity,\n  minimumPolarAngle: 0,\n  maximumPolarAngle: Math.PI,\n  minimumAzimuthalAngle: -Infinity,\n  maximumAzimuthalAngle: Infinity,\n  minimumFieldOfView: 10,\n  maximumFieldOfView: 45,\n  touchAction: 'none'\n});\n// Constants\nconst KEYBOARD_ORBIT_INCREMENT = Math.PI / 8;\nconst ZOOM_SENSITIVITY = 0.04;\n// The move size on pan key event\nconst PAN_KEY_INCREMENT = 10;\nexport const KeyCode = {\n  PAGE_UP: 33,\n  PAGE_DOWN: 34,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40\n};\nexport const ChangeSource = {\n  USER_INTERACTION: 'user-interaction',\n  NONE: 'none',\n  AUTOMATIC: 'automatic'\n};\n/**\n * SmoothControls is a Three.js helper for adding delightful pointer and\n * keyboard-based input to a staged Three.js scene. Its API is very similar to\n * OrbitControls, but it offers more opinionated (subjectively more delightful)\n * defaults, easy extensibility and subjectively better out-of-the-box keyboard\n * support.\n *\n * One important change compared to OrbitControls is that the `update` method\n * of SmoothControls must be invoked on every frame, otherwise the controls\n * will not have an effect.\n *\n * Another notable difference compared to OrbitControls is that SmoothControls\n * does not currently support panning (but probably will in a future revision).\n *\n * Like OrbitControls, SmoothControls assumes that the orientation of the camera\n * has been set in terms of position, rotation and scale, so it is important to\n * ensure that the camera's matrixWorld is in sync before using SmoothControls.\n */\nexport class SmoothControls extends EventDispatcher {\n  constructor(camera, element, scene) {\n    super();\n    this.camera = camera;\n    this.element = element;\n    this.scene = scene;\n    this.orbitSensitivity = 1;\n    this.zoomSensitivity = 1;\n    this.panSensitivity = 1;\n    this.inputSensitivity = 1;\n    this.changeSource = ChangeSource.NONE;\n    this._interactionEnabled = false;\n    this._disableZoom = false;\n    this.isUserPointing = false;\n    // Pan state\n    this.enablePan = true;\n    this.enableTap = true;\n    this.panProjection = new Matrix3();\n    this.panPerPixel = 0;\n    // Internal orbital position state\n    this.spherical = new Spherical();\n    this.goalSpherical = new Spherical();\n    this.thetaDamper = new Damper();\n    this.phiDamper = new Damper();\n    this.radiusDamper = new Damper();\n    this.logFov = Math.log(DEFAULT_OPTIONS.maximumFieldOfView);\n    this.goalLogFov = this.logFov;\n    this.fovDamper = new Damper();\n    // Pointer state\n    this.touchMode = null;\n    this.pointers = [];\n    this.startTime = 0;\n    this.startPointerPosition = {\n      clientX: 0,\n      clientY: 0\n    };\n    this.lastSeparation = 0;\n    this.touchDecided = false;\n    this.onContext = event => {\n      if (this.enablePan) {\n        event.preventDefault();\n      } else {\n        for (const pointer of this.pointers) {\n          // Required because of a common browser bug where the context menu never\n          // fires a pointercancel event.\n          this.onPointerUp(new PointerEvent('pointercancel', Object.assign(Object.assign({}, this.startPointerPosition), {\n            pointerId: pointer.id\n          })));\n        }\n      }\n    };\n    this.touchModeZoom = (dx, dy) => {\n      if (!this._disableZoom) {\n        const touchDistance = this.twoTouchDistance(this.pointers[0], this.pointers[1]);\n        const deltaZoom = ZOOM_SENSITIVITY * this.zoomSensitivity * (this.lastSeparation - touchDistance) * 50 / this.scene.height;\n        this.lastSeparation = touchDistance;\n        this.userAdjustOrbit(0, 0, deltaZoom);\n      }\n      if (this.panPerPixel > 0) {\n        this.movePan(dx, dy);\n      }\n    };\n    // We implement our own version of the browser's CSS touch-action, enforced by\n    // this function, because the iOS implementation of pan-y is bad and doesn't\n    // match Android. Specifically, even if a touch gesture begins by panning X,\n    // iOS will switch to scrolling as soon as the gesture moves in the Y, rather\n    // than staying in the same mode until the end of the gesture.\n    this.disableScroll = event => {\n      event.preventDefault();\n    };\n    this.touchModeRotate = (dx, dy) => {\n      const {\n        touchAction\n      } = this._options;\n      if (!this.touchDecided && touchAction !== 'none') {\n        this.touchDecided = true;\n        const dxMag = Math.abs(dx);\n        const dyMag = Math.abs(dy);\n        // If motion is mostly vertical, assume scrolling is the intent.\n        if (this.changeSource === ChangeSource.USER_INTERACTION && (touchAction === 'pan-y' && dyMag > dxMag || touchAction === 'pan-x' && dxMag > dyMag)) {\n          this.touchMode = null;\n          return;\n        } else {\n          this.element.addEventListener('touchmove', this.disableScroll, {\n            passive: false\n          });\n        }\n      }\n      this.handleSinglePointerMove(dx, dy);\n    };\n    this.onPointerDown = event => {\n      if (this.pointers.length > 2) {\n        return;\n      }\n      const {\n        element\n      } = this;\n      if (this.pointers.length === 0) {\n        element.addEventListener('pointermove', this.onPointerMove);\n        element.addEventListener('pointerup', this.onPointerUp);\n        this.touchMode = null;\n        this.touchDecided = false;\n        this.startPointerPosition.clientX = event.clientX;\n        this.startPointerPosition.clientY = event.clientY;\n        this.startTime = performance.now();\n      }\n      try {\n        element.setPointerCapture(event.pointerId);\n      } catch (_a) {}\n      this.pointers.push({\n        clientX: event.clientX,\n        clientY: event.clientY,\n        id: event.pointerId\n      });\n      this.isUserPointing = false;\n      if (event.pointerType === 'touch') {\n        this.changeSource = event.altKey ?\n        // set by interact() in controls.ts\n        ChangeSource.AUTOMATIC : ChangeSource.USER_INTERACTION;\n        this.onTouchChange(event);\n      } else {\n        this.changeSource = ChangeSource.USER_INTERACTION;\n        this.onMouseDown(event);\n      }\n      if (this.changeSource === ChangeSource.USER_INTERACTION) {\n        this.dispatchEvent({\n          type: 'user-interaction'\n        });\n      }\n    };\n    this.onPointerMove = event => {\n      const pointer = this.pointers.find(pointer => pointer.id === event.pointerId);\n      if (pointer == null) {\n        return;\n      }\n      // In case no one gave us a pointerup or pointercancel event.\n      if (event.pointerType === 'mouse' && event.buttons === 0) {\n        this.onPointerUp(event);\n        return;\n      }\n      const numTouches = this.pointers.length;\n      const dx = (event.clientX - pointer.clientX) / numTouches;\n      const dy = (event.clientY - pointer.clientY) / numTouches;\n      if (dx === 0 && dy === 0) {\n        return;\n      }\n      pointer.clientX = event.clientX;\n      pointer.clientY = event.clientY;\n      if (event.pointerType === 'touch') {\n        this.changeSource = event.altKey ?\n        // set by interact() in controls.ts\n        ChangeSource.AUTOMATIC : ChangeSource.USER_INTERACTION;\n        if (this.touchMode !== null) {\n          this.touchMode(dx, dy);\n        }\n      } else {\n        this.changeSource = ChangeSource.USER_INTERACTION;\n        if (this.panPerPixel > 0) {\n          this.movePan(dx, dy);\n        } else {\n          this.handleSinglePointerMove(dx, dy);\n        }\n      }\n    };\n    this.onPointerUp = event => {\n      const {\n        element\n      } = this;\n      const index = this.pointers.findIndex(pointer => pointer.id === event.pointerId);\n      if (index !== -1) {\n        this.pointers.splice(index, 1);\n      }\n      // altKey indicates an interaction prompt; don't reset radius in this case\n      // as it will cause the camera to drift.\n      if (this.panPerPixel > 0 && !event.altKey) {\n        this.resetRadius();\n      }\n      if (this.pointers.length === 0) {\n        element.removeEventListener('pointermove', this.onPointerMove);\n        element.removeEventListener('pointerup', this.onPointerUp);\n        element.removeEventListener('touchmove', this.disableScroll);\n        if (this.enablePan && this.enableTap) {\n          this.recenter(event);\n        }\n      } else if (this.touchMode !== null) {\n        this.onTouchChange(event);\n      }\n      this.scene.element[$panElement].style.opacity = 0;\n      element.style.cursor = 'grab';\n      this.panPerPixel = 0;\n      if (this.isUserPointing) {\n        this.dispatchEvent({\n          type: 'pointer-change-end'\n        });\n      }\n    };\n    this.onWheel = event => {\n      this.changeSource = ChangeSource.USER_INTERACTION;\n      const deltaZoom = event.deltaY * (event.deltaMode == 1 ? 18 : 1) * ZOOM_SENSITIVITY * this.zoomSensitivity / 30;\n      this.userAdjustOrbit(0, 0, deltaZoom);\n      event.preventDefault();\n      this.dispatchEvent({\n        type: 'user-interaction'\n      });\n    };\n    this.onKeyDown = event => {\n      // We track if the key is actually one we respond to, so as not to\n      // accidentally clobber unrelated key inputs when the <model-viewer> has\n      // focus.\n      const {\n        changeSource\n      } = this;\n      this.changeSource = ChangeSource.USER_INTERACTION;\n      const relevantKey = event.shiftKey && this.enablePan ? this.panKeyCodeHandler(event) : this.orbitZoomKeyCodeHandler(event);\n      if (relevantKey) {\n        event.preventDefault();\n        this.dispatchEvent({\n          type: 'user-interaction'\n        });\n      } else {\n        this.changeSource = changeSource;\n      }\n    };\n    this._options = Object.assign({}, DEFAULT_OPTIONS);\n    this.setOrbit(0, Math.PI / 2, 1);\n    this.setFieldOfView(100);\n    this.jumpToGoal();\n  }\n  get interactionEnabled() {\n    return this._interactionEnabled;\n  }\n  enableInteraction() {\n    if (this._interactionEnabled === false) {\n      const {\n        element\n      } = this;\n      element.addEventListener('pointerdown', this.onPointerDown);\n      element.addEventListener('pointercancel', this.onPointerUp);\n      if (!this._disableZoom) {\n        element.addEventListener('wheel', this.onWheel);\n      }\n      element.addEventListener('keydown', this.onKeyDown);\n      // This little beauty is to work around a WebKit bug that otherwise makes\n      // touch events randomly not cancelable.\n      element.addEventListener('touchmove', () => {}, {\n        passive: false\n      });\n      element.addEventListener('contextmenu', this.onContext);\n      this.element.style.cursor = 'grab';\n      this._interactionEnabled = true;\n      this.updateTouchActionStyle();\n    }\n  }\n  disableInteraction() {\n    if (this._interactionEnabled === true) {\n      const {\n        element\n      } = this;\n      element.removeEventListener('pointerdown', this.onPointerDown);\n      element.removeEventListener('pointermove', this.onPointerMove);\n      element.removeEventListener('pointerup', this.onPointerUp);\n      element.removeEventListener('pointercancel', this.onPointerUp);\n      element.removeEventListener('wheel', this.onWheel);\n      element.removeEventListener('keydown', this.onKeyDown);\n      element.removeEventListener('contextmenu', this.onContext);\n      element.style.cursor = '';\n      this.touchMode = null;\n      this._interactionEnabled = false;\n      this.updateTouchActionStyle();\n    }\n  }\n  /**\n   * The options that are currently configured for the controls instance.\n   */\n  get options() {\n    return this._options;\n  }\n  set disableZoom(disable) {\n    if (this._disableZoom != disable) {\n      this._disableZoom = disable;\n      if (disable === true) {\n        this.element.removeEventListener('wheel', this.onWheel);\n      } else {\n        this.element.addEventListener('wheel', this.onWheel);\n      }\n      this.updateTouchActionStyle();\n    }\n  }\n  /**\n   * Copy the spherical values that represent the current camera orbital\n   * position relative to the configured target into a provided Spherical\n   * instance. If no Spherical is provided, a new Spherical will be allocated\n   * to copy the values into. The Spherical that values are copied into is\n   * returned.\n   */\n  getCameraSpherical(target = new Spherical()) {\n    return target.copy(this.spherical);\n  }\n  /**\n   * Returns the camera's current vertical field of view in degrees.\n   */\n  getFieldOfView() {\n    return this.camera.fov;\n  }\n  /**\n   * Configure the _options of the controls. Configured _options will be\n   * merged with whatever _options have already been configured for this\n   * controls instance.\n   */\n  applyOptions(_options) {\n    Object.assign(this._options, _options);\n    // Re-evaluates clamping based on potentially new values for min/max\n    // polar, azimuth and radius:\n    this.setOrbit();\n    this.setFieldOfView(Math.exp(this.goalLogFov));\n  }\n  /**\n   * Sets the near and far planes of the camera.\n   */\n  updateNearFar(nearPlane, farPlane) {\n    this.camera.far = farPlane === 0 ? 2 : farPlane;\n    this.camera.near = Math.max(nearPlane, this.camera.far / 1000);\n    this.camera.updateProjectionMatrix();\n  }\n  /**\n   * Sets the aspect ratio of the camera\n   */\n  updateAspect(aspect) {\n    this.camera.aspect = aspect;\n    this.camera.updateProjectionMatrix();\n  }\n  /**\n   * Set the absolute orbital goal of the camera. The change will be\n   * applied over a number of frames depending on configured acceleration and\n   * dampening _options.\n   *\n   * Returns true if invoking the method will result in the camera changing\n   * position and/or rotation, otherwise false.\n   */\n  setOrbit(goalTheta = this.goalSpherical.theta, goalPhi = this.goalSpherical.phi, goalRadius = this.goalSpherical.radius) {\n    const {\n      minimumAzimuthalAngle,\n      maximumAzimuthalAngle,\n      minimumPolarAngle,\n      maximumPolarAngle,\n      minimumRadius,\n      maximumRadius\n    } = this._options;\n    const {\n      theta,\n      phi,\n      radius\n    } = this.goalSpherical;\n    const nextTheta = clamp(goalTheta, minimumAzimuthalAngle, maximumAzimuthalAngle);\n    if (!isFinite(minimumAzimuthalAngle) && !isFinite(maximumAzimuthalAngle)) {\n      this.spherical.theta = this.wrapAngle(this.spherical.theta - nextTheta) + nextTheta;\n    }\n    const nextPhi = clamp(goalPhi, minimumPolarAngle, maximumPolarAngle);\n    const nextRadius = clamp(goalRadius, minimumRadius, maximumRadius);\n    if (nextTheta === theta && nextPhi === phi && nextRadius === radius) {\n      return false;\n    }\n    if (!isFinite(nextTheta) || !isFinite(nextPhi) || !isFinite(nextRadius)) {\n      return false;\n    }\n    this.goalSpherical.theta = nextTheta;\n    this.goalSpherical.phi = nextPhi;\n    this.goalSpherical.radius = nextRadius;\n    this.goalSpherical.makeSafe();\n    return true;\n  }\n  /**\n   * Subset of setOrbit() above, which only sets the camera's radius.\n   */\n  setRadius(radius) {\n    this.goalSpherical.radius = radius;\n    this.setOrbit();\n  }\n  /**\n   * Sets the goal field of view for the camera\n   */\n  setFieldOfView(fov) {\n    const {\n      minimumFieldOfView,\n      maximumFieldOfView\n    } = this._options;\n    fov = clamp(fov, minimumFieldOfView, maximumFieldOfView);\n    this.goalLogFov = Math.log(fov);\n  }\n  /**\n   * Sets the smoothing decay time.\n   */\n  setDamperDecayTime(decayMilliseconds) {\n    this.thetaDamper.setDecayTime(decayMilliseconds);\n    this.phiDamper.setDecayTime(decayMilliseconds);\n    this.radiusDamper.setDecayTime(decayMilliseconds);\n    this.fovDamper.setDecayTime(decayMilliseconds);\n  }\n  /**\n   * Adjust the orbital position of the camera relative to its current orbital\n   * position. Does not let the theta goal get more than pi ahead of the current\n   * theta, which ensures interpolation continues in the direction of the delta.\n   * The deltaZoom parameter adjusts both the field of view and the orbit radius\n   * such that they progress across their allowed ranges in sync.\n   */\n  adjustOrbit(deltaTheta, deltaPhi, deltaZoom) {\n    const {\n      theta,\n      phi,\n      radius\n    } = this.goalSpherical;\n    const {\n      minimumRadius,\n      maximumRadius,\n      minimumFieldOfView,\n      maximumFieldOfView\n    } = this._options;\n    const dTheta = this.spherical.theta - theta;\n    const dThetaLimit = Math.PI - 0.001;\n    const goalTheta = theta - clamp(deltaTheta, -dThetaLimit - dTheta, dThetaLimit - dTheta);\n    const goalPhi = phi - deltaPhi;\n    const deltaRatio = deltaZoom === 0 ? 0 : ((deltaZoom > 0 ? maximumRadius : minimumRadius) - radius) / (Math.log(deltaZoom > 0 ? maximumFieldOfView : minimumFieldOfView) - this.goalLogFov);\n    const goalRadius = radius + deltaZoom * (isFinite(deltaRatio) ? deltaRatio : (maximumRadius - minimumRadius) * 2);\n    this.setOrbit(goalTheta, goalPhi, goalRadius);\n    if (deltaZoom !== 0) {\n      const goalLogFov = this.goalLogFov + deltaZoom;\n      this.setFieldOfView(Math.exp(goalLogFov));\n    }\n  }\n  /**\n   * Move the camera instantly instead of accelerating toward the goal\n   * parameters.\n   */\n  jumpToGoal() {\n    this.update(0, SETTLING_TIME);\n  }\n  /**\n   * Update controls. In most cases, this will result in the camera\n   * interpolating its position and rotation until it lines up with the\n   * designated goal orbital position. Returns false if the camera did not move.\n   *\n   * Time and delta are measured in milliseconds.\n   */\n  update(_time, delta) {\n    if (this.isStationary()) {\n      return false;\n    }\n    const {\n      maximumPolarAngle,\n      maximumRadius\n    } = this._options;\n    const dTheta = this.spherical.theta - this.goalSpherical.theta;\n    if (Math.abs(dTheta) > Math.PI && !isFinite(this._options.minimumAzimuthalAngle) && !isFinite(this._options.maximumAzimuthalAngle)) {\n      this.spherical.theta -= Math.sign(dTheta) * 2 * Math.PI;\n    }\n    this.spherical.theta = this.thetaDamper.update(this.spherical.theta, this.goalSpherical.theta, delta, Math.PI);\n    this.spherical.phi = this.phiDamper.update(this.spherical.phi, this.goalSpherical.phi, delta, maximumPolarAngle);\n    this.spherical.radius = this.radiusDamper.update(this.spherical.radius, this.goalSpherical.radius, delta, maximumRadius);\n    this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, delta, 1);\n    this.moveCamera();\n    return true;\n  }\n  updateTouchActionStyle() {\n    const {\n      style\n    } = this.element;\n    if (this._interactionEnabled) {\n      const {\n        touchAction\n      } = this._options;\n      if (this._disableZoom && touchAction !== 'none') {\n        style.touchAction = 'manipulation';\n      } else {\n        style.touchAction = touchAction;\n      }\n    } else {\n      style.touchAction = '';\n    }\n  }\n  isStationary() {\n    return this.goalSpherical.theta === this.spherical.theta && this.goalSpherical.phi === this.spherical.phi && this.goalSpherical.radius === this.spherical.radius && this.goalLogFov === this.logFov;\n  }\n  moveCamera() {\n    // Derive the new camera position from the updated spherical:\n    this.spherical.makeSafe();\n    this.camera.position.setFromSpherical(this.spherical);\n    this.camera.setRotationFromEuler(new Euler(this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, 'YXZ'));\n    if (this.camera.fov !== Math.exp(this.logFov)) {\n      this.camera.fov = Math.exp(this.logFov);\n      this.camera.updateProjectionMatrix();\n    }\n  }\n  userAdjustOrbit(deltaTheta, deltaPhi, deltaZoom) {\n    this.adjustOrbit(deltaTheta * this.orbitSensitivity * this.inputSensitivity, deltaPhi * this.orbitSensitivity * this.inputSensitivity, deltaZoom * this.inputSensitivity);\n  }\n  // Wraps to between -pi and pi\n  wrapAngle(radians) {\n    const normalized = (radians + Math.PI) / (2 * Math.PI);\n    const wrapped = normalized - Math.floor(normalized);\n    return wrapped * 2 * Math.PI - Math.PI;\n  }\n  pixelLengthToSphericalAngle(pixelLength) {\n    return 2 * Math.PI * pixelLength / this.scene.height;\n  }\n  twoTouchDistance(touchOne, touchTwo) {\n    const {\n      clientX: xOne,\n      clientY: yOne\n    } = touchOne;\n    const {\n      clientX: xTwo,\n      clientY: yTwo\n    } = touchTwo;\n    const xDelta = xTwo - xOne;\n    const yDelta = yTwo - yOne;\n    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);\n  }\n  handleSinglePointerMove(dx, dy) {\n    const deltaTheta = this.pixelLengthToSphericalAngle(dx);\n    const deltaPhi = this.pixelLengthToSphericalAngle(dy);\n    if (this.isUserPointing === false) {\n      this.isUserPointing = true;\n      this.dispatchEvent({\n        type: 'pointer-change-start'\n      });\n    }\n    this.userAdjustOrbit(deltaTheta, deltaPhi, 0);\n  }\n  initializePan() {\n    const {\n      theta,\n      phi\n    } = this.spherical;\n    const psi = theta - this.scene.yaw;\n    this.panPerPixel = PAN_SENSITIVITY * this.panSensitivity / this.scene.height;\n    this.panProjection.set(-Math.cos(psi), -Math.cos(phi) * Math.sin(psi), 0, 0, Math.sin(phi), 0, Math.sin(psi), -Math.cos(phi) * Math.cos(psi), 0);\n  }\n  movePan(dx, dy) {\n    const {\n      scene\n    } = this;\n    const dxy = vector3.set(dx, dy, 0).multiplyScalar(this.inputSensitivity);\n    const metersPerPixel = this.spherical.radius * Math.exp(this.logFov) * this.panPerPixel;\n    dxy.multiplyScalar(metersPerPixel);\n    const target = scene.getTarget();\n    target.add(dxy.applyMatrix3(this.panProjection));\n    scene.boundingSphere.clampPoint(target, target);\n    scene.setTarget(target.x, target.y, target.z);\n  }\n  recenter(pointer) {\n    if (performance.now() > this.startTime + TAP_MS || Math.abs(pointer.clientX - this.startPointerPosition.clientX) > TAP_DISTANCE || Math.abs(pointer.clientY - this.startPointerPosition.clientY) > TAP_DISTANCE) {\n      return;\n    }\n    const {\n      scene\n    } = this;\n    const hit = scene.positionAndNormalFromPoint(scene.getNDC(pointer.clientX, pointer.clientY));\n    if (hit == null) {\n      const {\n        cameraTarget\n      } = scene.element;\n      scene.element.cameraTarget = '';\n      scene.element.cameraTarget = cameraTarget;\n      // Zoom all the way out.\n      this.userAdjustOrbit(0, 0, 1);\n    } else {\n      scene.target.worldToLocal(hit.position);\n      scene.setTarget(hit.position.x, hit.position.y, hit.position.z);\n    }\n  }\n  resetRadius() {\n    const {\n      scene\n    } = this;\n    const hit = scene.positionAndNormalFromPoint(vector2.set(0, 0));\n    if (hit == null) {\n      return;\n    }\n    scene.target.worldToLocal(hit.position);\n    const goalTarget = scene.getTarget();\n    const {\n      theta,\n      phi\n    } = this.spherical;\n    // Set target to surface hit point, except the target is still settling,\n    // so offset the goal accordingly so the transition is smooth even though\n    // this will drift the target slightly away from the hit point.\n    const psi = theta - scene.yaw;\n    const n = vector3.set(Math.sin(phi) * Math.sin(psi), Math.cos(phi), Math.sin(phi) * Math.cos(psi));\n    const dr = n.dot(hit.position.sub(goalTarget));\n    goalTarget.add(n.multiplyScalar(dr));\n    scene.setTarget(goalTarget.x, goalTarget.y, goalTarget.z);\n    // Change the camera radius to match the change in target so that the\n    // camera itself does not move, unless it hits a radius bound.\n    this.setOrbit(undefined, undefined, this.goalSpherical.radius - dr);\n  }\n  onTouchChange(event) {\n    if (this.pointers.length === 1) {\n      this.touchMode = this.touchModeRotate;\n    } else {\n      if (this._disableZoom) {\n        this.touchMode = null;\n        this.element.removeEventListener('touchmove', this.disableScroll);\n        return;\n      }\n      this.touchMode = this.touchDecided && this.touchMode === null ? null : this.touchModeZoom;\n      this.touchDecided = true;\n      this.element.addEventListener('touchmove', this.disableScroll, {\n        passive: false\n      });\n      this.lastSeparation = this.twoTouchDistance(this.pointers[0], this.pointers[1]);\n      if (this.enablePan && this.touchMode != null) {\n        this.initializePan();\n        if (!event.altKey) {\n          // user interaction, not prompt\n          this.scene.element[$panElement].style.opacity = 1;\n        }\n      }\n    }\n  }\n  onMouseDown(event) {\n    this.panPerPixel = 0;\n    if (this.enablePan && (event.button === 2 || event.ctrlKey || event.metaKey || event.shiftKey)) {\n      this.initializePan();\n      this.scene.element[$panElement].style.opacity = 1;\n    }\n    this.element.style.cursor = 'grabbing';\n  }\n  /**\n   * Handles the orbit and Zoom key presses\n   * Uses constants for the increment.\n   * @param event The keyboard event for the .key value\n   * @returns boolean to indicate if the key event has been handled\n   */\n  orbitZoomKeyCodeHandler(event) {\n    let relevantKey = true;\n    switch (event.key) {\n      case 'PageUp':\n        this.userAdjustOrbit(0, 0, ZOOM_SENSITIVITY * this.zoomSensitivity);\n        break;\n      case 'PageDown':\n        this.userAdjustOrbit(0, 0, -1 * ZOOM_SENSITIVITY * this.zoomSensitivity);\n        break;\n      case 'ArrowUp':\n        this.userAdjustOrbit(0, -KEYBOARD_ORBIT_INCREMENT, 0);\n        break;\n      case 'ArrowDown':\n        this.userAdjustOrbit(0, KEYBOARD_ORBIT_INCREMENT, 0);\n        break;\n      case 'ArrowLeft':\n        this.userAdjustOrbit(-KEYBOARD_ORBIT_INCREMENT, 0, 0);\n        break;\n      case 'ArrowRight':\n        this.userAdjustOrbit(KEYBOARD_ORBIT_INCREMENT, 0, 0);\n        break;\n      default:\n        relevantKey = false;\n        break;\n    }\n    return relevantKey;\n  }\n  /**\n   * Handles the Pan key presses\n   * Uses constants for the increment.\n   * @param event The keyboard event for the .key value\n   * @returns boolean to indicate if the key event has been handled\n   */\n  panKeyCodeHandler(event) {\n    this.initializePan();\n    let relevantKey = true;\n    switch (event.key) {\n      case 'ArrowUp':\n        this.movePan(0, -1 * PAN_KEY_INCREMENT); // This is the negative one so that the\n        // model appears to move as the arrow\n        // direction rather than the view moving\n        break;\n      case 'ArrowDown':\n        this.movePan(0, PAN_KEY_INCREMENT);\n        break;\n      case 'ArrowLeft':\n        this.movePan(-1 * PAN_KEY_INCREMENT, 0);\n        break;\n      case 'ArrowRight':\n        this.movePan(PAN_KEY_INCREMENT, 0);\n        break;\n      default:\n        relevantKey = false;\n        break;\n    }\n    return relevantKey;\n  }\n}","map":{"version":3,"names":["Euler","EventDispatcher","Matrix3","Spherical","Vector2","Vector3","$panElement","clamp","Damper","SETTLING_TIME","PAN_SENSITIVITY","TAP_DISTANCE","TAP_MS","vector2","vector3","DEFAULT_OPTIONS","Object","freeze","minimumRadius","maximumRadius","Infinity","minimumPolarAngle","maximumPolarAngle","Math","PI","minimumAzimuthalAngle","maximumAzimuthalAngle","minimumFieldOfView","maximumFieldOfView","touchAction","KEYBOARD_ORBIT_INCREMENT","ZOOM_SENSITIVITY","PAN_KEY_INCREMENT","KeyCode","PAGE_UP","PAGE_DOWN","LEFT","UP","RIGHT","DOWN","ChangeSource","USER_INTERACTION","NONE","AUTOMATIC","SmoothControls","constructor","camera","element","scene","orbitSensitivity","zoomSensitivity","panSensitivity","inputSensitivity","changeSource","_interactionEnabled","_disableZoom","isUserPointing","enablePan","enableTap","panProjection","panPerPixel","spherical","goalSpherical","thetaDamper","phiDamper","radiusDamper","logFov","log","goalLogFov","fovDamper","touchMode","pointers","startTime","startPointerPosition","clientX","clientY","lastSeparation","touchDecided","onContext","event","preventDefault","pointer","onPointerUp","PointerEvent","assign","pointerId","id","touchModeZoom","dx","dy","touchDistance","twoTouchDistance","deltaZoom","height","userAdjustOrbit","movePan","disableScroll","touchModeRotate","_options","dxMag","abs","dyMag","addEventListener","passive","handleSinglePointerMove","onPointerDown","length","onPointerMove","performance","now","setPointerCapture","_a","push","pointerType","altKey","onTouchChange","onMouseDown","dispatchEvent","type","find","buttons","numTouches","index","findIndex","splice","resetRadius","removeEventListener","recenter","style","opacity","cursor","onWheel","deltaY","deltaMode","onKeyDown","relevantKey","shiftKey","panKeyCodeHandler","orbitZoomKeyCodeHandler","setOrbit","setFieldOfView","jumpToGoal","interactionEnabled","enableInteraction","updateTouchActionStyle","disableInteraction","options","disableZoom","disable","getCameraSpherical","target","copy","getFieldOfView","fov","applyOptions","exp","updateNearFar","nearPlane","farPlane","far","near","max","updateProjectionMatrix","updateAspect","aspect","goalTheta","theta","goalPhi","phi","goalRadius","radius","nextTheta","isFinite","wrapAngle","nextPhi","nextRadius","makeSafe","setRadius","setDamperDecayTime","decayMilliseconds","setDecayTime","adjustOrbit","deltaTheta","deltaPhi","dTheta","dThetaLimit","deltaRatio","update","_time","delta","isStationary","sign","moveCamera","position","setFromSpherical","setRotationFromEuler","radians","normalized","wrapped","floor","pixelLengthToSphericalAngle","pixelLength","touchOne","touchTwo","xOne","yOne","xTwo","yTwo","xDelta","yDelta","sqrt","initializePan","psi","yaw","set","cos","sin","dxy","multiplyScalar","metersPerPixel","getTarget","add","applyMatrix3","boundingSphere","clampPoint","setTarget","x","y","z","hit","positionAndNormalFromPoint","getNDC","cameraTarget","worldToLocal","goalTarget","n","dr","dot","sub","undefined","button","ctrlKey","metaKey","key"],"sources":["../../src/three-components/SmoothControls.ts"],"sourcesContent":["/* @license\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Euler, Event as ThreeEvent, EventDispatcher, Matrix3, PerspectiveCamera, Spherical, Vector2, Vector3} from 'three';\n\nimport {$panElement, TouchAction} from '../features/controls.js';\nimport {clamp} from '../utilities.js';\n\nimport {Damper, SETTLING_TIME} from './Damper.js';\nimport {ModelScene} from './ModelScene.js';\n\nconst PAN_SENSITIVITY = 0.018;\nconst TAP_DISTANCE = 2;\nconst TAP_MS = 300;\nconst vector2 = new Vector2();\nconst vector3 = new Vector3();\n\nexport type TouchMode = null|((dx: number, dy: number) => void);\n\nexport interface Pointer {\n  clientX: number;\n  clientY: number;\n  id: number;\n}\n\nexport interface SmoothControlsOptions {\n  // The closest the camera can be to the target\n  minimumRadius?: number;\n  // The farthest the camera can be from the target\n  maximumRadius?: number;\n  // The minimum angle between model-up and the camera polar position\n  minimumPolarAngle?: number;\n  // The maximum angle between model-up and the camera polar position\n  maximumPolarAngle?: number;\n  // The minimum angle between model-forward and the camera azimuthal position\n  minimumAzimuthalAngle?: number;\n  // The maximum angle between model-forward and the camera azimuthal position\n  maximumAzimuthalAngle?: number;\n  // The minimum camera field of view in degrees\n  minimumFieldOfView?: number;\n  // The maximum camera field of view in degrees\n  maximumFieldOfView?: number;\n  // Controls scrolling behavior\n  touchAction?: TouchAction;\n}\n\nexport const DEFAULT_OPTIONS = Object.freeze<SmoothControlsOptions>({\n  minimumRadius: 0,\n  maximumRadius: Infinity,\n  minimumPolarAngle: 0,\n  maximumPolarAngle: Math.PI,\n  minimumAzimuthalAngle: -Infinity,\n  maximumAzimuthalAngle: Infinity,\n  minimumFieldOfView: 10,\n  maximumFieldOfView: 45,\n  touchAction: 'none'\n});\n\n// Constants\nconst KEYBOARD_ORBIT_INCREMENT = Math.PI / 8;\nconst ZOOM_SENSITIVITY = 0.04;\n\n// The move size on pan key event\nconst PAN_KEY_INCREMENT = 10;\n\nexport const KeyCode = {\n  PAGE_UP: 33,\n  PAGE_DOWN: 34,\n  LEFT: 37,\n  UP: 38,\n  RIGHT: 39,\n  DOWN: 40\n};\n\nexport type ChangeSource = 'user-interaction'|'none'|'automatic';\n\nexport const ChangeSource: {[index: string]: ChangeSource} = {\n  USER_INTERACTION: 'user-interaction',\n  NONE: 'none',\n  AUTOMATIC: 'automatic'\n};\n\n/**\n * ChangEvents are dispatched whenever the camera position or orientation has\n * changed\n */\nexport interface ChangeEvent extends ThreeEvent {\n  /**\n   * determines what was the originating reason for the change event eg user or\n   * none\n   */\n  source: ChangeSource,\n}\n\nexport interface PointerChangeEvent extends ThreeEvent {\n  type: 'pointer-change-start'|'pointer-change-end';\n}\n\n/**\n * SmoothControls is a Three.js helper for adding delightful pointer and\n * keyboard-based input to a staged Three.js scene. Its API is very similar to\n * OrbitControls, but it offers more opinionated (subjectively more delightful)\n * defaults, easy extensibility and subjectively better out-of-the-box keyboard\n * support.\n *\n * One important change compared to OrbitControls is that the `update` method\n * of SmoothControls must be invoked on every frame, otherwise the controls\n * will not have an effect.\n *\n * Another notable difference compared to OrbitControls is that SmoothControls\n * does not currently support panning (but probably will in a future revision).\n *\n * Like OrbitControls, SmoothControls assumes that the orientation of the camera\n * has been set in terms of position, rotation and scale, so it is important to\n * ensure that the camera's matrixWorld is in sync before using SmoothControls.\n */\nexport class SmoothControls extends EventDispatcher<{\n  'user-interaction': {},\n  'pointer-change-start': {},\n  'pointer-change-end': {}\n}> {\n  public orbitSensitivity = 1;\n  public zoomSensitivity = 1;\n  public panSensitivity = 1;\n  public inputSensitivity = 1;\n  public changeSource = ChangeSource.NONE;\n\n  private _interactionEnabled: boolean = false;\n  private _options: SmoothControlsOptions;\n  private _disableZoom = false;\n  private isUserPointing = false;\n\n  // Pan state\n  public enablePan = true;\n  public enableTap = true;\n  private panProjection = new Matrix3();\n  private panPerPixel = 0;\n\n  // Internal orbital position state\n  private spherical = new Spherical();\n  private goalSpherical = new Spherical();\n  private thetaDamper = new Damper();\n  private phiDamper = new Damper();\n  private radiusDamper = new Damper();\n  private logFov = Math.log(DEFAULT_OPTIONS.maximumFieldOfView!);\n  private goalLogFov = this.logFov;\n  private fovDamper = new Damper();\n\n  // Pointer state\n  private touchMode: TouchMode = null;\n  private pointers: Pointer[] = [];\n  private startTime = 0;\n  private startPointerPosition = {clientX: 0, clientY: 0};\n  private lastSeparation = 0;\n  private touchDecided = false;\n\n  constructor(\n      readonly camera: PerspectiveCamera, readonly element: HTMLElement,\n      readonly scene: ModelScene) {\n    super();\n\n    this._options = Object.assign({}, DEFAULT_OPTIONS);\n\n    this.setOrbit(0, Math.PI / 2, 1);\n    this.setFieldOfView(100);\n    this.jumpToGoal();\n  }\n\n  get interactionEnabled(): boolean {\n    return this._interactionEnabled;\n  }\n\n  enableInteraction() {\n    if (this._interactionEnabled === false) {\n      const {element} = this;\n      element.addEventListener('pointerdown', this.onPointerDown);\n      element.addEventListener('pointercancel', this.onPointerUp);\n\n      if (!this._disableZoom) {\n        element.addEventListener('wheel', this.onWheel);\n      }\n      element.addEventListener('keydown', this.onKeyDown);\n      // This little beauty is to work around a WebKit bug that otherwise makes\n      // touch events randomly not cancelable.\n      element.addEventListener('touchmove', () => {}, {passive: false});\n      element.addEventListener('contextmenu', this.onContext);\n\n      this.element.style.cursor = 'grab';\n      this._interactionEnabled = true;\n\n      this.updateTouchActionStyle();\n    }\n  }\n\n  disableInteraction() {\n    if (this._interactionEnabled === true) {\n      const {element} = this;\n\n      element.removeEventListener('pointerdown', this.onPointerDown);\n      element.removeEventListener('pointermove', this.onPointerMove);\n      element.removeEventListener('pointerup', this.onPointerUp);\n      element.removeEventListener('pointercancel', this.onPointerUp);\n      element.removeEventListener('wheel', this.onWheel);\n      element.removeEventListener('keydown', this.onKeyDown);\n      element.removeEventListener('contextmenu', this.onContext);\n\n      element.style.cursor = '';\n      this.touchMode = null;\n      this._interactionEnabled = false;\n\n      this.updateTouchActionStyle();\n    }\n  }\n\n  /**\n   * The options that are currently configured for the controls instance.\n   */\n  get options() {\n    return this._options;\n  }\n\n  onContext = (event: MouseEvent) => {\n    if (this.enablePan) {\n      event.preventDefault();\n    } else {\n      for (const pointer of this.pointers) {\n        // Required because of a common browser bug where the context menu never\n        // fires a pointercancel event.\n        this.onPointerUp(new PointerEvent(\n            'pointercancel',\n            {...this.startPointerPosition, pointerId: pointer.id}));\n      }\n    }\n  };\n\n  set disableZoom(disable: boolean) {\n    if (this._disableZoom != disable) {\n      this._disableZoom = disable;\n      if (disable === true) {\n        this.element.removeEventListener('wheel', this.onWheel);\n      } else {\n        this.element.addEventListener('wheel', this.onWheel);\n      }\n\n      this.updateTouchActionStyle();\n    }\n  }\n\n  /**\n   * Copy the spherical values that represent the current camera orbital\n   * position relative to the configured target into a provided Spherical\n   * instance. If no Spherical is provided, a new Spherical will be allocated\n   * to copy the values into. The Spherical that values are copied into is\n   * returned.\n   */\n  getCameraSpherical(target: Spherical = new Spherical()) {\n    return target.copy(this.spherical);\n  }\n\n  /**\n   * Returns the camera's current vertical field of view in degrees.\n   */\n  getFieldOfView(): number {\n    return this.camera.fov;\n  }\n\n  /**\n   * Configure the _options of the controls. Configured _options will be\n   * merged with whatever _options have already been configured for this\n   * controls instance.\n   */\n  applyOptions(_options: SmoothControlsOptions) {\n    Object.assign(this._options, _options);\n    // Re-evaluates clamping based on potentially new values for min/max\n    // polar, azimuth and radius:\n    this.setOrbit();\n    this.setFieldOfView(Math.exp(this.goalLogFov));\n  }\n\n  /**\n   * Sets the near and far planes of the camera.\n   */\n  updateNearFar(nearPlane: number, farPlane: number) {\n    this.camera.far = farPlane === 0 ? 2 : farPlane;\n    this.camera.near = Math.max(nearPlane, this.camera.far / 1000);\n    this.camera.updateProjectionMatrix();\n  }\n\n  /**\n   * Sets the aspect ratio of the camera\n   */\n  updateAspect(aspect: number) {\n    this.camera.aspect = aspect;\n    this.camera.updateProjectionMatrix();\n  }\n\n  /**\n   * Set the absolute orbital goal of the camera. The change will be\n   * applied over a number of frames depending on configured acceleration and\n   * dampening _options.\n   *\n   * Returns true if invoking the method will result in the camera changing\n   * position and/or rotation, otherwise false.\n   */\n  setOrbit(\n      goalTheta: number = this.goalSpherical.theta,\n      goalPhi: number = this.goalSpherical.phi,\n      goalRadius: number = this.goalSpherical.radius): boolean {\n    const {\n      minimumAzimuthalAngle,\n      maximumAzimuthalAngle,\n      minimumPolarAngle,\n      maximumPolarAngle,\n      minimumRadius,\n      maximumRadius\n    } = this._options;\n\n    const {theta, phi, radius} = this.goalSpherical;\n\n    const nextTheta =\n        clamp(goalTheta, minimumAzimuthalAngle!, maximumAzimuthalAngle!);\n    if (!isFinite(minimumAzimuthalAngle!) &&\n        !isFinite(maximumAzimuthalAngle!)) {\n      this.spherical.theta =\n          this.wrapAngle(this.spherical.theta - nextTheta) + nextTheta;\n    }\n\n    const nextPhi = clamp(goalPhi, minimumPolarAngle!, maximumPolarAngle!);\n    const nextRadius = clamp(goalRadius, minimumRadius!, maximumRadius!);\n\n    if (nextTheta === theta && nextPhi === phi && nextRadius === radius) {\n      return false;\n    }\n\n    if (!isFinite(nextTheta) || !isFinite(nextPhi) || !isFinite(nextRadius)) {\n      return false;\n    }\n\n    this.goalSpherical.theta = nextTheta;\n    this.goalSpherical.phi = nextPhi;\n    this.goalSpherical.radius = nextRadius;\n    this.goalSpherical.makeSafe();\n\n    return true;\n  }\n\n  /**\n   * Subset of setOrbit() above, which only sets the camera's radius.\n   */\n  setRadius(radius: number) {\n    this.goalSpherical.radius = radius;\n    this.setOrbit();\n  }\n\n  /**\n   * Sets the goal field of view for the camera\n   */\n  setFieldOfView(fov: number) {\n    const {minimumFieldOfView, maximumFieldOfView} = this._options;\n    fov = clamp(fov, minimumFieldOfView!, maximumFieldOfView!);\n    this.goalLogFov = Math.log(fov);\n  }\n\n  /**\n   * Sets the smoothing decay time.\n   */\n  setDamperDecayTime(decayMilliseconds: number) {\n    this.thetaDamper.setDecayTime(decayMilliseconds);\n    this.phiDamper.setDecayTime(decayMilliseconds);\n    this.radiusDamper.setDecayTime(decayMilliseconds);\n    this.fovDamper.setDecayTime(decayMilliseconds);\n  }\n\n  /**\n   * Adjust the orbital position of the camera relative to its current orbital\n   * position. Does not let the theta goal get more than pi ahead of the current\n   * theta, which ensures interpolation continues in the direction of the delta.\n   * The deltaZoom parameter adjusts both the field of view and the orbit radius\n   * such that they progress across their allowed ranges in sync.\n   */\n  adjustOrbit(deltaTheta: number, deltaPhi: number, deltaZoom: number) {\n    const {theta, phi, radius} = this.goalSpherical;\n    const {\n      minimumRadius,\n      maximumRadius,\n      minimumFieldOfView,\n      maximumFieldOfView\n    } = this._options;\n\n    const dTheta = this.spherical.theta - theta;\n    const dThetaLimit = Math.PI - 0.001;\n    const goalTheta =\n        theta - clamp(deltaTheta, -dThetaLimit - dTheta, dThetaLimit - dTheta);\n    const goalPhi = phi - deltaPhi;\n\n    const deltaRatio = deltaZoom === 0 ?\n        0 :\n        ((deltaZoom > 0 ? maximumRadius! : minimumRadius!) - radius) /\n            (Math.log(\n                 deltaZoom > 0 ? maximumFieldOfView! : minimumFieldOfView!) -\n             this.goalLogFov);\n\n    const goalRadius = radius +\n        deltaZoom *\n            (isFinite(deltaRatio) ? deltaRatio :\n                                    (maximumRadius! - minimumRadius!) * 2);\n    this.setOrbit(goalTheta, goalPhi, goalRadius);\n\n    if (deltaZoom !== 0) {\n      const goalLogFov = this.goalLogFov + deltaZoom;\n      this.setFieldOfView(Math.exp(goalLogFov));\n    }\n  }\n\n  /**\n   * Move the camera instantly instead of accelerating toward the goal\n   * parameters.\n   */\n  jumpToGoal() {\n    this.update(0, SETTLING_TIME);\n  }\n\n  /**\n   * Update controls. In most cases, this will result in the camera\n   * interpolating its position and rotation until it lines up with the\n   * designated goal orbital position. Returns false if the camera did not move.\n   *\n   * Time and delta are measured in milliseconds.\n   */\n  update(_time: number, delta: number): boolean {\n    if (this.isStationary()) {\n      return false;\n    }\n    const {maximumPolarAngle, maximumRadius} = this._options;\n\n    const dTheta = this.spherical.theta - this.goalSpherical.theta;\n    if (Math.abs(dTheta) > Math.PI &&\n        !isFinite(this._options.minimumAzimuthalAngle!) &&\n        !isFinite(this._options.maximumAzimuthalAngle!)) {\n      this.spherical.theta -= Math.sign(dTheta) * 2 * Math.PI;\n    }\n\n    this.spherical.theta = this.thetaDamper.update(\n        this.spherical.theta, this.goalSpherical.theta, delta, Math.PI);\n\n    this.spherical.phi = this.phiDamper.update(\n        this.spherical.phi, this.goalSpherical.phi, delta, maximumPolarAngle!);\n\n    this.spherical.radius = this.radiusDamper.update(\n        this.spherical.radius, this.goalSpherical.radius, delta, maximumRadius!\n    );\n\n    this.logFov = this.fovDamper.update(this.logFov, this.goalLogFov, delta, 1);\n\n    this.moveCamera();\n    return true;\n  }\n\n  updateTouchActionStyle() {\n    const {style} = this.element;\n\n    if (this._interactionEnabled) {\n      const {touchAction} = this._options;\n      if (this._disableZoom && touchAction !== 'none') {\n        style.touchAction = 'manipulation';\n      } else {\n        style.touchAction = touchAction!;\n      }\n    } else {\n      style.touchAction = '';\n    }\n  }\n\n  private isStationary(): boolean {\n    return this.goalSpherical.theta === this.spherical.theta &&\n        this.goalSpherical.phi === this.spherical.phi &&\n        this.goalSpherical.radius === this.spherical.radius &&\n        this.goalLogFov === this.logFov;\n  }\n\n  private moveCamera() {\n    // Derive the new camera position from the updated spherical:\n    this.spherical.makeSafe();\n    this.camera.position.setFromSpherical(this.spherical);\n    this.camera.setRotationFromEuler(new Euler(\n        this.spherical.phi - Math.PI / 2, this.spherical.theta, 0, 'YXZ'));\n\n    if (this.camera.fov !== Math.exp(this.logFov)) {\n      this.camera.fov = Math.exp(this.logFov);\n      this.camera.updateProjectionMatrix();\n    }\n  }\n\n  private userAdjustOrbit(\n      deltaTheta: number, deltaPhi: number, deltaZoom: number) {\n    this.adjustOrbit(\n        deltaTheta * this.orbitSensitivity * this.inputSensitivity,\n        deltaPhi * this.orbitSensitivity * this.inputSensitivity,\n        deltaZoom * this.inputSensitivity);\n  }\n\n  // Wraps to between -pi and pi\n  private wrapAngle(radians: number): number {\n    const normalized = (radians + Math.PI) / (2 * Math.PI);\n    const wrapped = normalized - Math.floor(normalized);\n    return wrapped * 2 * Math.PI - Math.PI;\n  }\n\n  private pixelLengthToSphericalAngle(pixelLength: number): number {\n    return 2 * Math.PI * pixelLength / this.scene.height;\n  }\n\n  private twoTouchDistance(touchOne: Pointer, touchTwo: Pointer): number {\n    const {clientX: xOne, clientY: yOne} = touchOne;\n    const {clientX: xTwo, clientY: yTwo} = touchTwo;\n    const xDelta = xTwo - xOne;\n    const yDelta = yTwo - yOne;\n\n    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);\n  }\n\n  private touchModeZoom: TouchMode = (dx: number, dy: number) => {\n    if (!this._disableZoom) {\n      const touchDistance =\n          this.twoTouchDistance(this.pointers[0], this.pointers[1]);\n      const deltaZoom = ZOOM_SENSITIVITY * this.zoomSensitivity *\n          (this.lastSeparation - touchDistance) * 50 / this.scene.height;\n      this.lastSeparation = touchDistance;\n\n      this.userAdjustOrbit(0, 0, deltaZoom);\n    }\n\n    if (this.panPerPixel > 0) {\n      this.movePan(dx, dy);\n    }\n  };\n\n  // We implement our own version of the browser's CSS touch-action, enforced by\n  // this function, because the iOS implementation of pan-y is bad and doesn't\n  // match Android. Specifically, even if a touch gesture begins by panning X,\n  // iOS will switch to scrolling as soon as the gesture moves in the Y, rather\n  // than staying in the same mode until the end of the gesture.\n  private disableScroll = (event: TouchEvent) => {\n    event.preventDefault();\n  };\n\n  private touchModeRotate: TouchMode = (dx: number, dy: number) => {\n    const {touchAction} = this._options;\n    if (!this.touchDecided && touchAction !== 'none') {\n      this.touchDecided = true;\n      const dxMag = Math.abs(dx);\n      const dyMag = Math.abs(dy);\n      // If motion is mostly vertical, assume scrolling is the intent.\n      if (this.changeSource === ChangeSource.USER_INTERACTION &&\n          ((touchAction === 'pan-y' && dyMag > dxMag) ||\n           (touchAction === 'pan-x' && dxMag > dyMag))) {\n        this.touchMode = null;\n        return;\n      } else {\n        this.element.addEventListener(\n            'touchmove', this.disableScroll, {passive: false});\n      }\n    }\n    this.handleSinglePointerMove(dx, dy);\n  };\n\n  private handleSinglePointerMove(dx: number, dy: number) {\n    const deltaTheta = this.pixelLengthToSphericalAngle(dx);\n    const deltaPhi = this.pixelLengthToSphericalAngle(dy);\n\n    if (this.isUserPointing === false) {\n      this.isUserPointing = true;\n      this.dispatchEvent({type: 'pointer-change-start'});\n    }\n\n    this.userAdjustOrbit(deltaTheta, deltaPhi, 0);\n  }\n\n  private initializePan() {\n    const {theta, phi} = this.spherical;\n    const psi = theta - this.scene.yaw;\n    this.panPerPixel =\n        PAN_SENSITIVITY * this.panSensitivity / this.scene.height;\n    this.panProjection.set(\n        -Math.cos(psi),\n        -Math.cos(phi) * Math.sin(psi),\n        0,\n        0,\n        Math.sin(phi),\n        0,\n        Math.sin(psi),\n        -Math.cos(phi) * Math.cos(psi),\n        0);\n  }\n\n  private movePan(dx: number, dy: number) {\n    const {scene} = this;\n    const dxy = vector3.set(dx, dy, 0).multiplyScalar(this.inputSensitivity);\n    const metersPerPixel =\n        this.spherical.radius * Math.exp(this.logFov) * this.panPerPixel;\n    dxy.multiplyScalar(metersPerPixel);\n\n    const target = scene.getTarget();\n    target.add(dxy.applyMatrix3(this.panProjection));\n    scene.boundingSphere.clampPoint(target, target);\n    scene.setTarget(target.x, target.y, target.z);\n  }\n\n  private recenter(pointer: PointerEvent) {\n    if (performance.now() > this.startTime + TAP_MS ||\n        Math.abs(pointer.clientX - this.startPointerPosition.clientX) >\n            TAP_DISTANCE ||\n        Math.abs(pointer.clientY - this.startPointerPosition.clientY) >\n            TAP_DISTANCE) {\n      return;\n    }\n    const {scene} = this;\n\n    const hit = scene.positionAndNormalFromPoint(\n        scene.getNDC(pointer.clientX, pointer.clientY));\n\n    if (hit == null) {\n      const {cameraTarget} = scene.element;\n      scene.element.cameraTarget = '';\n      scene.element.cameraTarget = cameraTarget;\n      // Zoom all the way out.\n      this.userAdjustOrbit(0, 0, 1);\n    } else {\n      scene.target.worldToLocal(hit.position);\n      scene.setTarget(hit.position.x, hit.position.y, hit.position.z);\n    }\n  }\n\n  private resetRadius() {\n    const {scene} = this;\n\n    const hit = scene.positionAndNormalFromPoint(vector2.set(0, 0));\n    if (hit == null) {\n      return;\n    }\n\n    scene.target.worldToLocal(hit.position);\n    const goalTarget = scene.getTarget();\n    const {theta, phi} = this.spherical;\n\n    // Set target to surface hit point, except the target is still settling,\n    // so offset the goal accordingly so the transition is smooth even though\n    // this will drift the target slightly away from the hit point.\n    const psi = theta - scene.yaw;\n    const n = vector3.set(\n        Math.sin(phi) * Math.sin(psi),\n        Math.cos(phi),\n        Math.sin(phi) * Math.cos(psi));\n    const dr = n.dot(hit.position.sub(goalTarget));\n    goalTarget.add(n.multiplyScalar(dr));\n\n    scene.setTarget(goalTarget.x, goalTarget.y, goalTarget.z);\n    // Change the camera radius to match the change in target so that the\n    // camera itself does not move, unless it hits a radius bound.\n    this.setOrbit(undefined, undefined, this.goalSpherical.radius - dr);\n  }\n\n  private onPointerDown = (event: PointerEvent) => {\n    if (this.pointers.length > 2) {\n      return;\n    }\n    const {element} = this;\n\n    if (this.pointers.length === 0) {\n      element.addEventListener('pointermove', this.onPointerMove);\n      element.addEventListener('pointerup', this.onPointerUp);\n      this.touchMode = null;\n      this.touchDecided = false;\n      this.startPointerPosition.clientX = event.clientX;\n      this.startPointerPosition.clientY = event.clientY;\n      this.startTime = performance.now();\n    }\n\n    try {\n      element.setPointerCapture(event.pointerId);\n    } catch {\n    }\n    this.pointers.push(\n        {clientX: event.clientX, clientY: event.clientY, id: event.pointerId});\n\n    this.isUserPointing = false;\n\n    if (event.pointerType === 'touch') {\n      this.changeSource = event.altKey ?  // set by interact() in controls.ts\n          ChangeSource.AUTOMATIC :\n          ChangeSource.USER_INTERACTION;\n      this.onTouchChange(event);\n    } else {\n      this.changeSource = ChangeSource.USER_INTERACTION;\n      this.onMouseDown(event);\n    }\n\n    if (this.changeSource === ChangeSource.USER_INTERACTION) {\n      this.dispatchEvent({type: 'user-interaction'});\n    }\n  };\n\n  private onPointerMove = (event: PointerEvent) => {\n    const pointer =\n        this.pointers.find((pointer) => pointer.id === event.pointerId);\n    if (pointer == null) {\n      return;\n    }\n\n    // In case no one gave us a pointerup or pointercancel event.\n    if (event.pointerType === 'mouse' && event.buttons === 0) {\n      this.onPointerUp(event);\n      return;\n    }\n\n    const numTouches = this.pointers.length;\n    const dx = (event.clientX - pointer.clientX) / numTouches;\n    const dy = (event.clientY - pointer.clientY) / numTouches;\n    if (dx === 0 && dy === 0) {\n      return;\n    }\n    pointer.clientX = event.clientX;\n    pointer.clientY = event.clientY;\n\n    if (event.pointerType === 'touch') {\n      this.changeSource = event.altKey ?  // set by interact() in controls.ts\n          ChangeSource.AUTOMATIC :\n          ChangeSource.USER_INTERACTION;\n      if (this.touchMode !== null) {\n        this.touchMode(dx, dy);\n      }\n    } else {\n      this.changeSource = ChangeSource.USER_INTERACTION;\n      if (this.panPerPixel > 0) {\n        this.movePan(dx, dy);\n      } else {\n        this.handleSinglePointerMove(dx, dy);\n      }\n    }\n  };\n\n  private onPointerUp = (event: PointerEvent) => {\n    const {element} = this;\n\n    const index =\n        this.pointers.findIndex((pointer) => pointer.id === event.pointerId);\n    if (index !== -1) {\n      this.pointers.splice(index, 1);\n    }\n\n    // altKey indicates an interaction prompt; don't reset radius in this case\n    // as it will cause the camera to drift.\n    if (this.panPerPixel > 0 && !event.altKey) {\n      this.resetRadius();\n    }\n    if (this.pointers.length === 0) {\n      element.removeEventListener('pointermove', this.onPointerMove);\n      element.removeEventListener('pointerup', this.onPointerUp);\n      element.removeEventListener('touchmove', this.disableScroll);\n      if (this.enablePan && this.enableTap) {\n        this.recenter(event);\n      }\n    } else if (this.touchMode !== null) {\n      this.onTouchChange(event);\n    }\n\n    (this.scene.element as any)[$panElement].style.opacity = 0;\n    element.style.cursor = 'grab';\n    this.panPerPixel = 0;\n\n    if (this.isUserPointing) {\n      this.dispatchEvent({type: 'pointer-change-end'});\n    }\n  };\n\n  private onTouchChange(event: PointerEvent) {\n    if (this.pointers.length === 1) {\n      this.touchMode = this.touchModeRotate;\n    } else {\n      if (this._disableZoom) {\n        this.touchMode = null;\n        this.element.removeEventListener('touchmove', this.disableScroll);\n        return;\n      }\n      this.touchMode = (this.touchDecided && this.touchMode === null) ?\n          null :\n          this.touchModeZoom;\n      this.touchDecided = true;\n      this.element.addEventListener(\n          'touchmove', this.disableScroll, {passive: false});\n      this.lastSeparation =\n          this.twoTouchDistance(this.pointers[0], this.pointers[1]);\n\n      if (this.enablePan && this.touchMode != null) {\n        this.initializePan();\n        if (!event.altKey) {  // user interaction, not prompt\n          (this.scene.element as any)[$panElement].style.opacity = 1;\n        }\n      }\n    }\n  }\n\n  private onMouseDown(event: MouseEvent) {\n    this.panPerPixel = 0;\n    if (this.enablePan &&\n        (event.button === 2 || event.ctrlKey || event.metaKey ||\n         event.shiftKey)) {\n      this.initializePan();\n      (this.scene.element as any)[$panElement].style.opacity = 1;\n    }\n    this.element.style.cursor = 'grabbing';\n  }\n\n  private onWheel = (event: Event) => {\n    this.changeSource = ChangeSource.USER_INTERACTION;\n\n    const deltaZoom = (event as WheelEvent).deltaY *\n        ((event as WheelEvent).deltaMode == 1 ? 18 : 1) * ZOOM_SENSITIVITY *\n        this.zoomSensitivity / 30;\n    this.userAdjustOrbit(0, 0, deltaZoom);\n\n    event.preventDefault();\n    this.dispatchEvent({type: 'user-interaction'});\n  };\n\n  private onKeyDown = (event: KeyboardEvent) => {\n    // We track if the key is actually one we respond to, so as not to\n    // accidentally clobber unrelated key inputs when the <model-viewer> has\n    // focus.\n    const {changeSource} = this;\n    this.changeSource = ChangeSource.USER_INTERACTION;\n\n    const relevantKey = (event.shiftKey && this.enablePan) ?\n        this.panKeyCodeHandler(event) :\n        this.orbitZoomKeyCodeHandler(event);\n\n    if (relevantKey) {\n      event.preventDefault();\n      this.dispatchEvent({type: 'user-interaction'});\n    } else {\n      this.changeSource = changeSource;\n    }\n  };\n\n  /**\n   * Handles the orbit and Zoom key presses\n   * Uses constants for the increment.\n   * @param event The keyboard event for the .key value\n   * @returns boolean to indicate if the key event has been handled\n   */\n  private orbitZoomKeyCodeHandler(event: KeyboardEvent) {\n    let relevantKey = true;\n    switch (event.key) {\n      case 'PageUp':\n        this.userAdjustOrbit(0, 0, ZOOM_SENSITIVITY * this.zoomSensitivity);\n        break;\n      case 'PageDown':\n        this.userAdjustOrbit(\n            0, 0, -1 * ZOOM_SENSITIVITY * this.zoomSensitivity);\n        break;\n      case 'ArrowUp':\n        this.userAdjustOrbit(0, -KEYBOARD_ORBIT_INCREMENT, 0);\n        break;\n      case 'ArrowDown':\n        this.userAdjustOrbit(0, KEYBOARD_ORBIT_INCREMENT, 0);\n        break;\n      case 'ArrowLeft':\n        this.userAdjustOrbit(-KEYBOARD_ORBIT_INCREMENT, 0, 0);\n        break;\n      case 'ArrowRight':\n        this.userAdjustOrbit(KEYBOARD_ORBIT_INCREMENT, 0, 0);\n        break;\n      default:\n        relevantKey = false;\n        break;\n    }\n    return relevantKey;\n  }\n\n  /**\n   * Handles the Pan key presses\n   * Uses constants for the increment.\n   * @param event The keyboard event for the .key value\n   * @returns boolean to indicate if the key event has been handled\n   */\n  private panKeyCodeHandler(event: KeyboardEvent) {\n    this.initializePan();\n    let relevantKey = true;\n    switch (event.key) {\n      case 'ArrowUp':\n        this.movePan(\n            0,\n            -1 * PAN_KEY_INCREMENT);  // This is the negative one so that the\n                                      // model appears to move as the arrow\n                                      // direction rather than the view moving\n        break;\n      case 'ArrowDown':\n        this.movePan(0, PAN_KEY_INCREMENT);\n        break;\n      case 'ArrowLeft':\n        this.movePan(-1 * PAN_KEY_INCREMENT, 0);\n        break;\n      case 'ArrowRight':\n        this.movePan(PAN_KEY_INCREMENT, 0);\n        break;\n      default:\n        relevantKey = false;\n        break;\n    }\n    return relevantKey;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}