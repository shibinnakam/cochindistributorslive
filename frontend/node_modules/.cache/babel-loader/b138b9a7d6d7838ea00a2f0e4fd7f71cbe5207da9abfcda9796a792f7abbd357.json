{"ast":null,"code":"import _defineProperty from \"C:/Users/LENOVO/Music/OneDrive/Pictures/distribution-agency-project/frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.to-array.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/**\n * @monogrid/gainmap-js v3.4.0\n * With ❤️, by MONOGRID <gainmap@monogrid.com>\n */\n\nimport { Q as QuadRenderer } from './QuadRenderer-Bj1xl_EK.js';\nimport { c as createDecodeFunction, L as LoaderBaseShared, e as extractGainmapFromJPEG, X as XMPMetadataNotFoundError, G as GainMapNotFoundError } from './Loader-DLI-_JDP.js';\nexport { M as MPFExtractor, a as extractXMP } from './Loader-DLI-_JDP.js';\nimport { ShaderMaterial, NoBlending, Vector3, WebGLRenderer, FileLoader } from 'three';\nconst vertexShader = /* glsl */`\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */`\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */\nclass GainMapDecoderMaterial extends ShaderMaterial {\n  /**\n   *\n   * @param params\n   */\n  constructor({\n    gamma,\n    offsetHdr,\n    offsetSdr,\n    gainMapMin,\n    gainMapMax,\n    maxDisplayBoost,\n    hdrCapacityMin,\n    hdrCapacityMax,\n    sdr,\n    gainMap\n  }) {\n    super({\n      name: 'GainMapDecoderMaterial',\n      vertexShader,\n      fragmentShader,\n      uniforms: {\n        sdr: {\n          value: sdr\n        },\n        gainMap: {\n          value: gainMap\n        },\n        gamma: {\n          value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2])\n        },\n        offsetHdr: {\n          value: new Vector3().fromArray(offsetHdr)\n        },\n        offsetSdr: {\n          value: new Vector3().fromArray(offsetSdr)\n        },\n        gainMapMin: {\n          value: new Vector3().fromArray(gainMapMin)\n        },\n        gainMapMax: {\n          value: new Vector3().fromArray(gainMapMax)\n        },\n        weightFactor: {\n          value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n        }\n      },\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false\n    });\n    _defineProperty(this, \"_maxDisplayBoost\", void 0);\n    _defineProperty(this, \"_hdrCapacityMin\", void 0);\n    _defineProperty(this, \"_hdrCapacityMax\", void 0);\n    this._maxDisplayBoost = maxDisplayBoost;\n    this._hdrCapacityMin = hdrCapacityMin;\n    this._hdrCapacityMax = hdrCapacityMax;\n    this.needsUpdate = true;\n    this.uniformsNeedUpdate = true;\n  }\n  get sdr() {\n    return this.uniforms.sdr.value;\n  }\n  set sdr(value) {\n    this.uniforms.sdr.value = value;\n  }\n  get gainMap() {\n    return this.uniforms.gainMap.value;\n  }\n  set gainMap(value) {\n    this.uniforms.gainMap.value = value;\n  }\n  /**\n   * @see {@link GainMapMetadata.offsetHdr}\n   */\n  get offsetHdr() {\n    return this.uniforms.offsetHdr.value.toArray();\n  }\n  set offsetHdr(value) {\n    this.uniforms.offsetHdr.value.fromArray(value);\n  }\n  /**\n   * @see {@link GainMapMetadata.offsetSdr}\n   */\n  get offsetSdr() {\n    return this.uniforms.offsetSdr.value.toArray();\n  }\n  set offsetSdr(value) {\n    this.uniforms.offsetSdr.value.fromArray(value);\n  }\n  /**\n   * @see {@link GainMapMetadata.gainMapMin}\n   */\n  get gainMapMin() {\n    return this.uniforms.gainMapMin.value.toArray();\n  }\n  set gainMapMin(value) {\n    this.uniforms.gainMapMin.value.fromArray(value);\n  }\n  /**\n   * @see {@link GainMapMetadata.gainMapMax}\n   */\n  get gainMapMax() {\n    return this.uniforms.gainMapMax.value.toArray();\n  }\n  set gainMapMax(value) {\n    this.uniforms.gainMapMax.value.fromArray(value);\n  }\n  /**\n   * @see {@link GainMapMetadata.gamma}\n   */\n  get gamma() {\n    const g = this.uniforms.gamma.value;\n    return [1 / g.x, 1 / g.y, 1 / g.z];\n  }\n  set gamma(value) {\n    const g = this.uniforms.gamma.value;\n    g.x = 1.0 / value[0];\n    g.y = 1.0 / value[1];\n    g.z = 1.0 / value[2];\n  }\n  /**\n   * @see {@link GainMapMetadata.hdrCapacityMin}\n   * @remarks Logarithmic space\n   */\n  get hdrCapacityMin() {\n    return this._hdrCapacityMin;\n  }\n  set hdrCapacityMin(value) {\n    this._hdrCapacityMin = value;\n    this.calculateWeight();\n  }\n  /**\n   * @see {@link GainMapMetadata.hdrCapacityMin}\n   * @remarks Logarithmic space\n   */\n  get hdrCapacityMax() {\n    return this._hdrCapacityMax;\n  }\n  set hdrCapacityMax(value) {\n    this._hdrCapacityMax = value;\n    this.calculateWeight();\n  }\n  /**\n   * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n   * @remarks Non Logarithmic space\n   */\n  get maxDisplayBoost() {\n    return this._maxDisplayBoost;\n  }\n  set maxDisplayBoost(value) {\n    this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n    this.calculateWeight();\n  }\n  calculateWeight() {\n    const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n    this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n  }\n}\nconst decodeImpl = createDecodeFunction({\n  renderer: WebGLRenderer,\n  createMaterial: params => new GainMapDecoderMaterial(params),\n  createQuadRenderer: params => new QuadRenderer(params)\n});\n/**\n * Decodes a gain map using a WebGL RenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */\nconst decode = params => {\n  // Ensure renderer is defined for the base function\n  if (!params.renderer) {\n    throw new Error('Renderer is required for decode function');\n  }\n  const quadRenderer = decodeImpl({\n    ...params,\n    renderer: params.renderer\n  });\n  try {\n    quadRenderer.render();\n  } catch (e) {\n    quadRenderer.disposeOnDemandRenderer();\n    throw e;\n  }\n  return quadRenderer;\n};\n\n/**\n * Base class for WebGL loaders\n * @template TUrl - The type of URL used to load resources\n */\nclass LoaderBaseWebGL extends LoaderBaseShared {\n  constructor(renderer, manager) {\n    super({\n      renderer,\n      createMaterial: params => new GainMapDecoderMaterial(params),\n      createQuadRenderer: params => new QuadRenderer(params)\n    }, manager);\n  }\n  /**\n   * @private\n   * @param quadRenderer\n   * @param metadata\n   * @param sdrBuffer\n   * @param gainMapBuffer\n   */\n  async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n    const {\n      sdrImage,\n      gainMapImage,\n      needsFlip\n    } = await this.processImages(sdrBuffer, gainMapBuffer, 'flipY');\n    const {\n      gainMap,\n      sdr\n    } = this.createTextures(sdrImage, gainMapImage, needsFlip);\n    this.updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata);\n    quadRenderer.render();\n  }\n}\n\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass GainMapLoader extends LoaderBaseWebGL {\n  /**\n   * Loads a gainmap using separate data\n   * * sdr image\n   * * gain map image\n   * * metadata json\n   *\n   * useful for webp gain maps\n   *\n   * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n   * @param onLoad Load complete callback, will receive the result\n   * @param onProgress Progress callback, will receive a `ProgressEvent`\n   * @param onError Error callback\n   * @returns\n   */\n  load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n    const quadRenderer = this.prepareQuadRenderer();\n    let sdr;\n    let gainMap;\n    let metadata;\n    const loadCheck = async () => {\n      if (sdr && gainMap && metadata) {\n        // solves #16\n        try {\n          await this.render(quadRenderer, metadata, sdr, gainMap);\n        } catch (error) {\n          this.manager.itemError(sdrUrl);\n          this.manager.itemError(gainMapUrl);\n          this.manager.itemError(metadataUrl);\n          if (typeof onError === 'function') onError(error);\n          quadRenderer.disposeOnDemandRenderer();\n          return;\n        }\n        if (typeof onLoad === 'function') onLoad(quadRenderer);\n        this.manager.itemEnd(sdrUrl);\n        this.manager.itemEnd(gainMapUrl);\n        this.manager.itemEnd(metadataUrl);\n        quadRenderer.disposeOnDemandRenderer();\n      }\n    };\n    let sdrLengthComputable = true;\n    let sdrTotal = 0;\n    let sdrLoaded = 0;\n    let gainMapLengthComputable = true;\n    let gainMapTotal = 0;\n    let gainMapLoaded = 0;\n    let metadataLengthComputable = true;\n    let metadataTotal = 0;\n    let metadataLoaded = 0;\n    const progressHandler = () => {\n      if (typeof onProgress === 'function') {\n        const total = sdrTotal + gainMapTotal + metadataTotal;\n        const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n        const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n        onProgress(new ProgressEvent('progress', {\n          lengthComputable,\n          loaded,\n          total\n        }));\n      }\n    };\n    this.manager.itemStart(sdrUrl);\n    this.manager.itemStart(gainMapUrl);\n    this.manager.itemStart(metadataUrl);\n    const sdrLoader = new FileLoader(this._internalLoadingManager);\n    sdrLoader.setResponseType('arraybuffer');\n    sdrLoader.setRequestHeader(this.requestHeader);\n    sdrLoader.setPath(this.path);\n    sdrLoader.setWithCredentials(this.withCredentials);\n    sdrLoader.load(sdrUrl, async buffer => {\n      /* istanbul ignore if\n       this condition exists only because of three.js types + strict mode\n      */\n      if (typeof buffer === 'string') throw new Error('Invalid sdr buffer');\n      sdr = buffer;\n      await loadCheck();\n    }, e => {\n      sdrLengthComputable = e.lengthComputable;\n      sdrLoaded = e.loaded;\n      sdrTotal = e.total;\n      progressHandler();\n    }, error => {\n      this.manager.itemError(sdrUrl);\n      if (typeof onError === 'function') onError(error);\n    });\n    const gainMapLoader = new FileLoader(this._internalLoadingManager);\n    gainMapLoader.setResponseType('arraybuffer');\n    gainMapLoader.setRequestHeader(this.requestHeader);\n    gainMapLoader.setPath(this.path);\n    gainMapLoader.setWithCredentials(this.withCredentials);\n    gainMapLoader.load(gainMapUrl, async buffer => {\n      /* istanbul ignore if\n       this condition exists only because of three.js types + strict mode\n      */\n      if (typeof buffer === 'string') throw new Error('Invalid gainmap buffer');\n      gainMap = buffer;\n      await loadCheck();\n    }, e => {\n      gainMapLengthComputable = e.lengthComputable;\n      gainMapLoaded = e.loaded;\n      gainMapTotal = e.total;\n      progressHandler();\n    }, error => {\n      this.manager.itemError(gainMapUrl);\n      if (typeof onError === 'function') onError(error);\n    });\n    const metadataLoader = new FileLoader(this._internalLoadingManager);\n    // metadataLoader.setResponseType('json')\n    metadataLoader.setRequestHeader(this.requestHeader);\n    metadataLoader.setPath(this.path);\n    metadataLoader.setWithCredentials(this.withCredentials);\n    metadataLoader.load(metadataUrl, async json => {\n      /* istanbul ignore if\n       this condition exists only because of three.js types + strict mode\n      */\n      if (typeof json !== 'string') throw new Error('Invalid metadata string');\n      // TODO: implement check on JSON file and remove this eslint disable\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n      metadata = JSON.parse(json);\n      await loadCheck();\n    }, e => {\n      metadataLengthComputable = e.lengthComputable;\n      metadataLoaded = e.loaded;\n      metadataTotal = e.total;\n      progressHandler();\n    }, error => {\n      this.manager.itemError(metadataUrl);\n      if (typeof onError === 'function') onError(error);\n    });\n    return quadRenderer;\n  }\n}\n\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass HDRJPGLoader extends LoaderBaseWebGL {\n  /**\n   * Loads a JPEG containing gain map metadata\n   * Renders a normal SDR image if gainmap data is not found\n   *\n   * @param url Path to a JPEG file containing embedded gain map metadata\n   * @param onLoad Load complete callback, will receive the result\n   * @param onProgress Progress callback, will receive a `ProgressEvent`\n   * @param onError Error callback\n   * @returns\n   */\n  load(url, onLoad, onProgress, onError) {\n    const quadRenderer = this.prepareQuadRenderer();\n    const loader = new FileLoader(this._internalLoadingManager);\n    loader.setResponseType('arraybuffer');\n    loader.setRequestHeader(this.requestHeader);\n    loader.setPath(this.path);\n    loader.setWithCredentials(this.withCredentials);\n    this.manager.itemStart(url);\n    loader.load(url, async jpeg => {\n      /* istanbul ignore if\n       this condition exists only because of three.js types + strict mode\n      */\n      if (typeof jpeg === 'string') throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n      const jpegBuffer = new Uint8Array(jpeg);\n      let sdrJPEG;\n      let gainMapJPEG;\n      let metadata;\n      try {\n        const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n        // gain map is successfully reconstructed\n        sdrJPEG = extractionResult.sdr;\n        gainMapJPEG = extractionResult.gainMap;\n        metadata = extractionResult.metadata;\n      } catch (e) {\n        // render the SDR version if this is not a gainmap\n        if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n          console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n          metadata = {\n            gainMapMin: [0, 0, 0],\n            gainMapMax: [1, 1, 1],\n            gamma: [1, 1, 1],\n            hdrCapacityMin: 0,\n            hdrCapacityMax: 1,\n            offsetHdr: [0, 0, 0],\n            offsetSdr: [0, 0, 0]\n          };\n          sdrJPEG = jpegBuffer;\n        } else {\n          throw e;\n        }\n      }\n      // solves #16\n      try {\n        await this.render(quadRenderer, metadata, sdrJPEG.buffer, gainMapJPEG?.buffer);\n      } catch (error) {\n        this.manager.itemError(url);\n        if (typeof onError === 'function') onError(error);\n        quadRenderer.disposeOnDemandRenderer();\n        return;\n      }\n      if (typeof onLoad === 'function') onLoad(quadRenderer);\n      this.manager.itemEnd(url);\n      quadRenderer.disposeOnDemandRenderer();\n    }, onProgress, error => {\n      this.manager.itemError(url);\n      if (typeof onError === 'function') onError(error);\n    });\n    return quadRenderer;\n  }\n}\nexport { GainMapDecoderMaterial, GainMapLoader, GainMapNotFoundError, HDRJPGLoader, HDRJPGLoader as JPEGRLoader, LoaderBaseShared, QuadRenderer, XMPMetadataNotFoundError, createDecodeFunction, decode, extractGainmapFromJPEG };","map":{"version":3,"names":["Q","QuadRenderer","c","createDecodeFunction","L","LoaderBaseShared","e","extractGainmapFromJPEG","X","XMPMetadataNotFoundError","G","GainMapNotFoundError","M","MPFExtractor","a","extractXMP","ShaderMaterial","NoBlending","Vector3","WebGLRenderer","FileLoader","vertexShader","fragmentShader","GainMapDecoderMaterial","constructor","gamma","offsetHdr","offsetSdr","gainMapMin","gainMapMax","maxDisplayBoost","hdrCapacityMin","hdrCapacityMax","sdr","gainMap","name","uniforms","value","fromArray","weightFactor","Math","log2","blending","depthTest","depthWrite","_defineProperty","_maxDisplayBoost","_hdrCapacityMin","_hdrCapacityMax","needsUpdate","uniformsNeedUpdate","toArray","g","x","y","z","calculateWeight","max","min","val","decodeImpl","renderer","createMaterial","params","createQuadRenderer","decode","Error","quadRenderer","render","disposeOnDemandRenderer","LoaderBaseWebGL","manager","metadata","sdrBuffer","gainMapBuffer","sdrImage","gainMapImage","needsFlip","processImages","createTextures","updateQuadRenderer","GainMapLoader","load","sdrUrl","gainMapUrl","metadataUrl","onLoad","onProgress","onError","prepareQuadRenderer","loadCheck","error","itemError","itemEnd","sdrLengthComputable","sdrTotal","sdrLoaded","gainMapLengthComputable","gainMapTotal","gainMapLoaded","metadataLengthComputable","metadataTotal","metadataLoaded","progressHandler","total","loaded","lengthComputable","ProgressEvent","itemStart","sdrLoader","_internalLoadingManager","setResponseType","setRequestHeader","requestHeader","setPath","path","setWithCredentials","withCredentials","buffer","gainMapLoader","metadataLoader","json","JSON","parse","HDRJPGLoader","url","loader","jpeg","jpegBuffer","Uint8Array","sdrJPEG","gainMapJPEG","extractionResult","console","warn","JPEGRLoader"],"sources":["C:/Users/LENOVO/Music/OneDrive/Pictures/distribution-agency-project/frontend/node_modules/@monogrid/gainmap-js/dist/decode.js"],"sourcesContent":["/**\n * @monogrid/gainmap-js v3.4.0\n * With ❤️, by MONOGRID <gainmap@monogrid.com>\n */\n\nimport { Q as QuadRenderer } from './QuadRenderer-Bj1xl_EK.js';\nimport { c as createDecodeFunction, L as LoaderBaseShared, e as extractGainmapFromJPEG, X as XMPMetadataNotFoundError, G as GainMapNotFoundError } from './Loader-DLI-_JDP.js';\nexport { M as MPFExtractor, a as extractXMP } from './Loader-DLI-_JDP.js';\nimport { ShaderMaterial, NoBlending, Vector3, WebGLRenderer, FileLoader } from 'three';\n\nconst vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */\nclass GainMapDecoderMaterial extends ShaderMaterial {\n    _maxDisplayBoost;\n    _hdrCapacityMin;\n    _hdrCapacityMax;\n    /**\n     *\n     * @param params\n     */\n    constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }) {\n        super({\n            name: 'GainMapDecoderMaterial',\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                sdr: { value: sdr },\n                gainMap: { value: gainMap },\n                gamma: { value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2]) },\n                offsetHdr: { value: new Vector3().fromArray(offsetHdr) },\n                offsetSdr: { value: new Vector3().fromArray(offsetSdr) },\n                gainMapMin: { value: new Vector3().fromArray(gainMapMin) },\n                gainMapMax: { value: new Vector3().fromArray(gainMapMax) },\n                weightFactor: {\n                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                }\n            },\n            blending: NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._maxDisplayBoost = maxDisplayBoost;\n        this._hdrCapacityMin = hdrCapacityMin;\n        this._hdrCapacityMax = hdrCapacityMax;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get sdr() { return this.uniforms.sdr.value; }\n    set sdr(value) { this.uniforms.sdr.value = value; }\n    get gainMap() { return this.uniforms.gainMap.value; }\n    set gainMap(value) { this.uniforms.gainMap.value = value; }\n    /**\n     * @see {@link GainMapMetadata.offsetHdr}\n     */\n    get offsetHdr() { return this.uniforms.offsetHdr.value.toArray(); }\n    set offsetHdr(value) { this.uniforms.offsetHdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.offsetSdr}\n     */\n    get offsetSdr() { return this.uniforms.offsetSdr.value.toArray(); }\n    set offsetSdr(value) { this.uniforms.offsetSdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     */\n    get gainMapMin() { return this.uniforms.gainMapMin.value.toArray(); }\n    set gainMapMin(value) { this.uniforms.gainMapMin.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     */\n    get gainMapMax() { return this.uniforms.gainMapMax.value.toArray(); }\n    set gainMapMax(value) { this.uniforms.gainMapMax.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gamma}\n     */\n    get gamma() {\n        const g = this.uniforms.gamma.value;\n        return [1 / g.x, 1 / g.y, 1 / g.z];\n    }\n    set gamma(value) {\n        const g = this.uniforms.gamma.value;\n        g.x = 1.0 / value[0];\n        g.y = 1.0 / value[1];\n        g.z = 1.0 / value[2];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMin() { return this._hdrCapacityMin; }\n    set hdrCapacityMin(value) {\n        this._hdrCapacityMin = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMax() { return this._hdrCapacityMax; }\n    set hdrCapacityMax(value) {\n        this._hdrCapacityMax = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n     * @remarks Non Logarithmic space\n     */\n    get maxDisplayBoost() { return this._maxDisplayBoost; }\n    set maxDisplayBoost(value) {\n        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n        this.calculateWeight();\n    }\n    calculateWeight() {\n        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n    }\n}\n\nconst decodeImpl = createDecodeFunction({\n    renderer: WebGLRenderer,\n    createMaterial: (params) => new GainMapDecoderMaterial(params),\n    createQuadRenderer: (params) => new QuadRenderer(params)\n});\n/**\n * Decodes a gain map using a WebGL RenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */\nconst decode = (params) => {\n    // Ensure renderer is defined for the base function\n    if (!params.renderer) {\n        throw new Error('Renderer is required for decode function');\n    }\n    const quadRenderer = decodeImpl({\n        ...params,\n        renderer: params.renderer\n    });\n    try {\n        quadRenderer.render();\n    }\n    catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\n\n/**\n * Base class for WebGL loaders\n * @template TUrl - The type of URL used to load resources\n */\nclass LoaderBaseWebGL extends LoaderBaseShared {\n    constructor(renderer, manager) {\n        super({\n            renderer,\n            createMaterial: (params) => new GainMapDecoderMaterial(params),\n            createQuadRenderer: (params) => new QuadRenderer(params)\n        }, manager);\n    }\n    /**\n     * @private\n     * @param quadRenderer\n     * @param metadata\n     * @param sdrBuffer\n     * @param gainMapBuffer\n     */\n    async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n        const { sdrImage, gainMapImage, needsFlip } = await this.processImages(sdrBuffer, gainMapBuffer, 'flipY');\n        const { gainMap, sdr } = this.createTextures(sdrImage, gainMapImage, needsFlip);\n        this.updateQuadRenderer(quadRenderer, sdrImage, gainMap, sdr, metadata);\n        quadRenderer.render();\n    }\n}\n\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass GainMapLoader extends LoaderBaseWebGL {\n    /**\n     * Loads a gainmap using separate data\n     * * sdr image\n     * * gain map image\n     * * metadata json\n     *\n     * useful for webp gain maps\n     *\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a `ProgressEvent`\n     * @param onError Error callback\n     * @returns\n     */\n    load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        let sdr;\n        let gainMap;\n        let metadata;\n        const loadCheck = async () => {\n            if (sdr && gainMap && metadata) {\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdr, gainMap);\n                }\n                catch (error) {\n                    this.manager.itemError(sdrUrl);\n                    this.manager.itemError(gainMapUrl);\n                    this.manager.itemError(metadataUrl);\n                    if (typeof onError === 'function')\n                        onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === 'function')\n                    onLoad(quadRenderer);\n                this.manager.itemEnd(sdrUrl);\n                this.manager.itemEnd(gainMapUrl);\n                this.manager.itemEnd(metadataUrl);\n                quadRenderer.disposeOnDemandRenderer();\n            }\n        };\n        let sdrLengthComputable = true;\n        let sdrTotal = 0;\n        let sdrLoaded = 0;\n        let gainMapLengthComputable = true;\n        let gainMapTotal = 0;\n        let gainMapLoaded = 0;\n        let metadataLengthComputable = true;\n        let metadataTotal = 0;\n        let metadataLoaded = 0;\n        const progressHandler = () => {\n            if (typeof onProgress === 'function') {\n                const total = sdrTotal + gainMapTotal + metadataTotal;\n                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                onProgress(new ProgressEvent('progress', { lengthComputable, loaded, total }));\n            }\n        };\n        this.manager.itemStart(sdrUrl);\n        this.manager.itemStart(gainMapUrl);\n        this.manager.itemStart(metadataUrl);\n        const sdrLoader = new FileLoader(this._internalLoadingManager);\n        sdrLoader.setResponseType('arraybuffer');\n        sdrLoader.setRequestHeader(this.requestHeader);\n        sdrLoader.setPath(this.path);\n        sdrLoader.setWithCredentials(this.withCredentials);\n        sdrLoader.load(sdrUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid sdr buffer');\n            sdr = buffer;\n            await loadCheck();\n        }, (e) => {\n            sdrLengthComputable = e.lengthComputable;\n            sdrLoaded = e.loaded;\n            sdrTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(sdrUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const gainMapLoader = new FileLoader(this._internalLoadingManager);\n        gainMapLoader.setResponseType('arraybuffer');\n        gainMapLoader.setRequestHeader(this.requestHeader);\n        gainMapLoader.setPath(this.path);\n        gainMapLoader.setWithCredentials(this.withCredentials);\n        gainMapLoader.load(gainMapUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid gainmap buffer');\n            gainMap = buffer;\n            await loadCheck();\n        }, (e) => {\n            gainMapLengthComputable = e.lengthComputable;\n            gainMapLoaded = e.loaded;\n            gainMapTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(gainMapUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const metadataLoader = new FileLoader(this._internalLoadingManager);\n        // metadataLoader.setResponseType('json')\n        metadataLoader.setRequestHeader(this.requestHeader);\n        metadataLoader.setPath(this.path);\n        metadataLoader.setWithCredentials(this.withCredentials);\n        metadataLoader.load(metadataUrl, async (json) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof json !== 'string')\n                throw new Error('Invalid metadata string');\n            // TODO: implement check on JSON file and remove this eslint disable\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            metadata = JSON.parse(json);\n            await loadCheck();\n        }, (e) => {\n            metadataLengthComputable = e.lengthComputable;\n            metadataLoaded = e.loaded;\n            metadataTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(metadataUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *   .setRenderTargetOptions({ mapping: EquirectangularReflectionMapping })\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass HDRJPGLoader extends LoaderBaseWebGL {\n    /**\n     * Loads a JPEG containing gain map metadata\n     * Renders a normal SDR image if gainmap data is not found\n     *\n     * @param url Path to a JPEG file containing embedded gain map metadata\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a `ProgressEvent`\n     * @param onError Error callback\n     * @returns\n     */\n    load(url, onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        const loader = new FileLoader(this._internalLoadingManager);\n        loader.setResponseType('arraybuffer');\n        loader.setRequestHeader(this.requestHeader);\n        loader.setPath(this.path);\n        loader.setWithCredentials(this.withCredentials);\n        this.manager.itemStart(url);\n        loader.load(url, async (jpeg) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof jpeg === 'string')\n                throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n            const jpegBuffer = new Uint8Array(jpeg);\n            let sdrJPEG;\n            let gainMapJPEG;\n            let metadata;\n            try {\n                const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n                // gain map is successfully reconstructed\n                sdrJPEG = extractionResult.sdr;\n                gainMapJPEG = extractionResult.gainMap;\n                metadata = extractionResult.metadata;\n            }\n            catch (e) {\n                // render the SDR version if this is not a gainmap\n                if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                    metadata = {\n                        gainMapMin: [0, 0, 0],\n                        gainMapMax: [1, 1, 1],\n                        gamma: [1, 1, 1],\n                        hdrCapacityMin: 0,\n                        hdrCapacityMax: 1,\n                        offsetHdr: [0, 0, 0],\n                        offsetSdr: [0, 0, 0]\n                    };\n                    sdrJPEG = jpegBuffer;\n                }\n                else {\n                    throw e;\n                }\n            }\n            // solves #16\n            try {\n                await this.render(quadRenderer, metadata, sdrJPEG.buffer, gainMapJPEG?.buffer);\n            }\n            catch (error) {\n                this.manager.itemError(url);\n                if (typeof onError === 'function')\n                    onError(error);\n                quadRenderer.disposeOnDemandRenderer();\n                return;\n            }\n            if (typeof onLoad === 'function')\n                onLoad(quadRenderer);\n            this.manager.itemEnd(url);\n            quadRenderer.disposeOnDemandRenderer();\n        }, onProgress, (error) => {\n            this.manager.itemError(url);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\nexport { GainMapDecoderMaterial, GainMapLoader, GainMapNotFoundError, HDRJPGLoader, HDRJPGLoader as JPEGRLoader, LoaderBaseShared, QuadRenderer, XMPMetadataNotFoundError, createDecodeFunction, decode, extractGainmapFromJPEG };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}