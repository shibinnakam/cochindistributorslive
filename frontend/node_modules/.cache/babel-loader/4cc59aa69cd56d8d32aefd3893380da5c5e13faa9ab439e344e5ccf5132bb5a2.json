{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.every.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.to-array.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { BufferAttribute, ClampToEdgeWrapping, Color, DoubleSide, InterpolateDiscrete, InterpolateLinear, NoColorSpace, LinearFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, MathUtils, Matrix4, MirroredRepeatWrapping, NearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, PropertyBinding, RGBAFormat, RepeatWrapping, Scene, Source, SRGBColorSpace, CompressedTexture, Vector3, Quaternion, REVISION, ImageUtils } from 'three';\n\n/**\n * The KHR_mesh_quantization extension allows these extra attribute component types\n *\n * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes\n */\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n  POSITION: ['byte', 'byte normalized', 'unsigned byte', 'unsigned byte normalized', 'short', 'short normalized', 'unsigned short', 'unsigned short normalized'],\n  NORMAL: ['byte normalized', 'short normalized'],\n  TANGENT: ['byte normalized', 'short normalized'],\n  TEXCOORD: ['byte', 'byte normalized', 'unsigned byte', 'short', 'short normalized', 'unsigned short']\n};\n\n/**\n * An exporter for `glTF` 2.0.\n *\n * glTF (GL Transmission Format) is an [open format specification](https://github.com/KhronosGroup/glTF/tree/master/specification/2.0)\n * for efficient delivery and loading of 3D content. Assets may be provided either in JSON (.gltf)\n * or binary (.glb) format. External files store textures (.jpg, .png) and additional binary\n * data (.bin). A glTF asset may deliver one or more scenes, including meshes, materials,\n * textures, skins, skeletons, morph targets, animations, lights, and/or cameras.\n *\n * GLTFExporter supports the [glTF 2.0 extensions](https://github.com/KhronosGroup/glTF/tree/master/extensions/):\n *\n * - KHR_lights_punctual\n * - KHR_materials_clearcoat\n * - KHR_materials_dispersion\n * - KHR_materials_emissive_strength\n * - KHR_materials_ior\n * - KHR_materials_iridescence\n * - KHR_materials_specular\n * - KHR_materials_sheen\n * - KHR_materials_transmission\n * - KHR_materials_unlit\n * - KHR_materials_volume\n * - KHR_mesh_quantization\n * - KHR_texture_transform\n * - EXT_materials_bump\n * - EXT_mesh_gpu_instancing\n *\n * The following glTF 2.0 extension is supported by an external user plugin:\n *\n * - [KHR_materials_variants](https://github.com/takahirox/three-gltf-extensions)\n *\n * ```js\n * const exporter = new GLTFExporter();\n * const data = await exporter.parseAsync( scene, options );\n * ```\n *\n * @three_import import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';\n */\nclass GLTFExporter {\n  /**\n   * Constructs a new glTF exporter.\n   */\n  constructor() {\n    /**\n     * A reference to a texture utils module.\n     *\n     * @type {?(WebGLTextureUtils|WebGPUTextureUtils)}\n     * @default null\n     */\n    this.textureUtils = null;\n    this.pluginCallbacks = [];\n    this.register(function (writer) {\n      return new GLTFLightExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsUnlitExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsTransmissionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsVolumeExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsIorExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsSpecularExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsClearcoatExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsDispersionExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsIridescenceExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsSheenExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsAnisotropyExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsEmissiveStrengthExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMaterialsBumpExtension(writer);\n    });\n    this.register(function (writer) {\n      return new GLTFMeshGpuInstancing(writer);\n    });\n  }\n\n  /**\n   * Registers a plugin callback. This API is internally used to implement the various\n   * glTF extensions but can also used by third-party code to add additional logic\n   * to the exporter.\n   *\n   * @param {function(writer:GLTFWriter)} callback - The callback function to register.\n   * @return {GLTFExporter} A reference to this exporter.\n   */\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n\n  /**\n   * Unregisters a plugin callback.\n   *\n   * @param {Function} callback - The callback function to unregister.\n   * @return {GLTFExporter} A reference to this exporter.\n   */\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n\n  /**\n   * Sets the texture utils for this exporter. Only relevant when compressed textures have to be exported.\n   *\n   * Depending on whether you use {@link WebGLRenderer} or {@link WebGPURenderer}, you must inject the\n   * corresponding texture utils {@link WebGLTextureUtils} or {@link WebGPUTextureUtils}.\n   *\n   * @param {WebGLTextureUtils|WebGPUTextureUtils} utils - The texture utils.\n   * @return {GLTFExporter} A reference to this exporter.\n   */\n  setTextureUtils(utils) {\n    this.textureUtils = utils;\n    return this;\n  }\n\n  /**\n   * Parses the given scenes and generates the glTF output.\n   *\n   * @param {Scene|Array<Scene>} input - A scene or an array of scenes.\n   * @param {GLTFExporter~OnDone} onDone - A callback function that is executed when the export has finished.\n   * @param {GLTFExporter~OnError} onError - A callback function that is executed when an error happens.\n   * @param {GLTFExporter~Options} options - options\n   */\n  parse(input, onDone, onError, options) {\n    const writer = new GLTFWriter();\n    const plugins = [];\n    for (let i = 0, il = this.pluginCallbacks.length; i < il; i++) {\n      plugins.push(this.pluginCallbacks[i](writer));\n    }\n    writer.setPlugins(plugins);\n    writer.setTextureUtils(this.textureUtils);\n    writer.writeAsync(input, onDone, options).catch(onError);\n  }\n\n  /**\n   * Async version of {@link GLTFExporter#parse}.\n   *\n   * @param {Scene|Array<Scene>} input - A scene or an array of scenes.\n   * @param {GLTFExporter~Options} options - options.\n   * @return {Promise<ArrayBuffer|string>} A Promise that resolved with the exported glTF data.\n   */\n  parseAsync(input, options) {\n    const scope = this;\n    return new Promise(function (resolve, reject) {\n      scope.parse(input, resolve, reject, options);\n    });\n  }\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n  POINTS: 0x0000,\n  LINES: 0x0001,\n  LINE_LOOP: 0x0002,\n  LINE_STRIP: 0x0003,\n  TRIANGLES: 0x0004,\n  TRIANGLE_STRIP: 0x0005,\n  TRIANGLE_FAN: 0x0006,\n  BYTE: 0x1400,\n  UNSIGNED_BYTE: 0x1401,\n  SHORT: 0x1402,\n  UNSIGNED_SHORT: 0x1403,\n  INT: 0x1404,\n  UNSIGNED_INT: 0x1405,\n  FLOAT: 0x1406,\n  ARRAY_BUFFER: 0x8892,\n  ELEMENT_ARRAY_BUFFER: 0x8893,\n  NEAREST: 0x2600,\n  LINEAR: 0x2601,\n  NEAREST_MIPMAP_NEAREST: 0x2700,\n  LINEAR_MIPMAP_NEAREST: 0x2701,\n  NEAREST_MIPMAP_LINEAR: 0x2702,\n  LINEAR_MIPMAP_LINEAR: 0x2703,\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\nconst KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';\nconst THREE_TO_WEBGL = {};\nTHREE_TO_WEBGL[NearestFilter] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[NearestMipmapNearestFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[NearestMipmapLinearFilter] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[LinearFilter] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[LinearMipmapNearestFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[LinearMipmapLinearFilter] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ClampToEdgeWrapping] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[RepeatWrapping] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[MirroredRepeatWrapping] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\nconst PATH_PROPERTIES = {\n  scale: 'scale',\n  position: 'translation',\n  quaternion: 'rotation',\n  morphTargetInfluences: 'weights'\n};\nconst DEFAULT_SPECULAR_COLOR = new Color();\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546C67;\nconst GLB_VERSION = 2;\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n *\n * @private\n * @param {Array} array1 Array 1 to compare\n * @param {Array} array2 Array 2 to compare\n * @return {boolean}        Returns true if both arrays are equal\n */\nfunction equalArray(array1, array2) {\n  return array1.length === array2.length && array1.every(function (element, index) {\n    return element === array2[index];\n  });\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n *\n * @private\n * @param {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer(text) {\n  return new TextEncoder().encode(text).buffer;\n}\n\n/**\n * Is identity matrix\n *\n * @private\n * @param {Matrix4} matrix\n * @returns {boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix(matrix) {\n  return equalArray(matrix.elements, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n}\n\n/**\n * Get the min and max vectors from the given attribute\n *\n * @private\n * @param {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param {number} start Start index\n * @param {number} count Range to cover\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax(attribute, start, count) {\n  const output = {\n    min: new Array(attribute.itemSize).fill(Number.POSITIVE_INFINITY),\n    max: new Array(attribute.itemSize).fill(Number.NEGATIVE_INFINITY)\n  };\n  for (let i = start; i < start + count; i++) {\n    for (let a = 0; a < attribute.itemSize; a++) {\n      let value;\n      if (attribute.itemSize > 4) {\n        // no support for interleaved data for itemSize > 4\n\n        value = attribute.array[i * attribute.itemSize + a];\n      } else {\n        if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n        if (attribute.normalized === true) {\n          value = MathUtils.normalize(value, attribute.array);\n        }\n      }\n      output.min[a] = Math.min(output.min[a], value);\n      output.max[a] = Math.max(output.max[a], value);\n    }\n  }\n  return output;\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @private\n * @param {number} bufferSize The size the original buffer. Should be an integer.\n * @returns {number} new buffer size with required padding as an integer.\n *\n */\nfunction getPaddedBufferSize(bufferSize) {\n  return Math.ceil(bufferSize / 4) * 4;\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {number} [paddingByte=0] Should be an integer\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer(arrayBuffer, paddingByte = 0) {\n  const paddedLength = getPaddedBufferSize(arrayBuffer.byteLength);\n  if (paddedLength !== arrayBuffer.byteLength) {\n    const array = new Uint8Array(paddedLength);\n    array.set(new Uint8Array(arrayBuffer));\n    if (paddingByte !== 0) {\n      for (let i = arrayBuffer.byteLength; i < paddedLength; i++) {\n        array[i] = paddingByte;\n      }\n    }\n    return array.buffer;\n  }\n  return arrayBuffer;\n}\nfunction getCanvas() {\n  if (typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined') {\n    return new OffscreenCanvas(1, 1);\n  }\n  return document.createElement('canvas');\n}\nfunction getToBlobPromise(canvas, mimeType) {\n  if (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas) {\n    let quality;\n\n    // Blink's implementation of convertToBlob seems to default to a quality level of 100%\n    // Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n    if (mimeType === 'image/jpeg') {\n      quality = 0.92;\n    } else if (mimeType === 'image/webp') {\n      quality = 0.8;\n    }\n    return canvas.convertToBlob({\n      type: mimeType,\n      quality: quality\n    });\n  } else {\n    // HTMLCanvasElement code path\n\n    return new Promise(resolve => canvas.toBlob(resolve, mimeType));\n  }\n}\n\n/**\n * Writer\n *\n * @private\n */\nclass GLTFWriter {\n  constructor() {\n    this.plugins = [];\n    this.options = {};\n    this.pending = [];\n    this.buffers = [];\n    this.byteOffset = 0;\n    this.buffers = [];\n    this.nodeMap = new Map();\n    this.skins = [];\n    this.extensionsUsed = {};\n    this.extensionsRequired = {};\n    this.uids = new Map();\n    this.uid = 0;\n    this.json = {\n      asset: {\n        version: '2.0',\n        generator: 'THREE.GLTFExporter r' + REVISION\n      }\n    };\n    this.cache = {\n      meshes: new Map(),\n      attributes: new Map(),\n      attributesNormalized: new Map(),\n      materials: new Map(),\n      textures: new Map(),\n      images: new Map()\n    };\n    this.textureUtils = null;\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  setTextureUtils(utils) {\n    this.textureUtils = utils;\n  }\n\n  /**\n   * Parse scenes and generate GLTF output\n   *\n   * @param {Scene|Array<Scene>} input Scene or Array of THREE.Scenes\n   * @param {Function} onDone Callback on completed\n   * @param {Object} options options\n   */\n  async writeAsync(input, onDone, options = {}) {\n    this.options = Object.assign({\n      // default options\n      binary: false,\n      trs: false,\n      onlyVisible: true,\n      maxTextureSize: Infinity,\n      animations: [],\n      includeCustomExtensions: false\n    }, options);\n    if (this.options.animations.length > 0) {\n      // Only TRS properties, and not matrices, may be targeted by animation.\n      this.options.trs = true;\n    }\n    await this.processInputAsync(input);\n    await Promise.all(this.pending);\n    const writer = this;\n    const buffers = writer.buffers;\n    const json = writer.json;\n    options = writer.options;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionsRequired = writer.extensionsRequired;\n\n    // Merge buffers.\n    const blob = new Blob(buffers, {\n      type: 'application/octet-stream'\n    });\n\n    // Declare extensions.\n    const extensionsUsedList = Object.keys(extensionsUsed);\n    const extensionsRequiredList = Object.keys(extensionsRequired);\n    if (extensionsUsedList.length > 0) json.extensionsUsed = extensionsUsedList;\n    if (extensionsRequiredList.length > 0) json.extensionsRequired = extensionsRequiredList;\n\n    // Update bytelength of the single buffer.\n    if (json.buffers && json.buffers.length > 0) json.buffers[0].byteLength = blob.size;\n    if (options.binary === true) {\n      // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob);\n      reader.onloadend = function () {\n        // Binary chunk.\n        const binaryChunk = getPaddedArrayBuffer(reader.result);\n        const binaryChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        binaryChunkPrefix.setUint32(0, binaryChunk.byteLength, true);\n        binaryChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_BIN, true);\n\n        // JSON chunk.\n        const jsonChunk = getPaddedArrayBuffer(stringToArrayBuffer(JSON.stringify(json)), 0x20);\n        const jsonChunkPrefix = new DataView(new ArrayBuffer(GLB_CHUNK_PREFIX_BYTES));\n        jsonChunkPrefix.setUint32(0, jsonChunk.byteLength, true);\n        jsonChunkPrefix.setUint32(4, GLB_CHUNK_TYPE_JSON, true);\n\n        // GLB header.\n        const header = new ArrayBuffer(GLB_HEADER_BYTES);\n        const headerView = new DataView(header);\n        headerView.setUint32(0, GLB_HEADER_MAGIC, true);\n        headerView.setUint32(4, GLB_VERSION, true);\n        const totalByteLength = GLB_HEADER_BYTES + jsonChunkPrefix.byteLength + jsonChunk.byteLength + binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n        headerView.setUint32(8, totalByteLength, true);\n        const glbBlob = new Blob([header, jsonChunkPrefix, jsonChunk, binaryChunkPrefix, binaryChunk], {\n          type: 'application/octet-stream'\n        });\n        const glbReader = new FileReader();\n        glbReader.readAsArrayBuffer(glbBlob);\n        glbReader.onloadend = function () {\n          onDone(glbReader.result);\n        };\n      };\n    } else {\n      if (json.buffers && json.buffers.length > 0) {\n        const reader = new FileReader();\n        reader.readAsDataURL(blob);\n        reader.onloadend = function () {\n          const base64data = reader.result;\n          json.buffers[0].uri = base64data;\n          onDone(json);\n        };\n      } else {\n        onDone(json);\n      }\n    }\n  }\n\n  /**\n   * Serializes a userData.\n   *\n   * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry|THREE.AnimationClip} object\n   * @param {Object} objectDef\n   */\n  serializeUserData(object, objectDef) {\n    if (Object.keys(object.userData).length === 0) return;\n    const options = this.options;\n    const extensionsUsed = this.extensionsUsed;\n    try {\n      const json = JSON.parse(JSON.stringify(object.userData));\n      if (options.includeCustomExtensions && json.gltfExtensions) {\n        if (objectDef.extensions === undefined) objectDef.extensions = {};\n        for (const extensionName in json.gltfExtensions) {\n          objectDef.extensions[extensionName] = json.gltfExtensions[extensionName];\n          extensionsUsed[extensionName] = true;\n        }\n        delete json.gltfExtensions;\n      }\n      if (Object.keys(json).length > 0) objectDef.extras = json;\n    } catch (error) {\n      console.warn('THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' + 'won\\'t be serialized because of JSON.stringify error - ' + error.message);\n    }\n  }\n\n  /**\n   * Returns ids for buffer attributes.\n   *\n   * @param {Object} attribute\n   * @param {boolean} [isRelativeCopy=false]\n   * @return {number} An integer\n   */\n  getUID(attribute, isRelativeCopy = false) {\n    if (this.uids.has(attribute) === false) {\n      const uids = new Map();\n      uids.set(true, this.uid++);\n      uids.set(false, this.uid++);\n      this.uids.set(attribute, uids);\n    }\n    const uids = this.uids.get(attribute);\n    return uids.get(isRelativeCopy);\n  }\n\n  /**\n   * Checks if normal attribute values are normalized.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {boolean}\n   */\n  isNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return false;\n    const v = new Vector3();\n    for (let i = 0, il = normal.count; i < il; i++) {\n      // 0.0005 is from glTF-validator\n      if (Math.abs(v.fromBufferAttribute(normal, i).length() - 1.0) > 0.0005) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Creates normalized normal buffer attribute.\n   *\n   * @param {BufferAttribute} normal\n   * @returns {BufferAttribute}\n   *\n   */\n  createNormalizedNormalAttribute(normal) {\n    const cache = this.cache;\n    if (cache.attributesNormalized.has(normal)) return cache.attributesNormalized.get(normal);\n    const attribute = normal.clone();\n    const v = new Vector3();\n    for (let i = 0, il = attribute.count; i < il; i++) {\n      v.fromBufferAttribute(attribute, i);\n      if (v.x === 0 && v.y === 0 && v.z === 0) {\n        // if values can't be normalized set (1, 0, 0)\n        v.setX(1.0);\n      } else {\n        v.normalize();\n      }\n      attribute.setXYZ(i, v.x, v.y, v.z);\n    }\n    cache.attributesNormalized.set(normal, attribute);\n    return attribute;\n  }\n\n  /**\n   * Applies a texture transform, if present, to the map definition. Requires\n   * the KHR_texture_transform extension.\n   *\n   * @param {Object} mapDef\n   * @param {THREE.Texture} texture\n   */\n  applyTextureTransform(mapDef, texture) {\n    let didTransform = false;\n    const transformDef = {};\n    if (texture.offset.x !== 0 || texture.offset.y !== 0) {\n      transformDef.offset = texture.offset.toArray();\n      didTransform = true;\n    }\n    if (texture.rotation !== 0) {\n      transformDef.rotation = texture.rotation;\n      didTransform = true;\n    }\n    if (texture.repeat.x !== 1 || texture.repeat.y !== 1) {\n      transformDef.scale = texture.repeat.toArray();\n      didTransform = true;\n    }\n    if (didTransform) {\n      mapDef.extensions = mapDef.extensions || {};\n      mapDef.extensions['KHR_texture_transform'] = transformDef;\n      this.extensionsUsed['KHR_texture_transform'] = true;\n    }\n  }\n  async buildMetalRoughTextureAsync(metalnessMap, roughnessMap) {\n    if (metalnessMap === roughnessMap) return metalnessMap;\n    function getEncodingConversion(map) {\n      if (map.colorSpace === SRGBColorSpace) {\n        return function SRGBToLinear(c) {\n          return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n        };\n      }\n      return function LinearToLinear(c) {\n        return c;\n      };\n    }\n    if (metalnessMap instanceof CompressedTexture) {\n      metalnessMap = await this.decompressTextureAsync(metalnessMap);\n    }\n    if (roughnessMap instanceof CompressedTexture) {\n      roughnessMap = await this.decompressTextureAsync(roughnessMap);\n    }\n    const metalness = metalnessMap ? metalnessMap.image : null;\n    const roughness = roughnessMap ? roughnessMap.image : null;\n    const width = Math.max(metalness ? metalness.width : 0, roughness ? roughness.width : 0);\n    const height = Math.max(metalness ? metalness.height : 0, roughness ? roughness.height : 0);\n    const canvas = getCanvas();\n    canvas.width = width;\n    canvas.height = height;\n    const context = canvas.getContext('2d', {\n      willReadFrequently: true\n    });\n    context.fillStyle = '#00ffff';\n    context.fillRect(0, 0, width, height);\n    const composite = context.getImageData(0, 0, width, height);\n    if (metalness) {\n      context.drawImage(metalness, 0, 0, width, height);\n      const convert = getEncodingConversion(metalnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 2; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    if (roughness) {\n      context.drawImage(roughness, 0, 0, width, height);\n      const convert = getEncodingConversion(roughnessMap);\n      const data = context.getImageData(0, 0, width, height).data;\n      for (let i = 1; i < data.length; i += 4) {\n        composite.data[i] = convert(data[i] / 256) * 256;\n      }\n    }\n    context.putImageData(composite, 0, 0);\n\n    //\n\n    const reference = metalnessMap || roughnessMap;\n    const texture = reference.clone();\n    texture.source = new Source(canvas);\n    texture.colorSpace = NoColorSpace;\n    texture.channel = (metalnessMap || roughnessMap).channel;\n    if (metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel) {\n      console.warn('THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.');\n    }\n    console.warn('THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.');\n    return texture;\n  }\n  async decompressTextureAsync(texture, maxTextureSize = Infinity) {\n    if (this.textureUtils === null) {\n      throw new Error('THREE.GLTFExporter: setTextureUtils() must be called to process compressed textures.');\n    }\n    return await this.textureUtils.decompress(texture, maxTextureSize);\n  }\n\n  /**\n   * Process a buffer to append to the default one.\n   * @param {ArrayBuffer} buffer\n   * @return {0}\n   */\n  processBuffer(buffer) {\n    const json = this.json;\n    const buffers = this.buffers;\n    if (!json.buffers) json.buffers = [{\n      byteLength: 0\n    }];\n\n    // All buffers are merged before export.\n    buffers.push(buffer);\n    return 0;\n  }\n\n  /**\n   * Process and generate a BufferView\n   * @param {BufferAttribute} attribute\n   * @param {number} componentType\n   * @param {number} start\n   * @param {number} count\n   * @param {number} [target] Target usage of the BufferView\n   * @return {Object}\n   */\n  processBufferView(attribute, componentType, start, count, target) {\n    const json = this.json;\n    if (!json.bufferViews) json.bufferViews = [];\n\n    // Create a new dataview and dump the attribute's array into it\n\n    let componentSize;\n    switch (componentType) {\n      case WEBGL_CONSTANTS.BYTE:\n      case WEBGL_CONSTANTS.UNSIGNED_BYTE:\n        componentSize = 1;\n        break;\n      case WEBGL_CONSTANTS.SHORT:\n      case WEBGL_CONSTANTS.UNSIGNED_SHORT:\n        componentSize = 2;\n        break;\n      default:\n        componentSize = 4;\n    }\n    let byteStride = attribute.itemSize * componentSize;\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      // Each element of a vertex attribute MUST be aligned to 4-byte boundaries\n      // inside a bufferView\n      byteStride = Math.ceil(byteStride / 4) * 4;\n    }\n    const byteLength = getPaddedBufferSize(count * byteStride);\n    const dataView = new DataView(new ArrayBuffer(byteLength));\n    let offset = 0;\n    for (let i = start; i < start + count; i++) {\n      for (let a = 0; a < attribute.itemSize; a++) {\n        let value;\n        if (attribute.itemSize > 4) {\n          // no support for interleaved data for itemSize > 4\n\n          value = attribute.array[i * attribute.itemSize + a];\n        } else {\n          if (a === 0) value = attribute.getX(i);else if (a === 1) value = attribute.getY(i);else if (a === 2) value = attribute.getZ(i);else if (a === 3) value = attribute.getW(i);\n          if (attribute.normalized === true) {\n            value = MathUtils.normalize(value, attribute.array);\n          }\n        }\n        if (componentType === WEBGL_CONSTANTS.FLOAT) {\n          dataView.setFloat32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.INT) {\n          dataView.setInt32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_INT) {\n          dataView.setUint32(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.SHORT) {\n          dataView.setInt16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT) {\n          dataView.setUint16(offset, value, true);\n        } else if (componentType === WEBGL_CONSTANTS.BYTE) {\n          dataView.setInt8(offset, value);\n        } else if (componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE) {\n          dataView.setUint8(offset, value);\n        }\n        offset += componentSize;\n      }\n      if (offset % byteStride !== 0) {\n        offset += byteStride - offset % byteStride;\n      }\n    }\n    const bufferViewDef = {\n      buffer: this.processBuffer(dataView.buffer),\n      byteOffset: this.byteOffset,\n      byteLength: byteLength\n    };\n    if (target !== undefined) bufferViewDef.target = target;\n    if (target === WEBGL_CONSTANTS.ARRAY_BUFFER) {\n      // Only define byteStride for vertex attributes.\n      bufferViewDef.byteStride = byteStride;\n    }\n    this.byteOffset += byteLength;\n    json.bufferViews.push(bufferViewDef);\n\n    // @TODO Merge bufferViews where possible.\n    const output = {\n      id: json.bufferViews.length - 1,\n      byteLength: 0\n    };\n    return output;\n  }\n\n  /**\n   * Process and generate a BufferView from an image Blob.\n   * @param {Blob} blob\n   * @return {Promise<number>} An integer\n   */\n  processBufferViewImage(blob) {\n    const writer = this;\n    const json = writer.json;\n    if (!json.bufferViews) json.bufferViews = [];\n    return new Promise(function (resolve) {\n      const reader = new FileReader();\n      reader.readAsArrayBuffer(blob);\n      reader.onloadend = function () {\n        const buffer = getPaddedArrayBuffer(reader.result);\n        const bufferViewDef = {\n          buffer: writer.processBuffer(buffer),\n          byteOffset: writer.byteOffset,\n          byteLength: buffer.byteLength\n        };\n        writer.byteOffset += buffer.byteLength;\n        resolve(json.bufferViews.push(bufferViewDef) - 1);\n      };\n    });\n  }\n\n  /**\n   * Process attribute to generate an accessor\n   * @param {BufferAttribute} attribute Attribute to process\n   * @param {?BufferGeometry} [geometry] Geometry used for truncated draw range\n   * @param {number} [start=0]\n   * @param {number} [count=Infinity]\n   * @return {?number} Index of the processed accessor on the \"accessors\" array\n   */\n  processAccessor(attribute, geometry, start, count) {\n    const json = this.json;\n    const types = {\n      1: 'SCALAR',\n      2: 'VEC2',\n      3: 'VEC3',\n      4: 'VEC4',\n      9: 'MAT3',\n      16: 'MAT4'\n    };\n    let componentType;\n\n    // Detect the component type of the attribute array\n    if (attribute.array.constructor === Float32Array) {\n      componentType = WEBGL_CONSTANTS.FLOAT;\n    } else if (attribute.array.constructor === Int32Array) {\n      componentType = WEBGL_CONSTANTS.INT;\n    } else if (attribute.array.constructor === Uint32Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n    } else if (attribute.array.constructor === Int16Array) {\n      componentType = WEBGL_CONSTANTS.SHORT;\n    } else if (attribute.array.constructor === Uint16Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n    } else if (attribute.array.constructor === Int8Array) {\n      componentType = WEBGL_CONSTANTS.BYTE;\n    } else if (attribute.array.constructor === Uint8Array) {\n      componentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n    } else {\n      throw new Error('THREE.GLTFExporter: Unsupported bufferAttribute component type: ' + attribute.array.constructor.name);\n    }\n    if (start === undefined) start = 0;\n    if (count === undefined || count === Infinity) count = attribute.count;\n\n    // Skip creating an accessor if the attribute doesn't have data to export\n    if (count === 0) return null;\n    const minMax = getMinMax(attribute, start, count);\n    let bufferViewTarget;\n\n    // If geometry isn't provided, don't infer the target usage of the bufferView. For\n    // animation samplers, target must not be set.\n    if (geometry !== undefined) {\n      bufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n    }\n    const bufferView = this.processBufferView(attribute, componentType, start, count, bufferViewTarget);\n    const accessorDef = {\n      bufferView: bufferView.id,\n      byteOffset: bufferView.byteOffset,\n      componentType: componentType,\n      count: count,\n      max: minMax.max,\n      min: minMax.min,\n      type: types[attribute.itemSize]\n    };\n    if (attribute.normalized === true) accessorDef.normalized = true;\n    if (!json.accessors) json.accessors = [];\n    return json.accessors.push(accessorDef) - 1;\n  }\n\n  /**\n   * Process image\n   * @param {Image} image to process\n   * @param {number} format Identifier of the format (RGBAFormat)\n   * @param {boolean} flipY before writing out the image\n   * @param {string} mimeType export format\n   * @return {number}     Index of the processed texture in the \"images\" array\n   */\n  processImage(image, format, flipY, mimeType = 'image/png') {\n    if (image !== null) {\n      const writer = this;\n      const cache = writer.cache;\n      const json = writer.json;\n      const options = writer.options;\n      const pending = writer.pending;\n      if (!cache.images.has(image)) cache.images.set(image, {});\n      const cachedImages = cache.images.get(image);\n      const key = mimeType + ':flipY/' + flipY.toString();\n      if (cachedImages[key] !== undefined) return cachedImages[key];\n      if (!json.images) json.images = [];\n      const imageDef = {\n        mimeType: mimeType\n      };\n      const canvas = getCanvas();\n      canvas.width = Math.min(image.width, options.maxTextureSize);\n      canvas.height = Math.min(image.height, options.maxTextureSize);\n      const ctx = canvas.getContext('2d', {\n        willReadFrequently: true\n      });\n      if (flipY === true) {\n        ctx.translate(0, canvas.height);\n        ctx.scale(1, -1);\n      }\n      if (image.data !== undefined) {\n        // THREE.DataTexture\n\n        if (format !== RGBAFormat) {\n          console.error('GLTFExporter: Only RGBAFormat is supported.', format);\n        }\n        if (image.width > options.maxTextureSize || image.height > options.maxTextureSize) {\n          console.warn('GLTFExporter: Image size is bigger than maxTextureSize', image);\n        }\n        const data = new Uint8ClampedArray(image.height * image.width * 4);\n        for (let i = 0; i < data.length; i += 4) {\n          data[i + 0] = image.data[i + 0];\n          data[i + 1] = image.data[i + 1];\n          data[i + 2] = image.data[i + 2];\n          data[i + 3] = image.data[i + 3];\n        }\n        ctx.putImageData(new ImageData(data, image.width, image.height), 0, 0);\n      } else {\n        if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas) {\n          ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n        } else {\n          throw new Error('THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.');\n        }\n      }\n      if (options.binary === true) {\n        pending.push(getToBlobPromise(canvas, mimeType).then(blob => writer.processBufferViewImage(blob)).then(bufferViewIndex => {\n          imageDef.bufferView = bufferViewIndex;\n        }));\n      } else {\n        imageDef.uri = ImageUtils.getDataURL(canvas, mimeType);\n      }\n      const index = json.images.push(imageDef) - 1;\n      cachedImages[key] = index;\n      return index;\n    } else {\n      throw new Error('THREE.GLTFExporter: No valid image data found. Unable to process texture.');\n    }\n  }\n\n  /**\n   * Process sampler\n   * @param {Texture} map Texture to process\n   * @return {number}      Index of the processed texture in the \"samplers\" array\n   */\n  processSampler(map) {\n    const json = this.json;\n    if (!json.samplers) json.samplers = [];\n    const samplerDef = {\n      magFilter: THREE_TO_WEBGL[map.magFilter],\n      minFilter: THREE_TO_WEBGL[map.minFilter],\n      wrapS: THREE_TO_WEBGL[map.wrapS],\n      wrapT: THREE_TO_WEBGL[map.wrapT]\n    };\n    return json.samplers.push(samplerDef) - 1;\n  }\n\n  /**\n   * Process texture\n   * @param {Texture} map Map to process\n   * @return {Promise<number>} Index of the processed texture in the \"textures\" array\n   */\n  async processTextureAsync(map) {\n    const writer = this;\n    const options = writer.options;\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.textures.has(map)) return cache.textures.get(map);\n    if (!json.textures) json.textures = [];\n\n    // make non-readable textures (e.g. CompressedTexture) readable by blitting them into a new texture\n    if (map instanceof CompressedTexture) {\n      map = await this.decompressTextureAsync(map, options.maxTextureSize);\n    }\n    let mimeType = map.userData.mimeType;\n    if (mimeType === 'image/webp') mimeType = 'image/png';\n    const textureDef = {\n      sampler: this.processSampler(map),\n      source: this.processImage(map.image, map.format, map.flipY, mimeType)\n    };\n    if (map.name) textureDef.name = map.name;\n    await this._invokeAllAsync(async function (ext) {\n      ext.writeTexture && (await ext.writeTexture(map, textureDef));\n    });\n    const index = json.textures.push(textureDef) - 1;\n    cache.textures.set(map, index);\n    return index;\n  }\n\n  /**\n   * Process material\n   * @param {THREE.Material} material Material to process\n   * @return {Promise<?number>} Index of the processed material in the \"materials\" array\n   */\n  async processMaterialAsync(material) {\n    const cache = this.cache;\n    const json = this.json;\n    if (cache.materials.has(material)) return cache.materials.get(material);\n    if (material.isShaderMaterial) {\n      console.warn('GLTFExporter: THREE.ShaderMaterial not supported.');\n      return null;\n    }\n    if (!json.materials) json.materials = [];\n\n    // @QUESTION Should we avoid including any attribute that has the default value?\n    const materialDef = {\n      pbrMetallicRoughness: {}\n    };\n    if (material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true) {\n      console.warn('GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.');\n    }\n\n    // pbrMetallicRoughness.baseColorFactor\n    const color = material.color.toArray().concat([material.opacity]);\n    if (!equalArray(color, [1, 1, 1, 1])) {\n      materialDef.pbrMetallicRoughness.baseColorFactor = color;\n    }\n    if (material.isMeshStandardMaterial) {\n      materialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n      materialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n    } else {\n      materialDef.pbrMetallicRoughness.metallicFactor = 0;\n      materialDef.pbrMetallicRoughness.roughnessFactor = 1;\n    }\n\n    // pbrMetallicRoughness.metallicRoughnessTexture\n    if (material.metalnessMap || material.roughnessMap) {\n      const metalRoughTexture = await this.buildMetalRoughTextureAsync(material.metalnessMap, material.roughnessMap);\n      const metalRoughMapDef = {\n        index: await this.processTextureAsync(metalRoughTexture),\n        texCoord: metalRoughTexture.channel\n      };\n      this.applyTextureTransform(metalRoughMapDef, metalRoughTexture);\n      materialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n    }\n\n    // pbrMetallicRoughness.baseColorTexture\n    if (material.map) {\n      const baseColorMapDef = {\n        index: await this.processTextureAsync(material.map),\n        texCoord: material.map.channel\n      };\n      this.applyTextureTransform(baseColorMapDef, material.map);\n      materialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n    }\n    if (material.emissive) {\n      const emissive = material.emissive;\n      const maxEmissiveComponent = Math.max(emissive.r, emissive.g, emissive.b);\n      if (maxEmissiveComponent > 0) {\n        materialDef.emissiveFactor = material.emissive.toArray();\n      }\n\n      // emissiveTexture\n      if (material.emissiveMap) {\n        const emissiveMapDef = {\n          index: await this.processTextureAsync(material.emissiveMap),\n          texCoord: material.emissiveMap.channel\n        };\n        this.applyTextureTransform(emissiveMapDef, material.emissiveMap);\n        materialDef.emissiveTexture = emissiveMapDef;\n      }\n    }\n\n    // normalTexture\n    if (material.normalMap) {\n      const normalMapDef = {\n        index: await this.processTextureAsync(material.normalMap),\n        texCoord: material.normalMap.channel\n      };\n      if (material.normalScale && material.normalScale.x !== 1) {\n        // glTF normal scale is univariate. Ignore `y`, which may be flipped.\n        // Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n        normalMapDef.scale = material.normalScale.x;\n      }\n      this.applyTextureTransform(normalMapDef, material.normalMap);\n      materialDef.normalTexture = normalMapDef;\n    }\n\n    // occlusionTexture\n    if (material.aoMap) {\n      const occlusionMapDef = {\n        index: await this.processTextureAsync(material.aoMap),\n        texCoord: material.aoMap.channel\n      };\n      if (material.aoMapIntensity !== 1.0) {\n        occlusionMapDef.strength = material.aoMapIntensity;\n      }\n      this.applyTextureTransform(occlusionMapDef, material.aoMap);\n      materialDef.occlusionTexture = occlusionMapDef;\n    }\n\n    // alphaMode\n    if (material.transparent) {\n      materialDef.alphaMode = 'BLEND';\n    } else {\n      if (material.alphaTest > 0.0) {\n        materialDef.alphaMode = 'MASK';\n        materialDef.alphaCutoff = material.alphaTest;\n      }\n    }\n\n    // doubleSided\n    if (material.side === DoubleSide) materialDef.doubleSided = true;\n    if (material.name !== '') materialDef.name = material.name;\n    this.serializeUserData(material, materialDef);\n    await this._invokeAllAsync(async function (ext) {\n      ext.writeMaterialAsync && (await ext.writeMaterialAsync(material, materialDef));\n    });\n    const index = json.materials.push(materialDef) - 1;\n    cache.materials.set(material, index);\n    return index;\n  }\n\n  /**\n   * Process mesh\n   * @param {THREE.Mesh} mesh Mesh to process\n   * @return {Promise<?number>} Index of the processed mesh in the \"meshes\" array\n   */\n  async processMeshAsync(mesh) {\n    const cache = this.cache;\n    const json = this.json;\n    const meshCacheKeyParts = [mesh.geometry.uuid];\n    if (Array.isArray(mesh.material)) {\n      for (let i = 0, l = mesh.material.length; i < l; i++) {\n        meshCacheKeyParts.push(mesh.material[i].uuid);\n      }\n    } else {\n      meshCacheKeyParts.push(mesh.material.uuid);\n    }\n    const meshCacheKey = meshCacheKeyParts.join(':');\n    if (cache.meshes.has(meshCacheKey)) return cache.meshes.get(meshCacheKey);\n    const geometry = mesh.geometry;\n    let mode;\n\n    // Use the correct mode\n    if (mesh.isLineSegments) {\n      mode = WEBGL_CONSTANTS.LINES;\n    } else if (mesh.isLineLoop) {\n      mode = WEBGL_CONSTANTS.LINE_LOOP;\n    } else if (mesh.isLine) {\n      mode = WEBGL_CONSTANTS.LINE_STRIP;\n    } else if (mesh.isPoints) {\n      mode = WEBGL_CONSTANTS.POINTS;\n    } else {\n      mode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n    }\n    const meshDef = {};\n    const attributes = {};\n    const primitives = [];\n    const targets = [];\n\n    // Conversion between attributes names in threejs and gltf spec\n    const nameConversion = {\n      uv: 'TEXCOORD_0',\n      uv1: 'TEXCOORD_1',\n      uv2: 'TEXCOORD_2',\n      uv3: 'TEXCOORD_3',\n      color: 'COLOR_0',\n      skinWeight: 'WEIGHTS_0',\n      skinIndex: 'JOINTS_0'\n    };\n    const originalNormal = geometry.getAttribute('normal');\n    if (originalNormal !== undefined && !this.isNormalizedNormalAttribute(originalNormal)) {\n      console.warn('THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.');\n      geometry.setAttribute('normal', this.createNormalizedNormalAttribute(originalNormal));\n    }\n\n    // @QUESTION Detect if .vertexColors = true?\n    // For every attribute create an accessor\n    let modifiedAttribute = null;\n    for (let attributeName in geometry.attributes) {\n      // Ignore morph target attributes, which are exported later.\n      if (attributeName.slice(0, 5) === 'morph') continue;\n      const attribute = geometry.attributes[attributeName];\n      attributeName = nameConversion[attributeName] || attributeName.toUpperCase();\n\n      // Prefix all geometry attributes except the ones specifically\n      // listed in the spec; non-spec attributes are considered custom.\n      const validVertexAttributes = /^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n      if (!validVertexAttributes.test(attributeName)) attributeName = '_' + attributeName;\n      if (cache.attributes.has(this.getUID(attribute))) {\n        attributes[attributeName] = cache.attributes.get(this.getUID(attribute));\n        continue;\n      }\n\n      // Enforce glTF vertex attribute requirements:\n      // - JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT\n      // - Only custom attributes may be INT or UNSIGNED_INT\n      modifiedAttribute = null;\n      const array = attribute.array;\n      if (attributeName === 'JOINTS_0' && !(array instanceof Uint16Array) && !(array instanceof Uint8Array)) {\n        console.warn('GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.');\n        modifiedAttribute = new BufferAttribute(new Uint16Array(array), attribute.itemSize, attribute.normalized);\n      } else if ((array instanceof Uint32Array || array instanceof Int32Array) && !attributeName.startsWith('_')) {\n        console.warn(`GLTFExporter: Attribute \"${attributeName}\" converted to type FLOAT.`);\n        modifiedAttribute = GLTFExporter.Utils.toFloat32BufferAttribute(attribute);\n      }\n      const accessor = this.processAccessor(modifiedAttribute || attribute, geometry);\n      if (accessor !== null) {\n        if (!attributeName.startsWith('_')) {\n          this.detectMeshQuantization(attributeName, attribute);\n        }\n        attributes[attributeName] = accessor;\n        cache.attributes.set(this.getUID(attribute), accessor);\n      }\n    }\n    if (originalNormal !== undefined) geometry.setAttribute('normal', originalNormal);\n\n    // Skip if no exportable attributes found\n    if (Object.keys(attributes).length === 0) return null;\n\n    // Morph targets\n    if (mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0) {\n      const weights = [];\n      const targetNames = [];\n      const reverseDictionary = {};\n      if (mesh.morphTargetDictionary !== undefined) {\n        for (const key in mesh.morphTargetDictionary) {\n          reverseDictionary[mesh.morphTargetDictionary[key]] = key;\n        }\n      }\n      for (let i = 0; i < mesh.morphTargetInfluences.length; ++i) {\n        const target = {};\n        let warned = false;\n        for (const attributeName in geometry.morphAttributes) {\n          // glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n          // Three.js doesn't support TANGENT yet.\n\n          if (attributeName !== 'position' && attributeName !== 'normal') {\n            if (!warned) {\n              console.warn('GLTFExporter: Only POSITION and NORMAL morph are supported.');\n              warned = true;\n            }\n            continue;\n          }\n          const attribute = geometry.morphAttributes[attributeName][i];\n          const gltfAttributeName = attributeName.toUpperCase();\n\n          // Three.js morph attribute has absolute values while the one of glTF has relative values.\n          //\n          // glTF 2.0 Specification:\n          // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n          const baseAttribute = geometry.attributes[attributeName];\n          if (cache.attributes.has(this.getUID(attribute, true))) {\n            target[gltfAttributeName] = cache.attributes.get(this.getUID(attribute, true));\n            continue;\n          }\n\n          // Clones attribute not to override\n          const relativeAttribute = attribute.clone();\n          if (!geometry.morphTargetsRelative) {\n            for (let j = 0, jl = attribute.count; j < jl; j++) {\n              for (let a = 0; a < attribute.itemSize; a++) {\n                if (a === 0) relativeAttribute.setX(j, attribute.getX(j) - baseAttribute.getX(j));\n                if (a === 1) relativeAttribute.setY(j, attribute.getY(j) - baseAttribute.getY(j));\n                if (a === 2) relativeAttribute.setZ(j, attribute.getZ(j) - baseAttribute.getZ(j));\n                if (a === 3) relativeAttribute.setW(j, attribute.getW(j) - baseAttribute.getW(j));\n              }\n            }\n          }\n          target[gltfAttributeName] = this.processAccessor(relativeAttribute, geometry);\n          cache.attributes.set(this.getUID(baseAttribute, true), target[gltfAttributeName]);\n        }\n        targets.push(target);\n        weights.push(mesh.morphTargetInfluences[i]);\n        if (mesh.morphTargetDictionary !== undefined) targetNames.push(reverseDictionary[i]);\n      }\n      meshDef.weights = weights;\n      if (targetNames.length > 0) {\n        meshDef.extras = {};\n        meshDef.extras.targetNames = targetNames;\n      }\n    }\n    const isMultiMaterial = Array.isArray(mesh.material);\n    if (isMultiMaterial && geometry.groups.length === 0) return null;\n    let didForceIndices = false;\n    if (isMultiMaterial && geometry.index === null) {\n      const indices = [];\n      for (let i = 0, il = geometry.attributes.position.count; i < il; i++) {\n        indices[i] = i;\n      }\n      geometry.setIndex(indices);\n      didForceIndices = true;\n    }\n    const materials = isMultiMaterial ? mesh.material : [mesh.material];\n    const groups = isMultiMaterial ? geometry.groups : [{\n      materialIndex: 0,\n      start: undefined,\n      count: undefined\n    }];\n    for (let i = 0, il = groups.length; i < il; i++) {\n      const primitive = {\n        mode: mode,\n        attributes: attributes\n      };\n      this.serializeUserData(geometry, primitive);\n      if (targets.length > 0) primitive.targets = targets;\n      if (geometry.index !== null) {\n        let cacheKey = this.getUID(geometry.index);\n        if (groups[i].start !== undefined || groups[i].count !== undefined) {\n          cacheKey += ':' + groups[i].start + ':' + groups[i].count;\n        }\n        if (cache.attributes.has(cacheKey)) {\n          primitive.indices = cache.attributes.get(cacheKey);\n        } else {\n          primitive.indices = this.processAccessor(geometry.index, geometry, groups[i].start, groups[i].count);\n          cache.attributes.set(cacheKey, primitive.indices);\n        }\n        if (primitive.indices === null) delete primitive.indices;\n      }\n      const material = await this.processMaterialAsync(materials[groups[i].materialIndex]);\n      if (material !== null) primitive.material = material;\n      primitives.push(primitive);\n    }\n    if (didForceIndices === true) {\n      geometry.setIndex(null);\n    }\n    meshDef.primitives = primitives;\n    if (!json.meshes) json.meshes = [];\n    await this._invokeAllAsync(function (ext) {\n      ext.writeMesh && ext.writeMesh(mesh, meshDef);\n    });\n    const index = json.meshes.push(meshDef) - 1;\n    cache.meshes.set(meshCacheKey, index);\n    return index;\n  }\n\n  /**\n   * If a vertex attribute with a\n   * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n   * is used, it is checked whether it is a valid data type according to the\n   * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n   * extension.\n   * In this case the extension is automatically added to the list of used extensions.\n   *\n   * @param {string} attributeName\n   * @param {THREE.BufferAttribute} attribute\n   */\n  detectMeshQuantization(attributeName, attribute) {\n    if (this.extensionsUsed[KHR_MESH_QUANTIZATION]) return;\n    let attrType = undefined;\n    switch (attribute.array.constructor) {\n      case Int8Array:\n        attrType = 'byte';\n        break;\n      case Uint8Array:\n        attrType = 'unsigned byte';\n        break;\n      case Int16Array:\n        attrType = 'short';\n        break;\n      case Uint16Array:\n        attrType = 'unsigned short';\n        break;\n      default:\n        return;\n    }\n    if (attribute.normalized) attrType += ' normalized';\n    const attrNamePrefix = attributeName.split('_', 1)[0];\n    if (KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix] && KHR_mesh_quantization_ExtraAttrTypes[attrNamePrefix].includes(attrType)) {\n      this.extensionsUsed[KHR_MESH_QUANTIZATION] = true;\n      this.extensionsRequired[KHR_MESH_QUANTIZATION] = true;\n    }\n  }\n\n  /**\n   * Process camera\n   * @param {THREE.Camera} camera Camera to process\n   * @return {number} Index of the processed mesh in the \"camera\" array\n   */\n  processCamera(camera) {\n    const json = this.json;\n    if (!json.cameras) json.cameras = [];\n    const isOrtho = camera.isOrthographicCamera;\n    const cameraDef = {\n      type: isOrtho ? 'orthographic' : 'perspective'\n    };\n    if (isOrtho) {\n      cameraDef.orthographic = {\n        xmag: camera.right * 2,\n        ymag: camera.top * 2,\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    } else {\n      cameraDef.perspective = {\n        aspectRatio: camera.aspect,\n        yfov: MathUtils.degToRad(camera.fov),\n        zfar: camera.far <= 0 ? 0.001 : camera.far,\n        znear: camera.near < 0 ? 0 : camera.near\n      };\n    }\n\n    // Question: Is saving \"type\" as name intentional?\n    if (camera.name !== '') cameraDef.name = camera.type;\n    return json.cameras.push(cameraDef) - 1;\n  }\n\n  /**\n   * Creates glTF animation entry from AnimationClip object.\n   *\n   * Status:\n   * - Only properties listed in PATH_PROPERTIES may be animated.\n   *\n   * @param {THREE.AnimationClip} clip\n   * @param {THREE.Object3D} root\n   * @return {?number}\n   */\n  processAnimation(clip, root) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    if (!json.animations) json.animations = [];\n    clip = GLTFExporter.Utils.mergeMorphTargetTracks(clip.clone(), root);\n    const tracks = clip.tracks;\n    const channels = [];\n    const samplers = [];\n    for (let i = 0; i < tracks.length; ++i) {\n      const track = tracks[i];\n      const trackBinding = PropertyBinding.parseTrackName(track.name);\n      let trackNode = PropertyBinding.findNode(root, trackBinding.nodeName);\n      const trackProperty = PATH_PROPERTIES[trackBinding.propertyName];\n      if (trackBinding.objectName === 'bones') {\n        if (trackNode.isSkinnedMesh === true) {\n          trackNode = trackNode.skeleton.getBoneByName(trackBinding.objectIndex);\n        } else {\n          trackNode = undefined;\n        }\n      }\n      if (!trackNode || !trackProperty) {\n        console.warn('THREE.GLTFExporter: Could not export animation track \"%s\".', track.name);\n        continue;\n      }\n      const inputItemSize = 1;\n      let outputItemSize = track.values.length / track.times.length;\n      if (trackProperty === PATH_PROPERTIES.morphTargetInfluences) {\n        outputItemSize /= trackNode.morphTargetInfluences.length;\n      }\n      let interpolation;\n\n      // @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n      // Detecting glTF cubic spline interpolant by checking factory method's special property\n      // GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n      // valid value from .getInterpolation().\n      if (track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true) {\n        interpolation = 'CUBICSPLINE';\n\n        // itemSize of CUBICSPLINE keyframe is 9\n        // (VEC3 * 3: inTangent, splineVertex, and outTangent)\n        // but needs to be stored as VEC3 so dividing by 3 here.\n        outputItemSize /= 3;\n      } else if (track.getInterpolation() === InterpolateDiscrete) {\n        interpolation = 'STEP';\n      } else {\n        interpolation = 'LINEAR';\n      }\n      samplers.push({\n        input: this.processAccessor(new BufferAttribute(track.times, inputItemSize)),\n        output: this.processAccessor(new BufferAttribute(track.values, outputItemSize)),\n        interpolation: interpolation\n      });\n      channels.push({\n        sampler: samplers.length - 1,\n        target: {\n          node: nodeMap.get(trackNode),\n          path: trackProperty\n        }\n      });\n    }\n    const animationDef = {\n      name: clip.name || 'clip_' + json.animations.length,\n      samplers: samplers,\n      channels: channels\n    };\n    this.serializeUserData(clip, animationDef);\n    json.animations.push(animationDef);\n    return json.animations.length - 1;\n  }\n\n  /**\n   * @param {THREE.Object3D} object\n   * @return {?number}\n   */\n  processSkin(object) {\n    const json = this.json;\n    const nodeMap = this.nodeMap;\n    const node = json.nodes[nodeMap.get(object)];\n    const skeleton = object.skeleton;\n    if (skeleton === undefined) return null;\n    const rootJoint = object.skeleton.bones[0];\n    if (rootJoint === undefined) return null;\n    const joints = [];\n    const inverseBindMatrices = new Float32Array(skeleton.bones.length * 16);\n    const temporaryBoneInverse = new Matrix4();\n    for (let i = 0; i < skeleton.bones.length; ++i) {\n      joints.push(nodeMap.get(skeleton.bones[i]));\n      temporaryBoneInverse.copy(skeleton.boneInverses[i]);\n      temporaryBoneInverse.multiply(object.bindMatrix).toArray(inverseBindMatrices, i * 16);\n    }\n    if (json.skins === undefined) json.skins = [];\n    json.skins.push({\n      inverseBindMatrices: this.processAccessor(new BufferAttribute(inverseBindMatrices, 16)),\n      joints: joints,\n      skeleton: nodeMap.get(rootJoint)\n    });\n    const skinIndex = node.skin = json.skins.length - 1;\n    return skinIndex;\n  }\n\n  /**\n   * Process Object3D node\n   * @param {THREE.Object3D} object Object3D to processNodeAsync\n   * @return {Promise<number>} Index of the node in the nodes list\n   */\n  async processNodeAsync(object) {\n    const json = this.json;\n    const options = this.options;\n    const nodeMap = this.nodeMap;\n    if (!json.nodes) json.nodes = [];\n    const nodeDef = {};\n    if (options.trs) {\n      const rotation = object.quaternion.toArray();\n      const position = object.position.toArray();\n      const scale = object.scale.toArray();\n      if (!equalArray(rotation, [0, 0, 0, 1])) {\n        nodeDef.rotation = rotation;\n      }\n      if (!equalArray(position, [0, 0, 0])) {\n        nodeDef.translation = position;\n      }\n      if (!equalArray(scale, [1, 1, 1])) {\n        nodeDef.scale = scale;\n      }\n    } else {\n      if (object.matrixAutoUpdate) {\n        object.updateMatrix();\n      }\n      if (isIdentityMatrix(object.matrix) === false) {\n        nodeDef.matrix = object.matrix.elements;\n      }\n    }\n\n    // We don't export empty strings name because it represents no-name in Three.js.\n    if (object.name !== '') nodeDef.name = String(object.name);\n    this.serializeUserData(object, nodeDef);\n    if (object.isMesh || object.isLine || object.isPoints) {\n      const meshIndex = await this.processMeshAsync(object);\n      if (meshIndex !== null) nodeDef.mesh = meshIndex;\n    } else if (object.isCamera) {\n      nodeDef.camera = this.processCamera(object);\n    }\n    if (object.isSkinnedMesh) this.skins.push(object);\n    const nodeIndex = json.nodes.push(nodeDef) - 1;\n    nodeMap.set(object, nodeIndex);\n    if (object.children.length > 0) {\n      const children = [];\n      for (let i = 0, l = object.children.length; i < l; i++) {\n        const child = object.children[i];\n        if (child.visible || options.onlyVisible === false) {\n          const childNodeIndex = await this.processNodeAsync(child);\n          if (childNodeIndex !== null) children.push(childNodeIndex);\n        }\n      }\n      if (children.length > 0) nodeDef.children = children;\n    }\n    await this._invokeAllAsync(function (ext) {\n      ext.writeNode && ext.writeNode(object, nodeDef);\n    });\n    return nodeIndex;\n  }\n\n  /**\n   * Process Scene\n   * @param {Scene} scene Scene to process\n   */\n  async processSceneAsync(scene) {\n    const json = this.json;\n    const options = this.options;\n    if (!json.scenes) {\n      json.scenes = [];\n      json.scene = 0;\n    }\n    const sceneDef = {};\n    if (scene.name !== '') sceneDef.name = scene.name;\n    json.scenes.push(sceneDef);\n    const nodes = [];\n    for (let i = 0, l = scene.children.length; i < l; i++) {\n      const child = scene.children[i];\n      if (child.visible || options.onlyVisible === false) {\n        const nodeIndex = await this.processNodeAsync(child);\n        if (nodeIndex !== null) nodes.push(nodeIndex);\n      }\n    }\n    if (nodes.length > 0) sceneDef.nodes = nodes;\n    this.serializeUserData(scene, sceneDef);\n  }\n\n  /**\n   * Creates a Scene to hold a list of objects and parse it\n   * @param {Array<THREE.Object3D>} objects List of objects to process\n   */\n  async processObjectsAsync(objects) {\n    const scene = new Scene();\n    scene.name = 'AuxScene';\n    for (let i = 0; i < objects.length; i++) {\n      // We push directly to children instead of calling `add` to prevent\n      // modify the .parent and break its original scene and hierarchy\n      scene.children.push(objects[i]);\n    }\n    await this.processSceneAsync(scene);\n  }\n\n  /**\n   * @param {THREE.Object3D|Array<THREE.Object3D>} input\n   */\n  async processInputAsync(input) {\n    const options = this.options;\n    input = input instanceof Array ? input : [input];\n    await this._invokeAllAsync(function (ext) {\n      ext.beforeParse && ext.beforeParse(input);\n    });\n    const objectsWithoutScene = [];\n    for (let i = 0; i < input.length; i++) {\n      if (input[i] instanceof Scene) {\n        await this.processSceneAsync(input[i]);\n      } else {\n        objectsWithoutScene.push(input[i]);\n      }\n    }\n    if (objectsWithoutScene.length > 0) {\n      await this.processObjectsAsync(objectsWithoutScene);\n    }\n    for (let i = 0; i < this.skins.length; ++i) {\n      this.processSkin(this.skins[i]);\n    }\n    for (let i = 0; i < options.animations.length; ++i) {\n      this.processAnimation(options.animations[i], input[0]);\n    }\n    await this._invokeAllAsync(function (ext) {\n      ext.afterParse && ext.afterParse(input);\n    });\n  }\n  async _invokeAllAsync(func) {\n    for (let i = 0, il = this.plugins.length; i < il; i++) {\n      await func(this.plugins[i]);\n    }\n  }\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n *\n * @private\n */\nclass GLTFLightExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_lights_punctual';\n  }\n  writeNode(light, nodeDef) {\n    if (!light.isLight) return;\n    if (!light.isDirectionalLight && !light.isPointLight && !light.isSpotLight) {\n      console.warn('THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light);\n      return;\n    }\n    const writer = this.writer;\n    const json = writer.json;\n    const extensionsUsed = writer.extensionsUsed;\n    const lightDef = {};\n    if (light.name) lightDef.name = light.name;\n    lightDef.color = light.color.toArray();\n    lightDef.intensity = light.intensity;\n    if (light.isDirectionalLight) {\n      lightDef.type = 'directional';\n    } else if (light.isPointLight) {\n      lightDef.type = 'point';\n      if (light.distance > 0) lightDef.range = light.distance;\n    } else if (light.isSpotLight) {\n      lightDef.type = 'spot';\n      if (light.distance > 0) lightDef.range = light.distance;\n      lightDef.spot = {};\n      lightDef.spot.innerConeAngle = (1.0 - light.penumbra) * light.angle;\n      lightDef.spot.outerConeAngle = light.angle;\n    }\n    if (light.decay !== undefined && light.decay !== 2) {\n      console.warn('THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, ' + 'and expects light.decay=2.');\n    }\n    if (light.target && (light.target.parent !== light || light.target.position.x !== 0 || light.target.position.y !== 0 || light.target.position.z !== -1)) {\n      console.warn('THREE.GLTFExporter: Light direction may be lost. For best results, ' + 'make light.target a child of the light with position 0,0,-1.');\n    }\n    if (!extensionsUsed[this.name]) {\n      json.extensions = json.extensions || {};\n      json.extensions[this.name] = {\n        lights: []\n      };\n      extensionsUsed[this.name] = true;\n    }\n    const lights = json.extensions[this.name].lights;\n    lights.push(lightDef);\n    nodeDef.extensions = nodeDef.extensions || {};\n    nodeDef.extensions[this.name] = {\n      light: lights.length - 1\n    };\n  }\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n *\n * @private\n */\nclass GLTFMaterialsUnlitExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_unlit';\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshBasicMaterial) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = {};\n    extensionsUsed[this.name] = true;\n    materialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n    materialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n  }\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n *\n * @private\n */\nclass GLTFMaterialsClearcoatExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_clearcoat';\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.clearcoat === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.clearcoatFactor = material.clearcoat;\n    if (material.clearcoatMap) {\n      const clearcoatMapDef = {\n        index: await writer.processTextureAsync(material.clearcoatMap),\n        texCoord: material.clearcoatMap.channel\n      };\n      writer.applyTextureTransform(clearcoatMapDef, material.clearcoatMap);\n      extensionDef.clearcoatTexture = clearcoatMapDef;\n    }\n    extensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n    if (material.clearcoatRoughnessMap) {\n      const clearcoatRoughnessMapDef = {\n        index: await writer.processTextureAsync(material.clearcoatRoughnessMap),\n        texCoord: material.clearcoatRoughnessMap.channel\n      };\n      writer.applyTextureTransform(clearcoatRoughnessMapDef, material.clearcoatRoughnessMap);\n      extensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n    }\n    if (material.clearcoatNormalMap) {\n      const clearcoatNormalMapDef = {\n        index: await writer.processTextureAsync(material.clearcoatNormalMap),\n        texCoord: material.clearcoatNormalMap.channel\n      };\n      if (material.clearcoatNormalScale.x !== 1) clearcoatNormalMapDef.scale = material.clearcoatNormalScale.x;\n      writer.applyTextureTransform(clearcoatNormalMapDef, material.clearcoatNormalMap);\n      extensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_dispersion\n *\n * @private\n */\nclass GLTFMaterialsDispersionExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_dispersion';\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.dispersion === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.dispersion = material.dispersion;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n *\n * @private\n */\nclass GLTFMaterialsIridescenceExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_iridescence';\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.iridescence === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.iridescenceFactor = material.iridescence;\n    if (material.iridescenceMap) {\n      const iridescenceMapDef = {\n        index: await writer.processTextureAsync(material.iridescenceMap),\n        texCoord: material.iridescenceMap.channel\n      };\n      writer.applyTextureTransform(iridescenceMapDef, material.iridescenceMap);\n      extensionDef.iridescenceTexture = iridescenceMapDef;\n    }\n    extensionDef.iridescenceIor = material.iridescenceIOR;\n    extensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[0];\n    extensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[1];\n    if (material.iridescenceThicknessMap) {\n      const iridescenceThicknessMapDef = {\n        index: await writer.processTextureAsync(material.iridescenceThicknessMap),\n        texCoord: material.iridescenceThicknessMap.channel\n      };\n      writer.applyTextureTransform(iridescenceThicknessMapDef, material.iridescenceThicknessMap);\n      extensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n *\n * @private\n */\nclass GLTFMaterialsTransmissionExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_transmission';\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.transmissionFactor = material.transmission;\n    if (material.transmissionMap) {\n      const transmissionMapDef = {\n        index: await writer.processTextureAsync(material.transmissionMap),\n        texCoord: material.transmissionMap.channel\n      };\n      writer.applyTextureTransform(transmissionMapDef, material.transmissionMap);\n      extensionDef.transmissionTexture = transmissionMapDef;\n    }\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n *\n * @private\n */\nclass GLTFMaterialsVolumeExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_volume';\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.transmission === 0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.thicknessFactor = material.thickness;\n    if (material.thicknessMap) {\n      const thicknessMapDef = {\n        index: await writer.processTextureAsync(material.thicknessMap),\n        texCoord: material.thicknessMap.channel\n      };\n      writer.applyTextureTransform(thicknessMapDef, material.thicknessMap);\n      extensionDef.thicknessTexture = thicknessMapDef;\n    }\n    if (material.attenuationDistance !== Infinity) {\n      extensionDef.attenuationDistance = material.attenuationDistance;\n    }\n    extensionDef.attenuationColor = material.attenuationColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n *\n * @private\n */\nclass GLTFMaterialsIorExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_ior';\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.ior === 1.5) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.ior = material.ior;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n *\n * @private\n */\nclass GLTFMaterialsSpecularExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_specular';\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.specularIntensity === 1.0 && material.specularColor.equals(DEFAULT_SPECULAR_COLOR) && !material.specularIntensityMap && !material.specularColorMap) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.specularIntensityMap) {\n      const specularIntensityMapDef = {\n        index: await writer.processTextureAsync(material.specularIntensityMap),\n        texCoord: material.specularIntensityMap.channel\n      };\n      writer.applyTextureTransform(specularIntensityMapDef, material.specularIntensityMap);\n      extensionDef.specularTexture = specularIntensityMapDef;\n    }\n    if (material.specularColorMap) {\n      const specularColorMapDef = {\n        index: await writer.processTextureAsync(material.specularColorMap),\n        texCoord: material.specularColorMap.channel\n      };\n      writer.applyTextureTransform(specularColorMapDef, material.specularColorMap);\n      extensionDef.specularColorTexture = specularColorMapDef;\n    }\n    extensionDef.specularFactor = material.specularIntensity;\n    extensionDef.specularColorFactor = material.specularColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n *\n * @private\n */\nclass GLTFMaterialsSheenExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_sheen';\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.sheen == 0.0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.sheenRoughnessMap) {\n      const sheenRoughnessMapDef = {\n        index: await writer.processTextureAsync(material.sheenRoughnessMap),\n        texCoord: material.sheenRoughnessMap.channel\n      };\n      writer.applyTextureTransform(sheenRoughnessMapDef, material.sheenRoughnessMap);\n      extensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n    }\n    if (material.sheenColorMap) {\n      const sheenColorMapDef = {\n        index: await writer.processTextureAsync(material.sheenColorMap),\n        texCoord: material.sheenColorMap.channel\n      };\n      writer.applyTextureTransform(sheenColorMapDef, material.sheenColorMap);\n      extensionDef.sheenColorTexture = sheenColorMapDef;\n    }\n    extensionDef.sheenRoughnessFactor = material.sheenRoughness;\n    extensionDef.sheenColorFactor = material.sheenColor.toArray();\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Anisotropy Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\n *\n * @private\n */\nclass GLTFMaterialsAnisotropyExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_anisotropy';\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshPhysicalMaterial || material.anisotropy == 0.0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.anisotropyMap) {\n      const anisotropyMapDef = {\n        index: await writer.processTextureAsync(material.anisotropyMap)\n      };\n      writer.applyTextureTransform(anisotropyMapDef, material.anisotropyMap);\n      extensionDef.anisotropyTexture = anisotropyMapDef;\n    }\n    extensionDef.anisotropyStrength = material.anisotropy;\n    extensionDef.anisotropyRotation = material.anisotropyRotation;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n *\n * @private\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_emissive_strength';\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshStandardMaterial || material.emissiveIntensity === 1.0) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    extensionDef.emissiveStrength = material.emissiveIntensity;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n *\n * @private\n */\nclass GLTFMaterialsBumpExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'EXT_materials_bump';\n  }\n  async writeMaterialAsync(material, materialDef) {\n    if (!material.isMeshStandardMaterial || material.bumpScale === 1 && !material.bumpMap) return;\n    const writer = this.writer;\n    const extensionsUsed = writer.extensionsUsed;\n    const extensionDef = {};\n    if (material.bumpMap) {\n      const bumpMapDef = {\n        index: await writer.processTextureAsync(material.bumpMap),\n        texCoord: material.bumpMap.channel\n      };\n      writer.applyTextureTransform(bumpMapDef, material.bumpMap);\n      extensionDef.bumpTexture = bumpMapDef;\n    }\n    extensionDef.bumpFactor = material.bumpScale;\n    materialDef.extensions = materialDef.extensions || {};\n    materialDef.extensions[this.name] = extensionDef;\n    extensionsUsed[this.name] = true;\n  }\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n * @private\n */\nclass GLTFMeshGpuInstancing {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'EXT_mesh_gpu_instancing';\n  }\n  writeNode(object, nodeDef) {\n    if (!object.isInstancedMesh) return;\n    const writer = this.writer;\n    const mesh = object;\n    const translationAttr = new Float32Array(mesh.count * 3);\n    const rotationAttr = new Float32Array(mesh.count * 4);\n    const scaleAttr = new Float32Array(mesh.count * 3);\n    const matrix = new Matrix4();\n    const position = new Vector3();\n    const quaternion = new Quaternion();\n    const scale = new Vector3();\n    for (let i = 0; i < mesh.count; i++) {\n      mesh.getMatrixAt(i, matrix);\n      matrix.decompose(position, quaternion, scale);\n      position.toArray(translationAttr, i * 3);\n      quaternion.toArray(rotationAttr, i * 4);\n      scale.toArray(scaleAttr, i * 3);\n    }\n    const attributes = {\n      TRANSLATION: writer.processAccessor(new BufferAttribute(translationAttr, 3)),\n      ROTATION: writer.processAccessor(new BufferAttribute(rotationAttr, 4)),\n      SCALE: writer.processAccessor(new BufferAttribute(scaleAttr, 3))\n    };\n    if (mesh.instanceColor) attributes._COLOR_0 = writer.processAccessor(mesh.instanceColor);\n    nodeDef.extensions = nodeDef.extensions || {};\n    nodeDef.extensions[this.name] = {\n      attributes\n    };\n    writer.extensionsUsed[this.name] = true;\n    writer.extensionsRequired[this.name] = true;\n  }\n}\n\n/**\n * Static utility functions\n *\n * @private\n */\nGLTFExporter.Utils = {\n  insertKeyframe: function (track, time) {\n    const tolerance = 0.001; // 1ms\n    const valueSize = track.getValueSize();\n    const times = new track.TimeBufferType(track.times.length + 1);\n    const values = new track.ValueBufferType(track.values.length + valueSize);\n    const interpolant = track.createInterpolant(new track.ValueBufferType(valueSize));\n    let index;\n    if (track.times.length === 0) {\n      times[0] = time;\n      for (let i = 0; i < valueSize; i++) {\n        values[i] = 0;\n      }\n      index = 0;\n    } else if (time < track.times[0]) {\n      if (Math.abs(track.times[0] - time) < tolerance) return 0;\n      times[0] = time;\n      times.set(track.times, 1);\n      values.set(interpolant.evaluate(time), 0);\n      values.set(track.values, valueSize);\n      index = 0;\n    } else if (time > track.times[track.times.length - 1]) {\n      if (Math.abs(track.times[track.times.length - 1] - time) < tolerance) {\n        return track.times.length - 1;\n      }\n      times[times.length - 1] = time;\n      times.set(track.times, 0);\n      values.set(track.values, 0);\n      values.set(interpolant.evaluate(time), track.values.length);\n      index = times.length - 1;\n    } else {\n      for (let i = 0; i < track.times.length; i++) {\n        if (Math.abs(track.times[i] - time) < tolerance) return i;\n        if (track.times[i] < time && track.times[i + 1] > time) {\n          times.set(track.times.slice(0, i + 1), 0);\n          times[i + 1] = time;\n          times.set(track.times.slice(i + 1), i + 2);\n          values.set(track.values.slice(0, (i + 1) * valueSize), 0);\n          values.set(interpolant.evaluate(time), (i + 1) * valueSize);\n          values.set(track.values.slice((i + 1) * valueSize), (i + 2) * valueSize);\n          index = i + 1;\n          break;\n        }\n      }\n    }\n    track.times = times;\n    track.values = values;\n    return index;\n  },\n  mergeMorphTargetTracks: function (clip, root) {\n    const tracks = [];\n    const mergedTracks = {};\n    const sourceTracks = clip.tracks;\n    for (let i = 0; i < sourceTracks.length; ++i) {\n      let sourceTrack = sourceTracks[i];\n      const sourceTrackBinding = PropertyBinding.parseTrackName(sourceTrack.name);\n      const sourceTrackNode = PropertyBinding.findNode(root, sourceTrackBinding.nodeName);\n      if (sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined) {\n        // Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n        tracks.push(sourceTrack);\n        continue;\n      }\n      if (sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete && sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear) {\n        if (sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n          // This should never happen, because glTF morph target animations\n          // affect all targets already.\n          throw new Error('THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.');\n        }\n        console.warn('THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.');\n        sourceTrack = sourceTrack.clone();\n        sourceTrack.setInterpolation(InterpolateLinear);\n      }\n      const targetCount = sourceTrackNode.morphTargetInfluences.length;\n      const targetIndex = sourceTrackNode.morphTargetDictionary[sourceTrackBinding.propertyIndex];\n      if (targetIndex === undefined) {\n        throw new Error('THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex);\n      }\n      let mergedTrack;\n\n      // If this is the first time we've seen this object, create a new\n      // track to store merged keyframe data for each morph target.\n      if (mergedTracks[sourceTrackNode.uuid] === undefined) {\n        mergedTrack = sourceTrack.clone();\n        const values = new mergedTrack.ValueBufferType(targetCount * mergedTrack.times.length);\n        for (let j = 0; j < mergedTrack.times.length; j++) {\n          values[j * targetCount + targetIndex] = mergedTrack.values[j];\n        }\n\n        // We need to take into consideration the intended target node\n        // of our original un-merged morphTarget animation.\n        mergedTrack.name = (sourceTrackBinding.nodeName || '') + '.morphTargetInfluences';\n        mergedTrack.values = values;\n        mergedTracks[sourceTrackNode.uuid] = mergedTrack;\n        tracks.push(mergedTrack);\n        continue;\n      }\n      const sourceInterpolant = sourceTrack.createInterpolant(new sourceTrack.ValueBufferType(1));\n      mergedTrack = mergedTracks[sourceTrackNode.uuid];\n\n      // For every existing keyframe of the merged track, write a (possibly\n      // interpolated) value from the source track.\n      for (let j = 0; j < mergedTrack.times.length; j++) {\n        mergedTrack.values[j * targetCount + targetIndex] = sourceInterpolant.evaluate(mergedTrack.times[j]);\n      }\n\n      // For every existing keyframe of the source track, write a (possibly\n      // new) keyframe to the merged track. Values from the previous loop may\n      // be written again, but keyframes are de-duplicated.\n      for (let j = 0; j < sourceTrack.times.length; j++) {\n        const keyframeIndex = this.insertKeyframe(mergedTrack, sourceTrack.times[j]);\n        mergedTrack.values[keyframeIndex * targetCount + targetIndex] = sourceTrack.values[j];\n      }\n    }\n    clip.tracks = tracks;\n    return clip;\n  },\n  toFloat32BufferAttribute: function (srcAttribute) {\n    const dstAttribute = new BufferAttribute(new Float32Array(srcAttribute.count * srcAttribute.itemSize), srcAttribute.itemSize, false);\n    if (!srcAttribute.normalized && !srcAttribute.isInterleavedBufferAttribute) {\n      dstAttribute.array.set(srcAttribute.array);\n      return dstAttribute;\n    }\n    for (let i = 0, il = srcAttribute.count; i < il; i++) {\n      for (let j = 0; j < srcAttribute.itemSize; j++) {\n        dstAttribute.setComponent(i, j, srcAttribute.getComponent(i, j));\n      }\n    }\n    return dstAttribute;\n  }\n};\n\n/**\n * Export options of `GLTFExporter`.\n *\n * @typedef {Object} GLTFExporter~Options\n * @property {boolean} [trs=false] - Export position, rotation and scale instead of matrix per node.\n * @property {boolean} [onlyVisible=true] - Export only visible 3D objects.\n * @property {boolean} [binary=false] - Export in binary (.glb) format, returning an ArrayBuffer.\n * @property {number} [maxTextureSize=Infinity] - Restricts the image maximum size (both width and height) to the given value.\n * @property {Array<AnimationClip>} [animations=[]] - List of animations to be included in the export.\n * @property {boolean} [includeCustomExtensions=false] - Export custom glTF extensions defined on an object's `userData.gltfExtensions` property.\n **/\n\n/**\n * onDone callback of `GLTFExporter`.\n *\n * @callback GLTFExporter~OnDone\n * @param {ArrayBuffer|string} result - The generated .gltf (JSON) or .glb (binary).\n */\n\n/**\n * onError callback of `GLTFExporter`.\n *\n * @callback GLTFExporter~OnError\n * @param {Error} error - The error object.\n */\n\nexport { GLTFExporter };","map":{"version":3,"names":["BufferAttribute","ClampToEdgeWrapping","Color","DoubleSide","InterpolateDiscrete","InterpolateLinear","NoColorSpace","LinearFilter","LinearMipmapLinearFilter","LinearMipmapNearestFilter","MathUtils","Matrix4","MirroredRepeatWrapping","NearestFilter","NearestMipmapLinearFilter","NearestMipmapNearestFilter","PropertyBinding","RGBAFormat","RepeatWrapping","Scene","Source","SRGBColorSpace","CompressedTexture","Vector3","Quaternion","REVISION","ImageUtils","KHR_mesh_quantization_ExtraAttrTypes","POSITION","NORMAL","TANGENT","TEXCOORD","GLTFExporter","constructor","textureUtils","pluginCallbacks","register","writer","GLTFLightExtension","GLTFMaterialsUnlitExtension","GLTFMaterialsTransmissionExtension","GLTFMaterialsVolumeExtension","GLTFMaterialsIorExtension","GLTFMaterialsSpecularExtension","GLTFMaterialsClearcoatExtension","GLTFMaterialsDispersionExtension","GLTFMaterialsIridescenceExtension","GLTFMaterialsSheenExtension","GLTFMaterialsAnisotropyExtension","GLTFMaterialsEmissiveStrengthExtension","GLTFMaterialsBumpExtension","GLTFMeshGpuInstancing","callback","indexOf","push","unregister","splice","setTextureUtils","utils","parse","input","onDone","onError","options","GLTFWriter","plugins","i","il","length","setPlugins","writeAsync","catch","parseAsync","scope","Promise","resolve","reject","WEBGL_CONSTANTS","POINTS","LINES","LINE_LOOP","LINE_STRIP","TRIANGLES","TRIANGLE_STRIP","TRIANGLE_FAN","BYTE","UNSIGNED_BYTE","SHORT","UNSIGNED_SHORT","INT","UNSIGNED_INT","FLOAT","ARRAY_BUFFER","ELEMENT_ARRAY_BUFFER","NEAREST","LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_LINEAR","CLAMP_TO_EDGE","MIRRORED_REPEAT","REPEAT","KHR_MESH_QUANTIZATION","THREE_TO_WEBGL","PATH_PROPERTIES","scale","position","quaternion","morphTargetInfluences","DEFAULT_SPECULAR_COLOR","GLB_HEADER_BYTES","GLB_HEADER_MAGIC","GLB_VERSION","GLB_CHUNK_PREFIX_BYTES","GLB_CHUNK_TYPE_JSON","GLB_CHUNK_TYPE_BIN","equalArray","array1","array2","every","element","index","stringToArrayBuffer","text","TextEncoder","encode","buffer","isIdentityMatrix","matrix","elements","getMinMax","attribute","start","count","output","min","Array","itemSize","fill","Number","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","a","value","array","getX","getY","getZ","getW","normalized","normalize","Math","getPaddedBufferSize","bufferSize","ceil","getPaddedArrayBuffer","arrayBuffer","paddingByte","paddedLength","byteLength","Uint8Array","set","getCanvas","document","OffscreenCanvas","createElement","getToBlobPromise","canvas","mimeType","quality","convertToBlob","type","toBlob","pending","buffers","byteOffset","nodeMap","Map","skins","extensionsUsed","extensionsRequired","uids","uid","json","asset","version","generator","cache","meshes","attributes","attributesNormalized","materials","textures","images","Object","assign","binary","trs","onlyVisible","maxTextureSize","Infinity","animations","includeCustomExtensions","processInputAsync","all","blob","Blob","extensionsUsedList","keys","extensionsRequiredList","size","reader","FileReader","readAsArrayBuffer","onloadend","binaryChunk","result","binaryChunkPrefix","DataView","ArrayBuffer","setUint32","jsonChunk","JSON","stringify","jsonChunkPrefix","header","headerView","totalByteLength","glbBlob","glbReader","readAsDataURL","base64data","uri","serializeUserData","object","objectDef","userData","gltfExtensions","extensions","undefined","extensionName","extras","error","console","warn","name","message","getUID","isRelativeCopy","has","get","isNormalizedNormalAttribute","normal","v","abs","fromBufferAttribute","createNormalizedNormalAttribute","clone","x","y","z","setX","setXYZ","applyTextureTransform","mapDef","texture","didTransform","transformDef","offset","toArray","rotation","repeat","buildMetalRoughTextureAsync","metalnessMap","roughnessMap","getEncodingConversion","map","colorSpace","SRGBToLinear","c","pow","LinearToLinear","decompressTextureAsync","metalness","image","roughness","width","height","context","getContext","willReadFrequently","fillStyle","fillRect","composite","getImageData","drawImage","convert","data","putImageData","reference","source","channel","Error","decompress","processBuffer","processBufferView","componentType","target","bufferViews","componentSize","byteStride","dataView","setFloat32","setInt32","setInt16","setUint16","setInt8","setUint8","bufferViewDef","id","processBufferViewImage","processAccessor","geometry","types","Float32Array","Int32Array","Uint32Array","Int16Array","Uint16Array","Int8Array","minMax","bufferViewTarget","bufferView","accessorDef","accessors","processImage","format","flipY","cachedImages","key","toString","imageDef","ctx","translate","Uint8ClampedArray","ImageData","HTMLImageElement","HTMLCanvasElement","ImageBitmap","then","bufferViewIndex","getDataURL","processSampler","samplers","samplerDef","magFilter","minFilter","wrapS","wrapT","processTextureAsync","textureDef","sampler","_invokeAllAsync","ext","writeTexture","processMaterialAsync","material","isShaderMaterial","materialDef","pbrMetallicRoughness","isMeshStandardMaterial","isMeshBasicMaterial","color","concat","opacity","baseColorFactor","metallicFactor","roughnessFactor","metalRoughTexture","metalRoughMapDef","texCoord","metallicRoughnessTexture","baseColorMapDef","baseColorTexture","emissive","maxEmissiveComponent","r","g","b","emissiveFactor","emissiveMap","emissiveMapDef","emissiveTexture","normalMap","normalMapDef","normalScale","normalTexture","aoMap","occlusionMapDef","aoMapIntensity","strength","occlusionTexture","transparent","alphaMode","alphaTest","alphaCutoff","side","doubleSided","writeMaterialAsync","processMeshAsync","mesh","meshCacheKeyParts","uuid","isArray","l","meshCacheKey","join","mode","isLineSegments","isLineLoop","isLine","isPoints","wireframe","meshDef","primitives","targets","nameConversion","uv","uv1","uv2","uv3","skinWeight","skinIndex","originalNormal","getAttribute","setAttribute","modifiedAttribute","attributeName","slice","toUpperCase","validVertexAttributes","test","startsWith","Utils","toFloat32BufferAttribute","accessor","detectMeshQuantization","weights","targetNames","reverseDictionary","morphTargetDictionary","warned","morphAttributes","gltfAttributeName","baseAttribute","relativeAttribute","morphTargetsRelative","j","jl","setY","setZ","setW","isMultiMaterial","groups","didForceIndices","indices","setIndex","materialIndex","primitive","cacheKey","writeMesh","attrType","attrNamePrefix","split","includes","processCamera","camera","cameras","isOrtho","isOrthographicCamera","cameraDef","orthographic","xmag","right","ymag","top","zfar","far","znear","near","perspective","aspectRatio","aspect","yfov","degToRad","fov","processAnimation","clip","root","mergeMorphTargetTracks","tracks","channels","track","trackBinding","parseTrackName","trackNode","findNode","nodeName","trackProperty","propertyName","objectName","isSkinnedMesh","skeleton","getBoneByName","objectIndex","inputItemSize","outputItemSize","values","times","interpolation","createInterpolant","isInterpolantFactoryMethodGLTFCubicSpline","getInterpolation","node","path","animationDef","processSkin","nodes","rootJoint","bones","joints","inverseBindMatrices","temporaryBoneInverse","copy","boneInverses","multiply","bindMatrix","skin","processNodeAsync","nodeDef","translation","matrixAutoUpdate","updateMatrix","String","isMesh","meshIndex","isCamera","nodeIndex","children","child","visible","childNodeIndex","writeNode","processSceneAsync","scene","scenes","sceneDef","processObjectsAsync","objects","beforeParse","objectsWithoutScene","afterParse","func","light","isLight","isDirectionalLight","isPointLight","isSpotLight","lightDef","intensity","distance","range","spot","innerConeAngle","penumbra","angle","outerConeAngle","decay","parent","lights","isMeshPhysicalMaterial","clearcoat","extensionDef","clearcoatFactor","clearcoatMap","clearcoatMapDef","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughness","clearcoatRoughnessMap","clearcoatRoughnessMapDef","clearcoatRoughnessTexture","clearcoatNormalMap","clearcoatNormalMapDef","clearcoatNormalScale","clearcoatNormalTexture","dispersion","iridescence","iridescenceFactor","iridescenceMap","iridescenceMapDef","iridescenceTexture","iridescenceIor","iridescenceIOR","iridescenceThicknessMinimum","iridescenceThicknessRange","iridescenceThicknessMaximum","iridescenceThicknessMap","iridescenceThicknessMapDef","iridescenceThicknessTexture","transmission","transmissionFactor","transmissionMap","transmissionMapDef","transmissionTexture","thicknessFactor","thickness","thicknessMap","thicknessMapDef","thicknessTexture","attenuationDistance","attenuationColor","ior","specularIntensity","specularColor","equals","specularIntensityMap","specularColorMap","specularIntensityMapDef","specularTexture","specularColorMapDef","specularColorTexture","specularFactor","specularColorFactor","sheen","sheenRoughnessMap","sheenRoughnessMapDef","sheenRoughnessTexture","sheenColorMap","sheenColorMapDef","sheenColorTexture","sheenRoughnessFactor","sheenRoughness","sheenColorFactor","sheenColor","anisotropy","anisotropyMap","anisotropyMapDef","anisotropyTexture","anisotropyStrength","anisotropyRotation","emissiveIntensity","emissiveStrength","bumpScale","bumpMap","bumpMapDef","bumpTexture","bumpFactor","isInstancedMesh","translationAttr","rotationAttr","scaleAttr","getMatrixAt","decompose","TRANSLATION","ROTATION","SCALE","instanceColor","_COLOR_0","insertKeyframe","time","tolerance","valueSize","getValueSize","TimeBufferType","ValueBufferType","interpolant","evaluate","mergedTracks","sourceTracks","sourceTrack","sourceTrackBinding","sourceTrackNode","propertyIndex","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","setInterpolation","targetCount","targetIndex","mergedTrack","sourceInterpolant","keyframeIndex","srcAttribute","dstAttribute","isInterleavedBufferAttribute","setComponent","getComponent"],"sources":["C:/Users/LENOVO/Music/OneDrive/Pictures/distribution-agency-project/frontend/node_modules/three/examples/jsm/exporters/GLTFExporter.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tClampToEdgeWrapping,\n\tColor,\n\tDoubleSide,\n\tInterpolateDiscrete,\n\tInterpolateLinear,\n\tNoColorSpace,\n\tLinearFilter,\n\tLinearMipmapLinearFilter,\n\tLinearMipmapNearestFilter,\n\tMathUtils,\n\tMatrix4,\n\tMirroredRepeatWrapping,\n\tNearestFilter,\n\tNearestMipmapLinearFilter,\n\tNearestMipmapNearestFilter,\n\tPropertyBinding,\n\tRGBAFormat,\n\tRepeatWrapping,\n\tScene,\n\tSource,\n\tSRGBColorSpace,\n\tCompressedTexture,\n\tVector3,\n\tQuaternion,\n\tREVISION,\n\tImageUtils\n} from 'three';\n\n/**\n * The KHR_mesh_quantization extension allows these extra attribute component types\n *\n * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md#extending-mesh-attributes\n */\nconst KHR_mesh_quantization_ExtraAttrTypes = {\n\tPOSITION: [\n\t\t'byte',\n\t\t'byte normalized',\n\t\t'unsigned byte',\n\t\t'unsigned byte normalized',\n\t\t'short',\n\t\t'short normalized',\n\t\t'unsigned short',\n\t\t'unsigned short normalized',\n\t],\n\tNORMAL: [\n\t\t'byte normalized',\n\t\t'short normalized',\n\t],\n\tTANGENT: [\n\t\t'byte normalized',\n\t\t'short normalized',\n\t],\n\tTEXCOORD: [\n\t\t'byte',\n\t\t'byte normalized',\n\t\t'unsigned byte',\n\t\t'short',\n\t\t'short normalized',\n\t\t'unsigned short',\n\t],\n};\n\n/**\n * An exporter for `glTF` 2.0.\n *\n * glTF (GL Transmission Format) is an [open format specification](https://github.com/KhronosGroup/glTF/tree/master/specification/2.0)\n * for efficient delivery and loading of 3D content. Assets may be provided either in JSON (.gltf)\n * or binary (.glb) format. External files store textures (.jpg, .png) and additional binary\n * data (.bin). A glTF asset may deliver one or more scenes, including meshes, materials,\n * textures, skins, skeletons, morph targets, animations, lights, and/or cameras.\n *\n * GLTFExporter supports the [glTF 2.0 extensions](https://github.com/KhronosGroup/glTF/tree/master/extensions/):\n *\n * - KHR_lights_punctual\n * - KHR_materials_clearcoat\n * - KHR_materials_dispersion\n * - KHR_materials_emissive_strength\n * - KHR_materials_ior\n * - KHR_materials_iridescence\n * - KHR_materials_specular\n * - KHR_materials_sheen\n * - KHR_materials_transmission\n * - KHR_materials_unlit\n * - KHR_materials_volume\n * - KHR_mesh_quantization\n * - KHR_texture_transform\n * - EXT_materials_bump\n * - EXT_mesh_gpu_instancing\n *\n * The following glTF 2.0 extension is supported by an external user plugin:\n *\n * - [KHR_materials_variants](https://github.com/takahirox/three-gltf-extensions)\n *\n * ```js\n * const exporter = new GLTFExporter();\n * const data = await exporter.parseAsync( scene, options );\n * ```\n *\n * @three_import import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';\n */\nclass GLTFExporter {\n\n\t/**\n\t * Constructs a new glTF exporter.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * A reference to a texture utils module.\n\t\t *\n\t\t * @type {?(WebGLTextureUtils|WebGPUTextureUtils)}\n\t\t * @default null\n\t\t */\n\t\tthis.textureUtils = null;\n\n\t\tthis.pluginCallbacks = [];\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFLightExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsUnlitExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsTransmissionExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsVolumeExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIorExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsSpecularExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsClearcoatExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsDispersionExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsIridescenceExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsSheenExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsAnisotropyExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsEmissiveStrengthExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMaterialsBumpExtension( writer );\n\n\t\t} );\n\n\t\tthis.register( function ( writer ) {\n\n\t\t\treturn new GLTFMeshGpuInstancing( writer );\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Registers a plugin callback. This API is internally used to implement the various\n\t * glTF extensions but can also used by third-party code to add additional logic\n\t * to the exporter.\n\t *\n\t * @param {function(writer:GLTFWriter)} callback - The callback function to register.\n\t * @return {GLTFExporter} A reference to this exporter.\n\t */\n\tregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) === - 1 ) {\n\n\t\t\tthis.pluginCallbacks.push( callback );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Unregisters a plugin callback.\n\t *\n\t * @param {Function} callback - The callback function to unregister.\n\t * @return {GLTFExporter} A reference to this exporter.\n\t */\n\tunregister( callback ) {\n\n\t\tif ( this.pluginCallbacks.indexOf( callback ) !== - 1 ) {\n\n\t\t\tthis.pluginCallbacks.splice( this.pluginCallbacks.indexOf( callback ), 1 );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the texture utils for this exporter. Only relevant when compressed textures have to be exported.\n\t *\n\t * Depending on whether you use {@link WebGLRenderer} or {@link WebGPURenderer}, you must inject the\n\t * corresponding texture utils {@link WebGLTextureUtils} or {@link WebGPUTextureUtils}.\n\t *\n\t * @param {WebGLTextureUtils|WebGPUTextureUtils} utils - The texture utils.\n\t * @return {GLTFExporter} A reference to this exporter.\n\t */\n\tsetTextureUtils( utils ) {\n\n\t\tthis.textureUtils = utils;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Parses the given scenes and generates the glTF output.\n\t *\n\t * @param {Scene|Array<Scene>} input - A scene or an array of scenes.\n\t * @param {GLTFExporter~OnDone} onDone - A callback function that is executed when the export has finished.\n\t * @param {GLTFExporter~OnError} onError - A callback function that is executed when an error happens.\n\t * @param {GLTFExporter~Options} options - options\n\t */\n\tparse( input, onDone, onError, options ) {\n\n\t\tconst writer = new GLTFWriter();\n\t\tconst plugins = [];\n\n\t\tfor ( let i = 0, il = this.pluginCallbacks.length; i < il; i ++ ) {\n\n\t\t\tplugins.push( this.pluginCallbacks[ i ]( writer ) );\n\n\t\t}\n\n\t\twriter.setPlugins( plugins );\n\t\twriter.setTextureUtils( this.textureUtils );\n\t\twriter.writeAsync( input, onDone, options ).catch( onError );\n\n\t}\n\n\t/**\n\t * Async version of {@link GLTFExporter#parse}.\n\t *\n\t * @param {Scene|Array<Scene>} input - A scene or an array of scenes.\n\t * @param {GLTFExporter~Options} options - options.\n\t * @return {Promise<ArrayBuffer|string>} A Promise that resolved with the exported glTF data.\n\t */\n\tparseAsync( input, options ) {\n\n\t\tconst scope = this;\n\n\t\treturn new Promise( function ( resolve, reject ) {\n\n\t\t\tscope.parse( input, resolve, reject, options );\n\n\t\t} );\n\n\t}\n\n}\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\nconst WEBGL_CONSTANTS = {\n\tPOINTS: 0x0000,\n\tLINES: 0x0001,\n\tLINE_LOOP: 0x0002,\n\tLINE_STRIP: 0x0003,\n\tTRIANGLES: 0x0004,\n\tTRIANGLE_STRIP: 0x0005,\n\tTRIANGLE_FAN: 0x0006,\n\n\tBYTE: 0x1400,\n\tUNSIGNED_BYTE: 0x1401,\n\tSHORT: 0x1402,\n\tUNSIGNED_SHORT: 0x1403,\n\tINT: 0x1404,\n\tUNSIGNED_INT: 0x1405,\n\tFLOAT: 0x1406,\n\n\tARRAY_BUFFER: 0x8892,\n\tELEMENT_ARRAY_BUFFER: 0x8893,\n\n\tNEAREST: 0x2600,\n\tLINEAR: 0x2601,\n\tNEAREST_MIPMAP_NEAREST: 0x2700,\n\tLINEAR_MIPMAP_NEAREST: 0x2701,\n\tNEAREST_MIPMAP_LINEAR: 0x2702,\n\tLINEAR_MIPMAP_LINEAR: 0x2703,\n\n\tCLAMP_TO_EDGE: 33071,\n\tMIRRORED_REPEAT: 33648,\n\tREPEAT: 10497\n};\n\nconst KHR_MESH_QUANTIZATION = 'KHR_mesh_quantization';\n\nconst THREE_TO_WEBGL = {};\n\nTHREE_TO_WEBGL[ NearestFilter ] = WEBGL_CONSTANTS.NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapNearestFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ NearestMipmapLinearFilter ] = WEBGL_CONSTANTS.NEAREST_MIPMAP_LINEAR;\nTHREE_TO_WEBGL[ LinearFilter ] = WEBGL_CONSTANTS.LINEAR;\nTHREE_TO_WEBGL[ LinearMipmapNearestFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_NEAREST;\nTHREE_TO_WEBGL[ LinearMipmapLinearFilter ] = WEBGL_CONSTANTS.LINEAR_MIPMAP_LINEAR;\n\nTHREE_TO_WEBGL[ ClampToEdgeWrapping ] = WEBGL_CONSTANTS.CLAMP_TO_EDGE;\nTHREE_TO_WEBGL[ RepeatWrapping ] = WEBGL_CONSTANTS.REPEAT;\nTHREE_TO_WEBGL[ MirroredRepeatWrapping ] = WEBGL_CONSTANTS.MIRRORED_REPEAT;\n\nconst PATH_PROPERTIES = {\n\tscale: 'scale',\n\tposition: 'translation',\n\tquaternion: 'rotation',\n\tmorphTargetInfluences: 'weights'\n};\n\nconst DEFAULT_SPECULAR_COLOR = new Color();\n\n// GLB constants\n// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\nconst GLB_HEADER_BYTES = 12;\nconst GLB_HEADER_MAGIC = 0x46546C67;\nconst GLB_VERSION = 2;\n\nconst GLB_CHUNK_PREFIX_BYTES = 8;\nconst GLB_CHUNK_TYPE_JSON = 0x4E4F534A;\nconst GLB_CHUNK_TYPE_BIN = 0x004E4942;\n\n//------------------------------------------------------------------------------\n// Utility functions\n//------------------------------------------------------------------------------\n\n/**\n * Compare two arrays\n *\n * @private\n * @param {Array} array1 Array 1 to compare\n * @param {Array} array2 Array 2 to compare\n * @return {boolean}        Returns true if both arrays are equal\n */\nfunction equalArray( array1, array2 ) {\n\n\treturn ( array1.length === array2.length ) && array1.every( function ( element, index ) {\n\n\t\treturn element === array2[ index ];\n\n\t} );\n\n}\n\n/**\n * Converts a string to an ArrayBuffer.\n *\n * @private\n * @param {string} text\n * @return {ArrayBuffer}\n */\nfunction stringToArrayBuffer( text ) {\n\n\treturn new TextEncoder().encode( text ).buffer;\n\n}\n\n/**\n * Is identity matrix\n *\n * @private\n * @param {Matrix4} matrix\n * @returns {boolean} Returns true, if parameter is identity matrix\n */\nfunction isIdentityMatrix( matrix ) {\n\n\treturn equalArray( matrix.elements, [ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ] );\n\n}\n\n/**\n * Get the min and max vectors from the given attribute\n *\n * @private\n * @param {BufferAttribute} attribute Attribute to find the min/max in range from start to start + count\n * @param {number} start Start index\n * @param {number} count Range to cover\n * @return {Object} Object containing the `min` and `max` values (As an array of attribute.itemSize components)\n */\nfunction getMinMax( attribute, start, count ) {\n\n\tconst output = {\n\n\t\tmin: new Array( attribute.itemSize ).fill( Number.POSITIVE_INFINITY ),\n\t\tmax: new Array( attribute.itemSize ).fill( Number.NEGATIVE_INFINITY )\n\n\t};\n\n\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\tlet value;\n\n\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t} else {\n\n\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\tif ( attribute.normalized === true ) {\n\n\t\t\t\t\tvalue = MathUtils.normalize( value, attribute.array );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\toutput.min[ a ] = Math.min( output.min[ a ], value );\n\t\t\toutput.max[ a ] = Math.max( output.max[ a ], value );\n\n\t\t}\n\n\t}\n\n\treturn output;\n\n}\n\n/**\n * Get the required size + padding for a buffer, rounded to the next 4-byte boundary.\n * https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#data-alignment\n *\n * @private\n * @param {number} bufferSize The size the original buffer. Should be an integer.\n * @returns {number} new buffer size with required padding as an integer.\n *\n */\nfunction getPaddedBufferSize( bufferSize ) {\n\n\treturn Math.ceil( bufferSize / 4 ) * 4;\n\n}\n\n/**\n * Returns a buffer aligned to 4-byte boundary.\n *\n * @private\n * @param {ArrayBuffer} arrayBuffer Buffer to pad\n * @param {number} [paddingByte=0] Should be an integer\n * @returns {ArrayBuffer} The same buffer if it's already aligned to 4-byte boundary or a new buffer\n */\nfunction getPaddedArrayBuffer( arrayBuffer, paddingByte = 0 ) {\n\n\tconst paddedLength = getPaddedBufferSize( arrayBuffer.byteLength );\n\n\tif ( paddedLength !== arrayBuffer.byteLength ) {\n\n\t\tconst array = new Uint8Array( paddedLength );\n\t\tarray.set( new Uint8Array( arrayBuffer ) );\n\n\t\tif ( paddingByte !== 0 ) {\n\n\t\t\tfor ( let i = arrayBuffer.byteLength; i < paddedLength; i ++ ) {\n\n\t\t\t\tarray[ i ] = paddingByte;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn array.buffer;\n\n\t}\n\n\treturn arrayBuffer;\n\n}\n\nfunction getCanvas() {\n\n\tif ( typeof document === 'undefined' && typeof OffscreenCanvas !== 'undefined' ) {\n\n\t\treturn new OffscreenCanvas( 1, 1 );\n\n\t}\n\n\treturn document.createElement( 'canvas' );\n\n}\n\nfunction getToBlobPromise( canvas, mimeType ) {\n\n\tif ( typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas ) {\n\n\t\tlet quality;\n\n\t\t// Blink's implementation of convertToBlob seems to default to a quality level of 100%\n\t\t// Use the Blink default quality levels of toBlob instead so that file sizes are comparable.\n\t\tif ( mimeType === 'image/jpeg' ) {\n\n\t\t\tquality = 0.92;\n\n\t\t} else if ( mimeType === 'image/webp' ) {\n\n\t\t\tquality = 0.8;\n\n\t\t}\n\n\t\treturn canvas.convertToBlob( {\n\n\t\t\ttype: mimeType,\n\t\t\tquality: quality\n\n\t\t} );\n\n\t} else {\n\n\t\t// HTMLCanvasElement code path\n\n\t\treturn new Promise( ( resolve ) => canvas.toBlob( resolve, mimeType ) );\n\n\t}\n\n}\n\n/**\n * Writer\n *\n * @private\n */\nclass GLTFWriter {\n\n\tconstructor() {\n\n\t\tthis.plugins = [];\n\n\t\tthis.options = {};\n\t\tthis.pending = [];\n\t\tthis.buffers = [];\n\n\t\tthis.byteOffset = 0;\n\t\tthis.buffers = [];\n\t\tthis.nodeMap = new Map();\n\t\tthis.skins = [];\n\n\t\tthis.extensionsUsed = {};\n\t\tthis.extensionsRequired = {};\n\n\t\tthis.uids = new Map();\n\t\tthis.uid = 0;\n\n\t\tthis.json = {\n\t\t\tasset: {\n\t\t\t\tversion: '2.0',\n\t\t\t\tgenerator: 'THREE.GLTFExporter r' + REVISION\n\t\t\t}\n\t\t};\n\n\t\tthis.cache = {\n\t\t\tmeshes: new Map(),\n\t\t\tattributes: new Map(),\n\t\t\tattributesNormalized: new Map(),\n\t\t\tmaterials: new Map(),\n\t\t\ttextures: new Map(),\n\t\t\timages: new Map()\n\t\t};\n\n\t\tthis.textureUtils = null;\n\n\t}\n\n\tsetPlugins( plugins ) {\n\n\t\tthis.plugins = plugins;\n\n\t}\n\n\tsetTextureUtils( utils ) {\n\n\t\tthis.textureUtils = utils;\n\n\t}\n\n\t/**\n\t * Parse scenes and generate GLTF output\n\t *\n\t * @param {Scene|Array<Scene>} input Scene or Array of THREE.Scenes\n\t * @param {Function} onDone Callback on completed\n\t * @param {Object} options options\n\t */\n\tasync writeAsync( input, onDone, options = {} ) {\n\n\t\tthis.options = Object.assign( {\n\t\t\t// default options\n\t\t\tbinary: false,\n\t\t\ttrs: false,\n\t\t\tonlyVisible: true,\n\t\t\tmaxTextureSize: Infinity,\n\t\t\tanimations: [],\n\t\t\tincludeCustomExtensions: false\n\t\t}, options );\n\n\t\tif ( this.options.animations.length > 0 ) {\n\n\t\t\t// Only TRS properties, and not matrices, may be targeted by animation.\n\t\t\tthis.options.trs = true;\n\n\t\t}\n\n\t\tawait this.processInputAsync( input );\n\n\t\tawait Promise.all( this.pending );\n\n\t\tconst writer = this;\n\t\tconst buffers = writer.buffers;\n\t\tconst json = writer.json;\n\t\toptions = writer.options;\n\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\t\tconst extensionsRequired = writer.extensionsRequired;\n\n\t\t// Merge buffers.\n\t\tconst blob = new Blob( buffers, { type: 'application/octet-stream' } );\n\n\t\t// Declare extensions.\n\t\tconst extensionsUsedList = Object.keys( extensionsUsed );\n\t\tconst extensionsRequiredList = Object.keys( extensionsRequired );\n\n\t\tif ( extensionsUsedList.length > 0 ) json.extensionsUsed = extensionsUsedList;\n\t\tif ( extensionsRequiredList.length > 0 ) json.extensionsRequired = extensionsRequiredList;\n\n\t\t// Update bytelength of the single buffer.\n\t\tif ( json.buffers && json.buffers.length > 0 ) json.buffers[ 0 ].byteLength = blob.size;\n\n\t\tif ( options.binary === true ) {\n\n\t\t\t// https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#glb-file-format-specification\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\t// Binary chunk.\n\t\t\t\tconst binaryChunk = getPaddedArrayBuffer( reader.result );\n\t\t\t\tconst binaryChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tbinaryChunkPrefix.setUint32( 0, binaryChunk.byteLength, true );\n\t\t\t\tbinaryChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_BIN, true );\n\n\t\t\t\t// JSON chunk.\n\t\t\t\tconst jsonChunk = getPaddedArrayBuffer( stringToArrayBuffer( JSON.stringify( json ) ), 0x20 );\n\t\t\t\tconst jsonChunkPrefix = new DataView( new ArrayBuffer( GLB_CHUNK_PREFIX_BYTES ) );\n\t\t\t\tjsonChunkPrefix.setUint32( 0, jsonChunk.byteLength, true );\n\t\t\t\tjsonChunkPrefix.setUint32( 4, GLB_CHUNK_TYPE_JSON, true );\n\n\t\t\t\t// GLB header.\n\t\t\t\tconst header = new ArrayBuffer( GLB_HEADER_BYTES );\n\t\t\t\tconst headerView = new DataView( header );\n\t\t\t\theaderView.setUint32( 0, GLB_HEADER_MAGIC, true );\n\t\t\t\theaderView.setUint32( 4, GLB_VERSION, true );\n\t\t\t\tconst totalByteLength = GLB_HEADER_BYTES\n\t\t\t\t\t+ jsonChunkPrefix.byteLength + jsonChunk.byteLength\n\t\t\t\t\t+ binaryChunkPrefix.byteLength + binaryChunk.byteLength;\n\t\t\t\theaderView.setUint32( 8, totalByteLength, true );\n\n\t\t\t\tconst glbBlob = new Blob( [\n\t\t\t\t\theader,\n\t\t\t\t\tjsonChunkPrefix,\n\t\t\t\t\tjsonChunk,\n\t\t\t\t\tbinaryChunkPrefix,\n\t\t\t\t\tbinaryChunk\n\t\t\t\t], { type: 'application/octet-stream' } );\n\n\t\t\t\tconst glbReader = new FileReader();\n\t\t\t\tglbReader.readAsArrayBuffer( glbBlob );\n\t\t\t\tglbReader.onloadend = function () {\n\n\t\t\t\t\tonDone( glbReader.result );\n\n\t\t\t\t};\n\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tif ( json.buffers && json.buffers.length > 0 ) {\n\n\t\t\t\tconst reader = new FileReader();\n\t\t\t\treader.readAsDataURL( blob );\n\t\t\t\treader.onloadend = function () {\n\n\t\t\t\t\tconst base64data = reader.result;\n\t\t\t\t\tjson.buffers[ 0 ].uri = base64data;\n\t\t\t\t\tonDone( json );\n\n\t\t\t\t};\n\n\t\t\t} else {\n\n\t\t\t\tonDone( json );\n\n\t\t\t}\n\n\t\t}\n\n\n\t}\n\n\t/**\n\t * Serializes a userData.\n\t *\n\t * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry|THREE.AnimationClip} object\n\t * @param {Object} objectDef\n\t */\n\tserializeUserData( object, objectDef ) {\n\n\t\tif ( Object.keys( object.userData ).length === 0 ) return;\n\n\t\tconst options = this.options;\n\t\tconst extensionsUsed = this.extensionsUsed;\n\n\t\ttry {\n\n\t\t\tconst json = JSON.parse( JSON.stringify( object.userData ) );\n\n\t\t\tif ( options.includeCustomExtensions && json.gltfExtensions ) {\n\n\t\t\t\tif ( objectDef.extensions === undefined ) objectDef.extensions = {};\n\n\t\t\t\tfor ( const extensionName in json.gltfExtensions ) {\n\n\t\t\t\t\tobjectDef.extensions[ extensionName ] = json.gltfExtensions[ extensionName ];\n\t\t\t\t\textensionsUsed[ extensionName ] = true;\n\n\t\t\t\t}\n\n\t\t\t\tdelete json.gltfExtensions;\n\n\t\t\t}\n\n\t\t\tif ( Object.keys( json ).length > 0 ) objectDef.extras = json;\n\n\t\t} catch ( error ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: userData of \\'' + object.name + '\\' ' +\n\t\t\t\t'won\\'t be serialized because of JSON.stringify error - ' + error.message );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Returns ids for buffer attributes.\n\t *\n\t * @param {Object} attribute\n\t * @param {boolean} [isRelativeCopy=false]\n\t * @return {number} An integer\n\t */\n\tgetUID( attribute, isRelativeCopy = false ) {\n\n\t\tif ( this.uids.has( attribute ) === false ) {\n\n\t\t\tconst uids = new Map();\n\n\t\t\tuids.set( true, this.uid ++ );\n\t\t\tuids.set( false, this.uid ++ );\n\n\t\t\tthis.uids.set( attribute, uids );\n\n\t\t}\n\n\t\tconst uids = this.uids.get( attribute );\n\n\t\treturn uids.get( isRelativeCopy );\n\n\t}\n\n\t/**\n\t * Checks if normal attribute values are normalized.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {boolean}\n\t */\n\tisNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) ) return false;\n\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = normal.count; i < il; i ++ ) {\n\n\t\t\t// 0.0005 is from glTF-validator\n\t\t\tif ( Math.abs( v.fromBufferAttribute( normal, i ).length() - 1.0 ) > 0.0005 ) return false;\n\n\t\t}\n\n\t\treturn true;\n\n\t}\n\n\t/**\n\t * Creates normalized normal buffer attribute.\n\t *\n\t * @param {BufferAttribute} normal\n\t * @returns {BufferAttribute}\n\t *\n\t */\n\tcreateNormalizedNormalAttribute( normal ) {\n\n\t\tconst cache = this.cache;\n\n\t\tif ( cache.attributesNormalized.has( normal ) )\treturn cache.attributesNormalized.get( normal );\n\n\t\tconst attribute = normal.clone();\n\t\tconst v = new Vector3();\n\n\t\tfor ( let i = 0, il = attribute.count; i < il; i ++ ) {\n\n\t\t\tv.fromBufferAttribute( attribute, i );\n\n\t\t\tif ( v.x === 0 && v.y === 0 && v.z === 0 ) {\n\n\t\t\t\t// if values can't be normalized set (1, 0, 0)\n\t\t\t\tv.setX( 1.0 );\n\n\t\t\t} else {\n\n\t\t\t\tv.normalize();\n\n\t\t\t}\n\n\t\t\tattribute.setXYZ( i, v.x, v.y, v.z );\n\n\t\t}\n\n\t\tcache.attributesNormalized.set( normal, attribute );\n\n\t\treturn attribute;\n\n\t}\n\n\t/**\n\t * Applies a texture transform, if present, to the map definition. Requires\n\t * the KHR_texture_transform extension.\n\t *\n\t * @param {Object} mapDef\n\t * @param {THREE.Texture} texture\n\t */\n\tapplyTextureTransform( mapDef, texture ) {\n\n\t\tlet didTransform = false;\n\t\tconst transformDef = {};\n\n\t\tif ( texture.offset.x !== 0 || texture.offset.y !== 0 ) {\n\n\t\t\ttransformDef.offset = texture.offset.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.rotation !== 0 ) {\n\n\t\t\ttransformDef.rotation = texture.rotation;\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( texture.repeat.x !== 1 || texture.repeat.y !== 1 ) {\n\n\t\t\ttransformDef.scale = texture.repeat.toArray();\n\t\t\tdidTransform = true;\n\n\t\t}\n\n\t\tif ( didTransform ) {\n\n\t\t\tmapDef.extensions = mapDef.extensions || {};\n\t\t\tmapDef.extensions[ 'KHR_texture_transform' ] = transformDef;\n\t\t\tthis.extensionsUsed[ 'KHR_texture_transform' ] = true;\n\n\t\t}\n\n\t}\n\n\tasync buildMetalRoughTextureAsync( metalnessMap, roughnessMap ) {\n\n\t\tif ( metalnessMap === roughnessMap ) return metalnessMap;\n\n\t\tfunction getEncodingConversion( map ) {\n\n\t\t\tif ( map.colorSpace === SRGBColorSpace ) {\n\n\t\t\t\treturn function SRGBToLinear( c ) {\n\n\t\t\t\t\treturn ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );\n\n\t\t\t\t};\n\n\t\t\t}\n\n\t\t\treturn function LinearToLinear( c ) {\n\n\t\t\t\treturn c;\n\n\t\t\t};\n\n\t\t}\n\n\t\tif ( metalnessMap instanceof CompressedTexture ) {\n\n\t\t\tmetalnessMap = await this.decompressTextureAsync( metalnessMap );\n\n\t\t}\n\n\t\tif ( roughnessMap instanceof CompressedTexture ) {\n\n\t\t\troughnessMap = await this.decompressTextureAsync( roughnessMap );\n\n\t\t}\n\n\t\tconst metalness = metalnessMap ? metalnessMap.image : null;\n\t\tconst roughness = roughnessMap ? roughnessMap.image : null;\n\n\t\tconst width = Math.max( metalness ? metalness.width : 0, roughness ? roughness.width : 0 );\n\t\tconst height = Math.max( metalness ? metalness.height : 0, roughness ? roughness.height : 0 );\n\n\t\tconst canvas = getCanvas();\n\t\tcanvas.width = width;\n\t\tcanvas.height = height;\n\n\t\tconst context = canvas.getContext( '2d', {\n\t\t\twillReadFrequently: true,\n\t\t} );\n\t\tcontext.fillStyle = '#00ffff';\n\t\tcontext.fillRect( 0, 0, width, height );\n\n\t\tconst composite = context.getImageData( 0, 0, width, height );\n\n\t\tif ( metalness ) {\n\n\t\t\tcontext.drawImage( metalness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( metalnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 2; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( roughness ) {\n\n\t\t\tcontext.drawImage( roughness, 0, 0, width, height );\n\n\t\t\tconst convert = getEncodingConversion( roughnessMap );\n\t\t\tconst data = context.getImageData( 0, 0, width, height ).data;\n\n\t\t\tfor ( let i = 1; i < data.length; i += 4 ) {\n\n\t\t\t\tcomposite.data[ i ] = convert( data[ i ] / 256 ) * 256;\n\n\t\t\t}\n\n\t\t}\n\n\t\tcontext.putImageData( composite, 0, 0 );\n\n\t\t//\n\n\t\tconst reference = metalnessMap || roughnessMap;\n\n\t\tconst texture = reference.clone();\n\n\t\ttexture.source = new Source( canvas );\n\t\ttexture.colorSpace = NoColorSpace;\n\t\ttexture.channel = ( metalnessMap || roughnessMap ).channel;\n\n\t\tif ( metalnessMap && roughnessMap && metalnessMap.channel !== roughnessMap.channel ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match.' );\n\n\t\t}\n\n\t\tconsole.warn( 'THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.' );\n\n\t\treturn texture;\n\n\t}\n\n\n\tasync decompressTextureAsync( texture, maxTextureSize = Infinity ) {\n\n\t\tif ( this.textureUtils === null ) {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: setTextureUtils() must be called to process compressed textures.' );\n\n\t\t}\n\n\t\treturn await this.textureUtils.decompress( texture, maxTextureSize );\n\n\t}\n\n\t/**\n\t * Process a buffer to append to the default one.\n\t * @param {ArrayBuffer} buffer\n\t * @return {0}\n\t */\n\tprocessBuffer( buffer ) {\n\n\t\tconst json = this.json;\n\t\tconst buffers = this.buffers;\n\n\t\tif ( ! json.buffers ) json.buffers = [ { byteLength: 0 } ];\n\n\t\t// All buffers are merged before export.\n\t\tbuffers.push( buffer );\n\n\t\treturn 0;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView\n\t * @param {BufferAttribute} attribute\n\t * @param {number} componentType\n\t * @param {number} start\n\t * @param {number} count\n\t * @param {number} [target] Target usage of the BufferView\n\t * @return {Object}\n\t */\n\tprocessBufferView( attribute, componentType, start, count, target ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\t// Create a new dataview and dump the attribute's array into it\n\n\t\tlet componentSize;\n\n\t\tswitch ( componentType ) {\n\n\t\t\tcase WEBGL_CONSTANTS.BYTE:\n\t\t\tcase WEBGL_CONSTANTS.UNSIGNED_BYTE:\n\n\t\t\t\tcomponentSize = 1;\n\n\t\t\t\tbreak;\n\n\t\t\tcase WEBGL_CONSTANTS.SHORT:\n\t\t\tcase WEBGL_CONSTANTS.UNSIGNED_SHORT:\n\n\t\t\t\tcomponentSize = 2;\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tcomponentSize = 4;\n\n\t\t}\n\n\t\tlet byteStride = attribute.itemSize * componentSize;\n\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t// Each element of a vertex attribute MUST be aligned to 4-byte boundaries\n\t\t\t// inside a bufferView\n\t\t\tbyteStride = Math.ceil( byteStride / 4 ) * 4;\n\n\t\t}\n\n\t\tconst byteLength = getPaddedBufferSize( count * byteStride );\n\t\tconst dataView = new DataView( new ArrayBuffer( byteLength ) );\n\t\tlet offset = 0;\n\n\t\tfor ( let i = start; i < start + count; i ++ ) {\n\n\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\tlet value;\n\n\t\t\t\tif ( attribute.itemSize > 4 ) {\n\n\t\t\t\t\t // no support for interleaved data for itemSize > 4\n\n\t\t\t\t\tvalue = attribute.array[ i * attribute.itemSize + a ];\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif ( a === 0 ) value = attribute.getX( i );\n\t\t\t\t\telse if ( a === 1 ) value = attribute.getY( i );\n\t\t\t\t\telse if ( a === 2 ) value = attribute.getZ( i );\n\t\t\t\t\telse if ( a === 3 ) value = attribute.getW( i );\n\n\t\t\t\t\tif ( attribute.normalized === true ) {\n\n\t\t\t\t\t\tvalue = MathUtils.normalize( value, attribute.array );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( componentType === WEBGL_CONSTANTS.FLOAT ) {\n\n\t\t\t\t\tdataView.setFloat32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.INT ) {\n\n\t\t\t\t\tdataView.setInt32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_INT ) {\n\n\t\t\t\t\tdataView.setUint32( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.SHORT ) {\n\n\t\t\t\t\tdataView.setInt16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_SHORT ) {\n\n\t\t\t\t\tdataView.setUint16( offset, value, true );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.BYTE ) {\n\n\t\t\t\t\tdataView.setInt8( offset, value );\n\n\t\t\t\t} else if ( componentType === WEBGL_CONSTANTS.UNSIGNED_BYTE ) {\n\n\t\t\t\t\tdataView.setUint8( offset, value );\n\n\t\t\t\t}\n\n\t\t\t\toffset += componentSize;\n\n\t\t\t}\n\n\t\t\tif ( ( offset % byteStride ) !== 0 ) {\n\n\t\t\t\toffset += byteStride - ( offset % byteStride );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bufferViewDef = {\n\n\t\t\tbuffer: this.processBuffer( dataView.buffer ),\n\t\t\tbyteOffset: this.byteOffset,\n\t\t\tbyteLength: byteLength\n\n\t\t};\n\n\t\tif ( target !== undefined ) bufferViewDef.target = target;\n\n\t\tif ( target === WEBGL_CONSTANTS.ARRAY_BUFFER ) {\n\n\t\t\t// Only define byteStride for vertex attributes.\n\t\t\tbufferViewDef.byteStride = byteStride;\n\n\t\t}\n\n\t\tthis.byteOffset += byteLength;\n\n\t\tjson.bufferViews.push( bufferViewDef );\n\n\t\t// @TODO Merge bufferViews where possible.\n\t\tconst output = {\n\n\t\t\tid: json.bufferViews.length - 1,\n\t\t\tbyteLength: 0\n\n\t\t};\n\n\t\treturn output;\n\n\t}\n\n\t/**\n\t * Process and generate a BufferView from an image Blob.\n\t * @param {Blob} blob\n\t * @return {Promise<number>} An integer\n\t */\n\tprocessBufferViewImage( blob ) {\n\n\t\tconst writer = this;\n\t\tconst json = writer.json;\n\n\t\tif ( ! json.bufferViews ) json.bufferViews = [];\n\n\t\treturn new Promise( function ( resolve ) {\n\n\t\t\tconst reader = new FileReader();\n\t\t\treader.readAsArrayBuffer( blob );\n\t\t\treader.onloadend = function () {\n\n\t\t\t\tconst buffer = getPaddedArrayBuffer( reader.result );\n\n\t\t\t\tconst bufferViewDef = {\n\t\t\t\t\tbuffer: writer.processBuffer( buffer ),\n\t\t\t\t\tbyteOffset: writer.byteOffset,\n\t\t\t\t\tbyteLength: buffer.byteLength\n\t\t\t\t};\n\n\t\t\t\twriter.byteOffset += buffer.byteLength;\n\t\t\t\tresolve( json.bufferViews.push( bufferViewDef ) - 1 );\n\n\t\t\t};\n\n\t\t} );\n\n\t}\n\n\t/**\n\t * Process attribute to generate an accessor\n\t * @param {BufferAttribute} attribute Attribute to process\n\t * @param {?BufferGeometry} [geometry] Geometry used for truncated draw range\n\t * @param {number} [start=0]\n\t * @param {number} [count=Infinity]\n\t * @return {?number} Index of the processed accessor on the \"accessors\" array\n\t */\n\tprocessAccessor( attribute, geometry, start, count ) {\n\n\t\tconst json = this.json;\n\n\t\tconst types = {\n\n\t\t\t1: 'SCALAR',\n\t\t\t2: 'VEC2',\n\t\t\t3: 'VEC3',\n\t\t\t4: 'VEC4',\n\t\t\t9: 'MAT3',\n\t\t\t16: 'MAT4'\n\n\t\t};\n\n\t\tlet componentType;\n\n\t\t// Detect the component type of the attribute array\n\t\tif ( attribute.array.constructor === Float32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.FLOAT;\n\n\t\t} else if ( attribute.array.constructor === Int32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.INT;\n\n\t\t} else if ( attribute.array.constructor === Uint32Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_INT;\n\n\t\t} else if ( attribute.array.constructor === Int16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.SHORT;\n\n\t\t} else if ( attribute.array.constructor === Uint16Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_SHORT;\n\n\t\t} else if ( attribute.array.constructor === Int8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.BYTE;\n\n\t\t} else if ( attribute.array.constructor === Uint8Array ) {\n\n\t\t\tcomponentType = WEBGL_CONSTANTS.UNSIGNED_BYTE;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: Unsupported bufferAttribute component type: ' + attribute.array.constructor.name );\n\n\t\t}\n\n\t\tif ( start === undefined ) start = 0;\n\t\tif ( count === undefined || count === Infinity ) count = attribute.count;\n\n\t\t// Skip creating an accessor if the attribute doesn't have data to export\n\t\tif ( count === 0 ) return null;\n\n\t\tconst minMax = getMinMax( attribute, start, count );\n\t\tlet bufferViewTarget;\n\n\t\t// If geometry isn't provided, don't infer the target usage of the bufferView. For\n\t\t// animation samplers, target must not be set.\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tbufferViewTarget = attribute === geometry.index ? WEBGL_CONSTANTS.ELEMENT_ARRAY_BUFFER : WEBGL_CONSTANTS.ARRAY_BUFFER;\n\n\t\t}\n\n\t\tconst bufferView = this.processBufferView( attribute, componentType, start, count, bufferViewTarget );\n\n\t\tconst accessorDef = {\n\n\t\t\tbufferView: bufferView.id,\n\t\t\tbyteOffset: bufferView.byteOffset,\n\t\t\tcomponentType: componentType,\n\t\t\tcount: count,\n\t\t\tmax: minMax.max,\n\t\t\tmin: minMax.min,\n\t\t\ttype: types[ attribute.itemSize ]\n\n\t\t};\n\n\t\tif ( attribute.normalized === true ) accessorDef.normalized = true;\n\t\tif ( ! json.accessors ) json.accessors = [];\n\n\t\treturn json.accessors.push( accessorDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process image\n\t * @param {Image} image to process\n\t * @param {number} format Identifier of the format (RGBAFormat)\n\t * @param {boolean} flipY before writing out the image\n\t * @param {string} mimeType export format\n\t * @return {number}     Index of the processed texture in the \"images\" array\n\t */\n\tprocessImage( image, format, flipY, mimeType = 'image/png' ) {\n\n\t\tif ( image !== null ) {\n\n\t\t\tconst writer = this;\n\t\t\tconst cache = writer.cache;\n\t\t\tconst json = writer.json;\n\t\t\tconst options = writer.options;\n\t\t\tconst pending = writer.pending;\n\n\t\t\tif ( ! cache.images.has( image ) ) cache.images.set( image, {} );\n\n\t\t\tconst cachedImages = cache.images.get( image );\n\n\t\t\tconst key = mimeType + ':flipY/' + flipY.toString();\n\n\t\t\tif ( cachedImages[ key ] !== undefined ) return cachedImages[ key ];\n\n\t\t\tif ( ! json.images ) json.images = [];\n\n\t\t\tconst imageDef = { mimeType: mimeType };\n\n\t\t\tconst canvas = getCanvas();\n\n\t\t\tcanvas.width = Math.min( image.width, options.maxTextureSize );\n\t\t\tcanvas.height = Math.min( image.height, options.maxTextureSize );\n\n\t\t\tconst ctx = canvas.getContext( '2d', {\n\t\t\t\twillReadFrequently: true,\n\t\t\t} );\n\n\t\t\tif ( flipY === true ) {\n\n\t\t\t\tctx.translate( 0, canvas.height );\n\t\t\t\tctx.scale( 1, - 1 );\n\n\t\t\t}\n\n\t\t\tif ( image.data !== undefined ) { // THREE.DataTexture\n\n\t\t\t\tif ( format !== RGBAFormat ) {\n\n\t\t\t\t\tconsole.error( 'GLTFExporter: Only RGBAFormat is supported.', format );\n\n\t\t\t\t}\n\n\t\t\t\tif ( image.width > options.maxTextureSize || image.height > options.maxTextureSize ) {\n\n\t\t\t\t\tconsole.warn( 'GLTFExporter: Image size is bigger than maxTextureSize', image );\n\n\t\t\t\t}\n\n\t\t\t\tconst data = new Uint8ClampedArray( image.height * image.width * 4 );\n\n\t\t\t\tfor ( let i = 0; i < data.length; i += 4 ) {\n\n\t\t\t\t\tdata[ i + 0 ] = image.data[ i + 0 ];\n\t\t\t\t\tdata[ i + 1 ] = image.data[ i + 1 ];\n\t\t\t\t\tdata[ i + 2 ] = image.data[ i + 2 ];\n\t\t\t\t\tdata[ i + 3 ] = image.data[ i + 3 ];\n\n\t\t\t\t}\n\n\t\t\t\tctx.putImageData( new ImageData( data, image.width, image.height ), 0, 0 );\n\n\t\t\t} else {\n\n\t\t\t\tif ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||\n\t\t\t\t\t( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||\n\t\t\t\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ||\n\t\t\t\t\t( typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas ) ) {\n\n\t\t\t\t\tctx.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( options.binary === true ) {\n\n\t\t\t\tpending.push(\n\n\t\t\t\t\tgetToBlobPromise( canvas, mimeType )\n\t\t\t\t\t\t.then( blob => writer.processBufferViewImage( blob ) )\n\t\t\t\t\t\t.then( bufferViewIndex => {\n\n\t\t\t\t\t\t\timageDef.bufferView = bufferViewIndex;\n\n\t\t\t\t\t\t} )\n\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\timageDef.uri = ImageUtils.getDataURL( canvas, mimeType );\n\n\t\t\t}\n\n\t\t\tconst index = json.images.push( imageDef ) - 1;\n\t\t\tcachedImages[ key ] = index;\n\t\t\treturn index;\n\n\t\t} else {\n\n\t\t\tthrow new Error( 'THREE.GLTFExporter: No valid image data found. Unable to process texture.' );\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Process sampler\n\t * @param {Texture} map Texture to process\n\t * @return {number}      Index of the processed texture in the \"samplers\" array\n\t */\n\tprocessSampler( map ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.samplers ) json.samplers = [];\n\n\t\tconst samplerDef = {\n\t\t\tmagFilter: THREE_TO_WEBGL[ map.magFilter ],\n\t\t\tminFilter: THREE_TO_WEBGL[ map.minFilter ],\n\t\t\twrapS: THREE_TO_WEBGL[ map.wrapS ],\n\t\t\twrapT: THREE_TO_WEBGL[ map.wrapT ]\n\t\t};\n\n\t\treturn json.samplers.push( samplerDef ) - 1;\n\n\t}\n\n\t/**\n\t * Process texture\n\t * @param {Texture} map Map to process\n\t * @return {Promise<number>} Index of the processed texture in the \"textures\" array\n\t */\n\tasync processTextureAsync( map ) {\n\n\t\tconst writer = this;\n\t\tconst options = writer.options;\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.textures.has( map ) ) return cache.textures.get( map );\n\n\t\tif ( ! json.textures ) json.textures = [];\n\n\t\t// make non-readable textures (e.g. CompressedTexture) readable by blitting them into a new texture\n\t\tif ( map instanceof CompressedTexture ) {\n\n\t\t\tmap = await this.decompressTextureAsync( map, options.maxTextureSize );\n\n\t\t}\n\n\t\tlet mimeType = map.userData.mimeType;\n\n\t\tif ( mimeType === 'image/webp' ) mimeType = 'image/png';\n\n\t\tconst textureDef = {\n\t\t\tsampler: this.processSampler( map ),\n\t\t\tsource: this.processImage( map.image, map.format, map.flipY, mimeType )\n\t\t};\n\n\t\tif ( map.name ) textureDef.name = map.name;\n\n\t\tawait this._invokeAllAsync( async function ( ext ) {\n\n\t\t\text.writeTexture && await ext.writeTexture( map, textureDef );\n\n\t\t} );\n\n\t\tconst index = json.textures.push( textureDef ) - 1;\n\t\tcache.textures.set( map, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process material\n\t * @param {THREE.Material} material Material to process\n\t * @return {Promise<?number>} Index of the processed material in the \"materials\" array\n\t */\n\tasync processMaterialAsync( material ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tif ( cache.materials.has( material ) ) return cache.materials.get( material );\n\n\t\tif ( material.isShaderMaterial ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: THREE.ShaderMaterial not supported.' );\n\t\t\treturn null;\n\n\t\t}\n\n\t\tif ( ! json.materials ) json.materials = [];\n\n\t\t// @QUESTION Should we avoid including any attribute that has the default value?\n\t\tconst materialDef = {\tpbrMetallicRoughness: {} };\n\n\t\tif ( material.isMeshStandardMaterial !== true && material.isMeshBasicMaterial !== true ) {\n\n\t\t\tconsole.warn( 'GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.' );\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorFactor\n\t\tconst color = material.color.toArray().concat( [ material.opacity ] );\n\n\t\tif ( ! equalArray( color, [ 1, 1, 1, 1 ] ) ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorFactor = color;\n\n\t\t}\n\n\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = material.metalness;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = material.roughness;\n\n\t\t} else {\n\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0;\n\t\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 1;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.metallicRoughnessTexture\n\t\tif ( material.metalnessMap || material.roughnessMap ) {\n\n\t\t\tconst metalRoughTexture = await this.buildMetalRoughTextureAsync( material.metalnessMap, material.roughnessMap );\n\n\t\t\tconst metalRoughMapDef = {\n\t\t\t\tindex: await this.processTextureAsync( metalRoughTexture ),\n\t\t\t\ttexCoord: metalRoughTexture.channel\n\t\t\t};\n\t\t\tthis.applyTextureTransform( metalRoughMapDef, metalRoughTexture );\n\t\t\tmaterialDef.pbrMetallicRoughness.metallicRoughnessTexture = metalRoughMapDef;\n\n\t\t}\n\n\t\t// pbrMetallicRoughness.baseColorTexture\n\t\tif ( material.map ) {\n\n\t\t\tconst baseColorMapDef = {\n\t\t\t\tindex: await this.processTextureAsync( material.map ),\n\t\t\t\ttexCoord: material.map.channel\n\t\t\t};\n\t\t\tthis.applyTextureTransform( baseColorMapDef, material.map );\n\t\t\tmaterialDef.pbrMetallicRoughness.baseColorTexture = baseColorMapDef;\n\n\t\t}\n\n\t\tif ( material.emissive ) {\n\n\t\t\tconst emissive = material.emissive;\n\t\t\tconst maxEmissiveComponent = Math.max( emissive.r, emissive.g, emissive.b );\n\n\t\t\tif ( maxEmissiveComponent > 0 ) {\n\n\t\t\t\tmaterialDef.emissiveFactor = material.emissive.toArray();\n\n\t\t\t}\n\n\t\t\t// emissiveTexture\n\t\t\tif ( material.emissiveMap ) {\n\n\t\t\t\tconst emissiveMapDef = {\n\t\t\t\t\tindex: await this.processTextureAsync( material.emissiveMap ),\n\t\t\t\t\ttexCoord: material.emissiveMap.channel\n\t\t\t\t};\n\t\t\t\tthis.applyTextureTransform( emissiveMapDef, material.emissiveMap );\n\t\t\t\tmaterialDef.emissiveTexture = emissiveMapDef;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// normalTexture\n\t\tif ( material.normalMap ) {\n\n\t\t\tconst normalMapDef = {\n\t\t\t\tindex: await this.processTextureAsync( material.normalMap ),\n\t\t\t\ttexCoord: material.normalMap.channel\n\t\t\t};\n\n\t\t\tif ( material.normalScale && material.normalScale.x !== 1 ) {\n\n\t\t\t\t// glTF normal scale is univariate. Ignore `y`, which may be flipped.\n\t\t\t\t// Context: https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995\n\t\t\t\tnormalMapDef.scale = material.normalScale.x;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( normalMapDef, material.normalMap );\n\t\t\tmaterialDef.normalTexture = normalMapDef;\n\n\t\t}\n\n\t\t// occlusionTexture\n\t\tif ( material.aoMap ) {\n\n\t\t\tconst occlusionMapDef = {\n\t\t\t\tindex: await this.processTextureAsync( material.aoMap ),\n\t\t\t\ttexCoord: material.aoMap.channel\n\t\t\t};\n\n\t\t\tif ( material.aoMapIntensity !== 1.0 ) {\n\n\t\t\t\tocclusionMapDef.strength = material.aoMapIntensity;\n\n\t\t\t}\n\n\t\t\tthis.applyTextureTransform( occlusionMapDef, material.aoMap );\n\t\t\tmaterialDef.occlusionTexture = occlusionMapDef;\n\n\t\t}\n\n\t\t// alphaMode\n\t\tif ( material.transparent ) {\n\n\t\t\tmaterialDef.alphaMode = 'BLEND';\n\n\t\t} else {\n\n\t\t\tif ( material.alphaTest > 0.0 ) {\n\n\t\t\t\tmaterialDef.alphaMode = 'MASK';\n\t\t\t\tmaterialDef.alphaCutoff = material.alphaTest;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// doubleSided\n\t\tif ( material.side === DoubleSide ) materialDef.doubleSided = true;\n\t\tif ( material.name !== '' ) materialDef.name = material.name;\n\n\t\tthis.serializeUserData( material, materialDef );\n\n\t\tawait this._invokeAllAsync( async function ( ext ) {\n\n\t\t\text.writeMaterialAsync && await ext.writeMaterialAsync( material, materialDef );\n\n\t\t} );\n\n\t\tconst index = json.materials.push( materialDef ) - 1;\n\t\tcache.materials.set( material, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * Process mesh\n\t * @param {THREE.Mesh} mesh Mesh to process\n\t * @return {Promise<?number>} Index of the processed mesh in the \"meshes\" array\n\t */\n\tasync processMeshAsync( mesh ) {\n\n\t\tconst cache = this.cache;\n\t\tconst json = this.json;\n\n\t\tconst meshCacheKeyParts = [ mesh.geometry.uuid ];\n\n\t\tif ( Array.isArray( mesh.material ) ) {\n\n\t\t\tfor ( let i = 0, l = mesh.material.length; i < l; i ++ ) {\n\n\t\t\t\tmeshCacheKeyParts.push( mesh.material[ i ].uuid\t);\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tmeshCacheKeyParts.push( mesh.material.uuid );\n\n\t\t}\n\n\t\tconst meshCacheKey = meshCacheKeyParts.join( ':' );\n\n\t\tif ( cache.meshes.has( meshCacheKey ) ) return cache.meshes.get( meshCacheKey );\n\n\t\tconst geometry = mesh.geometry;\n\n\t\tlet mode;\n\n\t\t// Use the correct mode\n\t\tif ( mesh.isLineSegments ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINES;\n\n\t\t} else if ( mesh.isLineLoop ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_LOOP;\n\n\t\t} else if ( mesh.isLine ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.LINE_STRIP;\n\n\t\t} else if ( mesh.isPoints ) {\n\n\t\t\tmode = WEBGL_CONSTANTS.POINTS;\n\n\t\t} else {\n\n\t\t\tmode = mesh.material.wireframe ? WEBGL_CONSTANTS.LINES : WEBGL_CONSTANTS.TRIANGLES;\n\n\t\t}\n\n\t\tconst meshDef = {};\n\t\tconst attributes = {};\n\t\tconst primitives = [];\n\t\tconst targets = [];\n\n\t\t// Conversion between attributes names in threejs and gltf spec\n\t\tconst nameConversion = {\n\t\t\tuv: 'TEXCOORD_0',\n\t\t\tuv1: 'TEXCOORD_1',\n\t\t\tuv2: 'TEXCOORD_2',\n\t\t\tuv3: 'TEXCOORD_3',\n\t\t\tcolor: 'COLOR_0',\n\t\t\tskinWeight: 'WEIGHTS_0',\n\t\t\tskinIndex: 'JOINTS_0'\n\t\t};\n\n\t\tconst originalNormal = geometry.getAttribute( 'normal' );\n\n\t\tif ( originalNormal !== undefined && ! this.isNormalizedNormalAttribute( originalNormal ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one.' );\n\n\t\t\tgeometry.setAttribute( 'normal', this.createNormalizedNormalAttribute( originalNormal ) );\n\n\t\t}\n\n\t\t// @QUESTION Detect if .vertexColors = true?\n\t\t// For every attribute create an accessor\n\t\tlet modifiedAttribute = null;\n\n\t\tfor ( let attributeName in geometry.attributes ) {\n\n\t\t\t// Ignore morph target attributes, which are exported later.\n\t\t\tif ( attributeName.slice( 0, 5 ) === 'morph' ) continue;\n\n\t\t\tconst attribute = geometry.attributes[ attributeName ];\n\t\t\tattributeName = nameConversion[ attributeName ] || attributeName.toUpperCase();\n\n\t\t\t// Prefix all geometry attributes except the ones specifically\n\t\t\t// listed in the spec; non-spec attributes are considered custom.\n\t\t\tconst validVertexAttributes =\n\t\t\t\t\t/^(POSITION|NORMAL|TANGENT|TEXCOORD_\\d+|COLOR_\\d+|JOINTS_\\d+|WEIGHTS_\\d+)$/;\n\n\t\t\tif ( ! validVertexAttributes.test( attributeName ) ) attributeName = '_' + attributeName;\n\n\t\t\tif ( cache.attributes.has( this.getUID( attribute ) ) ) {\n\n\t\t\t\tattributes[ attributeName ] = cache.attributes.get( this.getUID( attribute ) );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\t// Enforce glTF vertex attribute requirements:\n\t\t\t// - JOINTS_0 must be UNSIGNED_BYTE or UNSIGNED_SHORT\n\t\t\t// - Only custom attributes may be INT or UNSIGNED_INT\n\t\t\tmodifiedAttribute = null;\n\t\t\tconst array = attribute.array;\n\n\t\t\tif ( attributeName === 'JOINTS_0' &&\n\t\t\t\t! ( array instanceof Uint16Array ) &&\n\t\t\t\t! ( array instanceof Uint8Array ) ) {\n\n\t\t\t\tconsole.warn( 'GLTFExporter: Attribute \"skinIndex\" converted to type UNSIGNED_SHORT.' );\n\t\t\t\tmodifiedAttribute = new BufferAttribute( new Uint16Array( array ), attribute.itemSize, attribute.normalized );\n\n\t\t\t} else if ( ( array instanceof Uint32Array || array instanceof Int32Array ) && ! attributeName.startsWith( '_' ) ) {\n\n\t\t\t\tconsole.warn( `GLTFExporter: Attribute \"${ attributeName }\" converted to type FLOAT.` );\n\t\t\t\tmodifiedAttribute = GLTFExporter.Utils.toFloat32BufferAttribute( attribute );\n\n\t\t\t}\n\n\t\t\tconst accessor = this.processAccessor( modifiedAttribute || attribute, geometry );\n\n\t\t\tif ( accessor !== null ) {\n\n\t\t\t\tif ( ! attributeName.startsWith( '_' ) ) {\n\n\t\t\t\t\tthis.detectMeshQuantization( attributeName, attribute );\n\n\t\t\t\t}\n\n\t\t\t\tattributes[ attributeName ] = accessor;\n\t\t\t\tcache.attributes.set( this.getUID( attribute ), accessor );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( originalNormal !== undefined ) geometry.setAttribute( 'normal', originalNormal );\n\n\t\t// Skip if no exportable attributes found\n\t\tif ( Object.keys( attributes ).length === 0 ) return null;\n\n\t\t// Morph targets\n\t\tif ( mesh.morphTargetInfluences !== undefined && mesh.morphTargetInfluences.length > 0 ) {\n\n\t\t\tconst weights = [];\n\t\t\tconst targetNames = [];\n\t\t\tconst reverseDictionary = {};\n\n\t\t\tif ( mesh.morphTargetDictionary !== undefined ) {\n\n\t\t\t\tfor ( const key in mesh.morphTargetDictionary ) {\n\n\t\t\t\t\treverseDictionary[ mesh.morphTargetDictionary[ key ] ] = key;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < mesh.morphTargetInfluences.length; ++ i ) {\n\n\t\t\t\tconst target = {};\n\t\t\t\tlet warned = false;\n\n\t\t\t\tfor ( const attributeName in geometry.morphAttributes ) {\n\n\t\t\t\t\t// glTF 2.0 morph supports only POSITION/NORMAL/TANGENT.\n\t\t\t\t\t// Three.js doesn't support TANGENT yet.\n\n\t\t\t\t\tif ( attributeName !== 'position' && attributeName !== 'normal' ) {\n\n\t\t\t\t\t\tif ( ! warned ) {\n\n\t\t\t\t\t\t\tconsole.warn( 'GLTFExporter: Only POSITION and NORMAL morph are supported.' );\n\t\t\t\t\t\t\twarned = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tconst attribute = geometry.morphAttributes[ attributeName ][ i ];\n\t\t\t\t\tconst gltfAttributeName = attributeName.toUpperCase();\n\n\t\t\t\t\t// Three.js morph attribute has absolute values while the one of glTF has relative values.\n\t\t\t\t\t//\n\t\t\t\t\t// glTF 2.0 Specification:\n\t\t\t\t\t// https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#morph-targets\n\n\t\t\t\t\tconst baseAttribute = geometry.attributes[ attributeName ];\n\n\t\t\t\t\tif ( cache.attributes.has( this.getUID( attribute, true ) ) ) {\n\n\t\t\t\t\t\ttarget[ gltfAttributeName ] = cache.attributes.get( this.getUID( attribute, true ) );\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// Clones attribute not to override\n\t\t\t\t\tconst relativeAttribute = attribute.clone();\n\n\t\t\t\t\tif ( ! geometry.morphTargetsRelative ) {\n\n\t\t\t\t\t\tfor ( let j = 0, jl = attribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tfor ( let a = 0; a < attribute.itemSize; a ++ ) {\n\n\t\t\t\t\t\t\t\tif ( a === 0 ) relativeAttribute.setX( j, attribute.getX( j ) - baseAttribute.getX( j ) );\n\t\t\t\t\t\t\t\tif ( a === 1 ) relativeAttribute.setY( j, attribute.getY( j ) - baseAttribute.getY( j ) );\n\t\t\t\t\t\t\t\tif ( a === 2 ) relativeAttribute.setZ( j, attribute.getZ( j ) - baseAttribute.getZ( j ) );\n\t\t\t\t\t\t\t\tif ( a === 3 ) relativeAttribute.setW( j, attribute.getW( j ) - baseAttribute.getW( j ) );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttarget[ gltfAttributeName ] = this.processAccessor( relativeAttribute, geometry );\n\t\t\t\t\tcache.attributes.set( this.getUID( baseAttribute, true ), target[ gltfAttributeName ] );\n\n\t\t\t\t}\n\n\t\t\t\ttargets.push( target );\n\n\t\t\t\tweights.push( mesh.morphTargetInfluences[ i ] );\n\n\t\t\t\tif ( mesh.morphTargetDictionary !== undefined ) targetNames.push( reverseDictionary[ i ] );\n\n\t\t\t}\n\n\t\t\tmeshDef.weights = weights;\n\n\t\t\tif ( targetNames.length > 0 ) {\n\n\t\t\t\tmeshDef.extras = {};\n\t\t\t\tmeshDef.extras.targetNames = targetNames;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst isMultiMaterial = Array.isArray( mesh.material );\n\n\t\tif ( isMultiMaterial && geometry.groups.length === 0 ) return null;\n\n\t\tlet didForceIndices = false;\n\n\t\tif ( isMultiMaterial && geometry.index === null ) {\n\n\t\t\tconst indices = [];\n\n\t\t\tfor ( let i = 0, il = geometry.attributes.position.count; i < il; i ++ ) {\n\n\t\t\t\tindices[ i ] = i;\n\n\t\t\t}\n\n\t\t\tgeometry.setIndex( indices );\n\n\t\t\tdidForceIndices = true;\n\n\t\t}\n\n\t\tconst materials = isMultiMaterial ? mesh.material : [ mesh.material ];\n\t\tconst groups = isMultiMaterial ? geometry.groups : [ { materialIndex: 0, start: undefined, count: undefined } ];\n\n\t\tfor ( let i = 0, il = groups.length; i < il; i ++ ) {\n\n\t\t\tconst primitive = {\n\t\t\t\tmode: mode,\n\t\t\t\tattributes: attributes,\n\t\t\t};\n\n\t\t\tthis.serializeUserData( geometry, primitive );\n\n\t\t\tif ( targets.length > 0 ) primitive.targets = targets;\n\n\t\t\tif ( geometry.index !== null ) {\n\n\t\t\t\tlet cacheKey = this.getUID( geometry.index );\n\n\t\t\t\tif ( groups[ i ].start !== undefined || groups[ i ].count !== undefined ) {\n\n\t\t\t\t\tcacheKey += ':' + groups[ i ].start + ':' + groups[ i ].count;\n\n\t\t\t\t}\n\n\t\t\t\tif ( cache.attributes.has( cacheKey ) ) {\n\n\t\t\t\t\tprimitive.indices = cache.attributes.get( cacheKey );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tprimitive.indices = this.processAccessor( geometry.index, geometry, groups[ i ].start, groups[ i ].count );\n\t\t\t\t\tcache.attributes.set( cacheKey, primitive.indices );\n\n\t\t\t\t}\n\n\t\t\t\tif ( primitive.indices === null ) delete primitive.indices;\n\n\t\t\t}\n\n\t\t\tconst material = await this.processMaterialAsync( materials[ groups[ i ].materialIndex ] );\n\n\t\t\tif ( material !== null ) primitive.material = material;\n\n\t\t\tprimitives.push( primitive );\n\n\t\t}\n\n\t\tif ( didForceIndices === true ) {\n\n\t\t\tgeometry.setIndex( null );\n\n\t\t}\n\n\t\tmeshDef.primitives = primitives;\n\n\t\tif ( ! json.meshes ) json.meshes = [];\n\n\t\tawait this._invokeAllAsync( function ( ext ) {\n\n\t\t\text.writeMesh && ext.writeMesh( mesh, meshDef );\n\n\t\t} );\n\n\t\tconst index = json.meshes.push( meshDef ) - 1;\n\t\tcache.meshes.set( meshCacheKey, index );\n\t\treturn index;\n\n\t}\n\n\t/**\n\t * If a vertex attribute with a\n\t * [non-standard data type](https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#meshes-overview)\n\t * is used, it is checked whether it is a valid data type according to the\n\t * [KHR_mesh_quantization](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_mesh_quantization/README.md)\n\t * extension.\n\t * In this case the extension is automatically added to the list of used extensions.\n\t *\n\t * @param {string} attributeName\n\t * @param {THREE.BufferAttribute} attribute\n\t */\n\tdetectMeshQuantization( attributeName, attribute ) {\n\n\t\tif ( this.extensionsUsed[ KHR_MESH_QUANTIZATION ] ) return;\n\n\t\tlet attrType = undefined;\n\n\t\tswitch ( attribute.array.constructor ) {\n\n\t\t\tcase Int8Array:\n\n\t\t\t\tattrType = 'byte';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Uint8Array:\n\n\t\t\t\tattrType = 'unsigned byte';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Int16Array:\n\n\t\t\t\tattrType = 'short';\n\n\t\t\t\tbreak;\n\n\t\t\tcase Uint16Array:\n\n\t\t\t\tattrType = 'unsigned short';\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\treturn;\n\n\t\t}\n\n\t\tif ( attribute.normalized ) attrType += ' normalized';\n\n\t\tconst attrNamePrefix = attributeName.split( '_', 1 )[ 0 ];\n\n\t\tif ( KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ] && KHR_mesh_quantization_ExtraAttrTypes[ attrNamePrefix ].includes( attrType ) ) {\n\n\t\t\tthis.extensionsUsed[ KHR_MESH_QUANTIZATION ] = true;\n\t\t\tthis.extensionsRequired[ KHR_MESH_QUANTIZATION ] = true;\n\n\t\t}\n\n\t}\n\n\t/**\n\t * Process camera\n\t * @param {THREE.Camera} camera Camera to process\n\t * @return {number} Index of the processed mesh in the \"camera\" array\n\t */\n\tprocessCamera( camera ) {\n\n\t\tconst json = this.json;\n\n\t\tif ( ! json.cameras ) json.cameras = [];\n\n\t\tconst isOrtho = camera.isOrthographicCamera;\n\n\t\tconst cameraDef = {\n\t\t\ttype: isOrtho ? 'orthographic' : 'perspective'\n\t\t};\n\n\t\tif ( isOrtho ) {\n\n\t\t\tcameraDef.orthographic = {\n\t\t\t\txmag: camera.right * 2,\n\t\t\t\tymag: camera.top * 2,\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t} else {\n\n\t\t\tcameraDef.perspective = {\n\t\t\t\taspectRatio: camera.aspect,\n\t\t\t\tyfov: MathUtils.degToRad( camera.fov ),\n\t\t\t\tzfar: camera.far <= 0 ? 0.001 : camera.far,\n\t\t\t\tznear: camera.near < 0 ? 0 : camera.near\n\t\t\t};\n\n\t\t}\n\n\t\t// Question: Is saving \"type\" as name intentional?\n\t\tif ( camera.name !== '' ) cameraDef.name = camera.type;\n\n\t\treturn json.cameras.push( cameraDef ) - 1;\n\n\t}\n\n\t/**\n\t * Creates glTF animation entry from AnimationClip object.\n\t *\n\t * Status:\n\t * - Only properties listed in PATH_PROPERTIES may be animated.\n\t *\n\t * @param {THREE.AnimationClip} clip\n\t * @param {THREE.Object3D} root\n\t * @return {?number}\n\t */\n\tprocessAnimation( clip, root ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.animations ) json.animations = [];\n\n\t\tclip = GLTFExporter.Utils.mergeMorphTargetTracks( clip.clone(), root );\n\n\t\tconst tracks = clip.tracks;\n\t\tconst channels = [];\n\t\tconst samplers = [];\n\n\t\tfor ( let i = 0; i < tracks.length; ++ i ) {\n\n\t\t\tconst track = tracks[ i ];\n\t\t\tconst trackBinding = PropertyBinding.parseTrackName( track.name );\n\t\t\tlet trackNode = PropertyBinding.findNode( root, trackBinding.nodeName );\n\t\t\tconst trackProperty = PATH_PROPERTIES[ trackBinding.propertyName ];\n\n\t\t\tif ( trackBinding.objectName === 'bones' ) {\n\n\t\t\t\tif ( trackNode.isSkinnedMesh === true ) {\n\n\t\t\t\t\ttrackNode = trackNode.skeleton.getBoneByName( trackBinding.objectIndex );\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttrackNode = undefined;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! trackNode || ! trackProperty ) {\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Could not export animation track \"%s\".', track.name );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst inputItemSize = 1;\n\t\t\tlet outputItemSize = track.values.length / track.times.length;\n\n\t\t\tif ( trackProperty === PATH_PROPERTIES.morphTargetInfluences ) {\n\n\t\t\t\toutputItemSize /= trackNode.morphTargetInfluences.length;\n\n\t\t\t}\n\n\t\t\tlet interpolation;\n\n\t\t\t// @TODO export CubicInterpolant(InterpolateSmooth) as CUBICSPLINE\n\n\t\t\t// Detecting glTF cubic spline interpolant by checking factory method's special property\n\t\t\t// GLTFCubicSplineInterpolant is a custom interpolant and track doesn't return\n\t\t\t// valid value from .getInterpolation().\n\t\t\tif ( track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline === true ) {\n\n\t\t\t\tinterpolation = 'CUBICSPLINE';\n\n\t\t\t\t// itemSize of CUBICSPLINE keyframe is 9\n\t\t\t\t// (VEC3 * 3: inTangent, splineVertex, and outTangent)\n\t\t\t\t// but needs to be stored as VEC3 so dividing by 3 here.\n\t\t\t\toutputItemSize /= 3;\n\n\t\t\t} else if ( track.getInterpolation() === InterpolateDiscrete ) {\n\n\t\t\t\tinterpolation = 'STEP';\n\n\t\t\t} else {\n\n\t\t\t\tinterpolation = 'LINEAR';\n\n\t\t\t}\n\n\t\t\tsamplers.push( {\n\t\t\t\tinput: this.processAccessor( new BufferAttribute( track.times, inputItemSize ) ),\n\t\t\t\toutput: this.processAccessor( new BufferAttribute( track.values, outputItemSize ) ),\n\t\t\t\tinterpolation: interpolation\n\t\t\t} );\n\n\t\t\tchannels.push( {\n\t\t\t\tsampler: samplers.length - 1,\n\t\t\t\ttarget: {\n\t\t\t\t\tnode: nodeMap.get( trackNode ),\n\t\t\t\t\tpath: trackProperty\n\t\t\t\t}\n\t\t\t} );\n\n\t\t}\n\n\t\tconst animationDef = {\n\t\t\tname: clip.name || 'clip_' + json.animations.length,\n\t\t\tsamplers: samplers,\n\t\t\tchannels: channels\n\t\t};\n\n\t\tthis.serializeUserData( clip, animationDef );\n\n\t\tjson.animations.push( animationDef );\n\n\t\treturn json.animations.length - 1;\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D} object\n\t * @return {?number}\n\t */\n\t processSkin( object ) {\n\n\t\tconst json = this.json;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tconst node = json.nodes[ nodeMap.get( object ) ];\n\n\t\tconst skeleton = object.skeleton;\n\n\t\tif ( skeleton === undefined ) return null;\n\n\t\tconst rootJoint = object.skeleton.bones[ 0 ];\n\n\t\tif ( rootJoint === undefined ) return null;\n\n\t\tconst joints = [];\n\t\tconst inverseBindMatrices = new Float32Array( skeleton.bones.length * 16 );\n\t\tconst temporaryBoneInverse = new Matrix4();\n\n\t\tfor ( let i = 0; i < skeleton.bones.length; ++ i ) {\n\n\t\t\tjoints.push( nodeMap.get( skeleton.bones[ i ] ) );\n\t\t\ttemporaryBoneInverse.copy( skeleton.boneInverses[ i ] );\n\t\t\ttemporaryBoneInverse.multiply( object.bindMatrix ).toArray( inverseBindMatrices, i * 16 );\n\n\t\t}\n\n\t\tif ( json.skins === undefined ) json.skins = [];\n\n\t\tjson.skins.push( {\n\t\t\tinverseBindMatrices: this.processAccessor( new BufferAttribute( inverseBindMatrices, 16 ) ),\n\t\t\tjoints: joints,\n\t\t\tskeleton: nodeMap.get( rootJoint )\n\t\t} );\n\n\t\tconst skinIndex = node.skin = json.skins.length - 1;\n\n\t\treturn skinIndex;\n\n\t}\n\n\t/**\n\t * Process Object3D node\n\t * @param {THREE.Object3D} object Object3D to processNodeAsync\n\t * @return {Promise<number>} Index of the node in the nodes list\n\t */\n\tasync processNodeAsync( object ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\t\tconst nodeMap = this.nodeMap;\n\n\t\tif ( ! json.nodes ) json.nodes = [];\n\n\t\tconst nodeDef = {};\n\n\t\tif ( options.trs ) {\n\n\t\t\tconst rotation = object.quaternion.toArray();\n\t\t\tconst position = object.position.toArray();\n\t\t\tconst scale = object.scale.toArray();\n\n\t\t\tif ( ! equalArray( rotation, [ 0, 0, 0, 1 ] ) ) {\n\n\t\t\t\tnodeDef.rotation = rotation;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( position, [ 0, 0, 0 ] ) ) {\n\n\t\t\t\tnodeDef.translation = position;\n\n\t\t\t}\n\n\t\t\tif ( ! equalArray( scale, [ 1, 1, 1 ] ) ) {\n\n\t\t\t\tnodeDef.scale = scale;\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tif ( object.matrixAutoUpdate ) {\n\n\t\t\t\tobject.updateMatrix();\n\n\t\t\t}\n\n\t\t\tif ( isIdentityMatrix( object.matrix ) === false ) {\n\n\t\t\t\tnodeDef.matrix = object.matrix.elements;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// We don't export empty strings name because it represents no-name in Three.js.\n\t\tif ( object.name !== '' ) nodeDef.name = String( object.name );\n\n\t\tthis.serializeUserData( object, nodeDef );\n\n\t\tif ( object.isMesh || object.isLine || object.isPoints ) {\n\n\t\t\tconst meshIndex = await this.processMeshAsync( object );\n\n\t\t\tif ( meshIndex !== null ) nodeDef.mesh = meshIndex;\n\n\t\t} else if ( object.isCamera ) {\n\n\t\t\tnodeDef.camera = this.processCamera( object );\n\n\t\t}\n\n\t\tif ( object.isSkinnedMesh ) this.skins.push( object );\n\n\t\tconst nodeIndex = json.nodes.push( nodeDef ) - 1;\n\t\tnodeMap.set( object, nodeIndex );\n\n\t\tif ( object.children.length > 0 ) {\n\n\t\t\tconst children = [];\n\n\t\t\tfor ( let i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\t\t\tconst child = object.children[ i ];\n\n\t\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\t\tconst childNodeIndex = await this.processNodeAsync( child );\n\n\t\t\t\t\tif ( childNodeIndex !== null ) children.push( childNodeIndex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( children.length > 0 ) nodeDef.children = children;\n\n\t\t}\n\n\t\tawait this._invokeAllAsync( function ( ext ) {\n\n\t\t\text.writeNode && ext.writeNode( object, nodeDef );\n\n\t\t} );\n\n\t\treturn nodeIndex;\n\n\t}\n\n\t/**\n\t * Process Scene\n\t * @param {Scene} scene Scene to process\n\t */\n\tasync processSceneAsync( scene ) {\n\n\t\tconst json = this.json;\n\t\tconst options = this.options;\n\n\t\tif ( ! json.scenes ) {\n\n\t\t\tjson.scenes = [];\n\t\t\tjson.scene = 0;\n\n\t\t}\n\n\t\tconst sceneDef = {};\n\n\t\tif ( scene.name !== '' ) sceneDef.name = scene.name;\n\n\t\tjson.scenes.push( sceneDef );\n\n\t\tconst nodes = [];\n\n\t\tfor ( let i = 0, l = scene.children.length; i < l; i ++ ) {\n\n\t\t\tconst child = scene.children[ i ];\n\n\t\t\tif ( child.visible || options.onlyVisible === false ) {\n\n\t\t\t\tconst nodeIndex = await this.processNodeAsync( child );\n\n\t\t\t\tif ( nodeIndex !== null ) nodes.push( nodeIndex );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( nodes.length > 0 ) sceneDef.nodes = nodes;\n\n\t\tthis.serializeUserData( scene, sceneDef );\n\n\t}\n\n\t/**\n\t * Creates a Scene to hold a list of objects and parse it\n\t * @param {Array<THREE.Object3D>} objects List of objects to process\n\t */\n\tasync processObjectsAsync( objects ) {\n\n\t\tconst scene = new Scene();\n\t\tscene.name = 'AuxScene';\n\n\t\tfor ( let i = 0; i < objects.length; i ++ ) {\n\n\t\t\t// We push directly to children instead of calling `add` to prevent\n\t\t\t// modify the .parent and break its original scene and hierarchy\n\t\t\tscene.children.push( objects[ i ] );\n\n\t\t}\n\n\t\tawait this.processSceneAsync( scene );\n\n\t}\n\n\t/**\n\t * @param {THREE.Object3D|Array<THREE.Object3D>} input\n\t */\n\tasync processInputAsync( input ) {\n\n\t\tconst options = this.options;\n\n\t\tinput = input instanceof Array ? input : [ input ];\n\n\t\tawait this._invokeAllAsync( function ( ext ) {\n\n\t\t\text.beforeParse && ext.beforeParse( input );\n\n\t\t} );\n\n\t\tconst objectsWithoutScene = [];\n\n\t\tfor ( let i = 0; i < input.length; i ++ ) {\n\n\t\t\tif ( input[ i ] instanceof Scene ) {\n\n\t\t\t\tawait this.processSceneAsync( input[ i ] );\n\n\t\t\t} else {\n\n\t\t\t\tobjectsWithoutScene.push( input[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( objectsWithoutScene.length > 0 ) {\n\n\t\t\tawait this.processObjectsAsync( objectsWithoutScene );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.skins.length; ++ i ) {\n\n\t\t\tthis.processSkin( this.skins[ i ] );\n\n\t\t}\n\n\t\tfor ( let i = 0; i < options.animations.length; ++ i ) {\n\n\t\t\tthis.processAnimation( options.animations[ i ], input[ 0 ] );\n\n\t\t}\n\n\t\tawait this._invokeAllAsync( function ( ext ) {\n\n\t\t\text.afterParse && ext.afterParse( input );\n\n\t\t} );\n\n\t}\n\n\tasync _invokeAllAsync( func ) {\n\n\t\tfor ( let i = 0, il = this.plugins.length; i < il; i ++ ) {\n\n\t\t\tawait func( this.plugins[ i ] );\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Punctual Lights Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual\n *\n * @private\n */\nclass GLTFLightExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_lights_punctual';\n\n\t}\n\n\twriteNode( light, nodeDef ) {\n\n\t\tif ( ! light.isLight ) return;\n\n\t\tif ( ! light.isDirectionalLight && ! light.isPointLight && ! light.isSpotLight ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Only directional, point, and spot lights are supported.', light );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst writer = this.writer;\n\t\tconst json = writer.json;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst lightDef = {};\n\n\t\tif ( light.name ) lightDef.name = light.name;\n\n\t\tlightDef.color = light.color.toArray();\n\n\t\tlightDef.intensity = light.intensity;\n\n\t\tif ( light.isDirectionalLight ) {\n\n\t\t\tlightDef.type = 'directional';\n\n\t\t} else if ( light.isPointLight ) {\n\n\t\t\tlightDef.type = 'point';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t} else if ( light.isSpotLight ) {\n\n\t\t\tlightDef.type = 'spot';\n\n\t\t\tif ( light.distance > 0 ) lightDef.range = light.distance;\n\n\t\t\tlightDef.spot = {};\n\t\t\tlightDef.spot.innerConeAngle = ( 1.0 - light.penumbra ) * light.angle;\n\t\t\tlightDef.spot.outerConeAngle = light.angle;\n\n\t\t}\n\n\t\tif ( light.decay !== undefined && light.decay !== 2 ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, '\n\t\t\t\t+ 'and expects light.decay=2.' );\n\n\t\t}\n\n\t\tif ( light.target\n\t\t\t\t&& ( light.target.parent !== light\n\t\t\t\t|| light.target.position.x !== 0\n\t\t\t\t|| light.target.position.y !== 0\n\t\t\t\t|| light.target.position.z !== - 1 ) ) {\n\n\t\t\tconsole.warn( 'THREE.GLTFExporter: Light direction may be lost. For best results, '\n\t\t\t\t+ 'make light.target a child of the light with position 0,0,-1.' );\n\n\t\t}\n\n\t\tif ( ! extensionsUsed[ this.name ] ) {\n\n\t\t\tjson.extensions = json.extensions || {};\n\t\t\tjson.extensions[ this.name ] = { lights: [] };\n\t\t\textensionsUsed[ this.name ] = true;\n\n\t\t}\n\n\t\tconst lights = json.extensions[ this.name ].lights;\n\t\tlights.push( lightDef );\n\n\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\tnodeDef.extensions[ this.name ] = { light: lights.length - 1 };\n\n\t}\n\n}\n\n/**\n * Unlit Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit\n *\n * @private\n */\nclass GLTFMaterialsUnlitExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_unlit';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshBasicMaterial ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = {};\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t\tmaterialDef.pbrMetallicRoughness.metallicFactor = 0.0;\n\t\tmaterialDef.pbrMetallicRoughness.roughnessFactor = 0.9;\n\n\t}\n\n}\n\n/**\n * Clearcoat Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat\n *\n * @private\n */\nclass GLTFMaterialsClearcoatExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_clearcoat';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.clearcoat === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.clearcoatFactor = material.clearcoat;\n\n\t\tif ( material.clearcoatMap ) {\n\n\t\t\tconst clearcoatMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.clearcoatMap ),\n\t\t\t\ttexCoord: material.clearcoatMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( clearcoatMapDef, material.clearcoatMap );\n\t\t\textensionDef.clearcoatTexture = clearcoatMapDef;\n\n\t\t}\n\n\t\textensionDef.clearcoatRoughnessFactor = material.clearcoatRoughness;\n\n\t\tif ( material.clearcoatRoughnessMap ) {\n\n\t\t\tconst clearcoatRoughnessMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.clearcoatRoughnessMap ),\n\t\t\t\ttexCoord: material.clearcoatRoughnessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( clearcoatRoughnessMapDef, material.clearcoatRoughnessMap );\n\t\t\textensionDef.clearcoatRoughnessTexture = clearcoatRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.clearcoatNormalMap ) {\n\n\t\t\tconst clearcoatNormalMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.clearcoatNormalMap ),\n\t\t\t\ttexCoord: material.clearcoatNormalMap.channel\n\t\t\t};\n\n\t\t\tif ( material.clearcoatNormalScale.x !== 1 ) clearcoatNormalMapDef.scale = material.clearcoatNormalScale.x;\n\n\t\t\twriter.applyTextureTransform( clearcoatNormalMapDef, material.clearcoatNormalMap );\n\t\t\textensionDef.clearcoatNormalTexture = clearcoatNormalMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\n\t}\n\n}\n\n/**\n * Materials dispersion Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_dispersion\n *\n * @private\n */\nclass GLTFMaterialsDispersionExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_dispersion';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.dispersion === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.dispersion = material.dispersion;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Iridescence Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_iridescence\n *\n * @private\n */\nclass GLTFMaterialsIridescenceExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_iridescence';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.iridescence === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.iridescenceFactor = material.iridescence;\n\n\t\tif ( material.iridescenceMap ) {\n\n\t\t\tconst iridescenceMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.iridescenceMap ),\n\t\t\t\ttexCoord: material.iridescenceMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( iridescenceMapDef, material.iridescenceMap );\n\t\t\textensionDef.iridescenceTexture = iridescenceMapDef;\n\n\t\t}\n\n\t\textensionDef.iridescenceIor = material.iridescenceIOR;\n\t\textensionDef.iridescenceThicknessMinimum = material.iridescenceThicknessRange[ 0 ];\n\t\textensionDef.iridescenceThicknessMaximum = material.iridescenceThicknessRange[ 1 ];\n\n\t\tif ( material.iridescenceThicknessMap ) {\n\n\t\t\tconst iridescenceThicknessMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.iridescenceThicknessMap ),\n\t\t\t\ttexCoord: material.iridescenceThicknessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( iridescenceThicknessMapDef, material.iridescenceThicknessMap );\n\t\t\textensionDef.iridescenceThicknessTexture = iridescenceThicknessMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Transmission Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission\n *\n * @private\n */\nclass GLTFMaterialsTransmissionExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_transmission';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.transmissionFactor = material.transmission;\n\n\t\tif ( material.transmissionMap ) {\n\n\t\t\tconst transmissionMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.transmissionMap ),\n\t\t\t\ttexCoord: material.transmissionMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( transmissionMapDef, material.transmissionMap );\n\t\t\textensionDef.transmissionTexture = transmissionMapDef;\n\n\t\t}\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Volume Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_volume\n *\n * @private\n */\nclass GLTFMaterialsVolumeExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_volume';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.transmission === 0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.thicknessFactor = material.thickness;\n\n\t\tif ( material.thicknessMap ) {\n\n\t\t\tconst thicknessMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.thicknessMap ),\n\t\t\t\ttexCoord: material.thicknessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( thicknessMapDef, material.thicknessMap );\n\t\t\textensionDef.thicknessTexture = thicknessMapDef;\n\n\t\t}\n\n\t\tif ( material.attenuationDistance !== Infinity ) {\n\n\t\t\textensionDef.attenuationDistance = material.attenuationDistance;\n\n\t\t}\n\n\t\textensionDef.attenuationColor = material.attenuationColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials ior Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_ior\n *\n * @private\n */\nclass GLTFMaterialsIorExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_ior';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.ior === 1.5 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.ior = material.ior;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials specular Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_specular\n *\n * @private\n */\nclass GLTFMaterialsSpecularExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_specular';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || ( material.specularIntensity === 1.0 &&\n\t\t       material.specularColor.equals( DEFAULT_SPECULAR_COLOR ) &&\n\t\t     ! material.specularIntensityMap && ! material.specularColorMap ) ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.specularIntensityMap ) {\n\n\t\t\tconst specularIntensityMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.specularIntensityMap ),\n\t\t\t\ttexCoord: material.specularIntensityMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( specularIntensityMapDef, material.specularIntensityMap );\n\t\t\textensionDef.specularTexture = specularIntensityMapDef;\n\n\t\t}\n\n\t\tif ( material.specularColorMap ) {\n\n\t\t\tconst specularColorMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.specularColorMap ),\n\t\t\t\ttexCoord: material.specularColorMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( specularColorMapDef, material.specularColorMap );\n\t\t\textensionDef.specularColorTexture = specularColorMapDef;\n\n\t\t}\n\n\t\textensionDef.specularFactor = material.specularIntensity;\n\t\textensionDef.specularColorFactor = material.specularColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Sheen Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_sheen\n *\n * @private\n */\nclass GLTFMaterialsSheenExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_sheen';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.sheen == 0.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.sheenRoughnessMap ) {\n\n\t\t\tconst sheenRoughnessMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.sheenRoughnessMap ),\n\t\t\t\ttexCoord: material.sheenRoughnessMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( sheenRoughnessMapDef, material.sheenRoughnessMap );\n\t\t\textensionDef.sheenRoughnessTexture = sheenRoughnessMapDef;\n\n\t\t}\n\n\t\tif ( material.sheenColorMap ) {\n\n\t\t\tconst sheenColorMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.sheenColorMap ),\n\t\t\t\ttexCoord: material.sheenColorMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( sheenColorMapDef, material.sheenColorMap );\n\t\t\textensionDef.sheenColorTexture = sheenColorMapDef;\n\n\t\t}\n\n\t\textensionDef.sheenRoughnessFactor = material.sheenRoughness;\n\t\textensionDef.sheenColorFactor = material.sheenColor.toArray();\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Anisotropy Materials Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_anisotropy\n *\n * @private\n */\nclass GLTFMaterialsAnisotropyExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_anisotropy';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshPhysicalMaterial || material.anisotropy == 0.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.anisotropyMap ) {\n\n\t\t\tconst anisotropyMapDef = { index: await writer.processTextureAsync( material.anisotropyMap ) };\n\t\t\twriter.applyTextureTransform( anisotropyMapDef, material.anisotropyMap );\n\t\t\textensionDef.anisotropyTexture = anisotropyMapDef;\n\n\t\t}\n\n\t\textensionDef.anisotropyStrength = material.anisotropy;\n\t\textensionDef.anisotropyRotation = material.anisotropyRotation;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Materials Emissive Strength Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/blob/5768b3ce0ef32bc39cdf1bef10b948586635ead3/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md\n *\n * @private\n */\nclass GLTFMaterialsEmissiveStrengthExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'KHR_materials_emissive_strength';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshStandardMaterial || material.emissiveIntensity === 1.0 ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\textensionDef.emissiveStrength = material.emissiveIntensity;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n\n/**\n * Materials bump Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/EXT_materials_bump\n *\n * @private\n */\nclass GLTFMaterialsBumpExtension {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'EXT_materials_bump';\n\n\t}\n\n\tasync writeMaterialAsync( material, materialDef ) {\n\n\t\tif ( ! material.isMeshStandardMaterial || (\n\t\t       material.bumpScale === 1 &&\n\t\t     ! material.bumpMap ) ) return;\n\n\t\tconst writer = this.writer;\n\t\tconst extensionsUsed = writer.extensionsUsed;\n\n\t\tconst extensionDef = {};\n\n\t\tif ( material.bumpMap ) {\n\n\t\t\tconst bumpMapDef = {\n\t\t\t\tindex: await writer.processTextureAsync( material.bumpMap ),\n\t\t\t\ttexCoord: material.bumpMap.channel\n\t\t\t};\n\t\t\twriter.applyTextureTransform( bumpMapDef, material.bumpMap );\n\t\t\textensionDef.bumpTexture = bumpMapDef;\n\n\t\t}\n\n\t\textensionDef.bumpFactor = material.bumpScale;\n\n\t\tmaterialDef.extensions = materialDef.extensions || {};\n\t\tmaterialDef.extensions[ this.name ] = extensionDef;\n\n\t\textensionsUsed[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * GPU Instancing Extension\n *\n * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/EXT_mesh_gpu_instancing\n *\n * @private\n */\nclass GLTFMeshGpuInstancing {\n\n\tconstructor( writer ) {\n\n\t\tthis.writer = writer;\n\t\tthis.name = 'EXT_mesh_gpu_instancing';\n\n\t}\n\n\twriteNode( object, nodeDef ) {\n\n\t\tif ( ! object.isInstancedMesh ) return;\n\n\t\tconst writer = this.writer;\n\n\t\tconst mesh = object;\n\n\t\tconst translationAttr = new Float32Array( mesh.count * 3 );\n\t\tconst rotationAttr = new Float32Array( mesh.count * 4 );\n\t\tconst scaleAttr = new Float32Array( mesh.count * 3 );\n\n\t\tconst matrix = new Matrix4();\n\t\tconst position = new Vector3();\n\t\tconst quaternion = new Quaternion();\n\t\tconst scale = new Vector3();\n\n\t\tfor ( let i = 0; i < mesh.count; i ++ ) {\n\n\t\t\tmesh.getMatrixAt( i, matrix );\n\t\t\tmatrix.decompose( position, quaternion, scale );\n\n\t\t\tposition.toArray( translationAttr, i * 3 );\n\t\t\tquaternion.toArray( rotationAttr, i * 4 );\n\t\t\tscale.toArray( scaleAttr, i * 3 );\n\n\t\t}\n\n\t\tconst attributes = {\n\t\t\tTRANSLATION: writer.processAccessor( new BufferAttribute( translationAttr, 3 ) ),\n\t\t\tROTATION: writer.processAccessor( new BufferAttribute( rotationAttr, 4 ) ),\n\t\t\tSCALE: writer.processAccessor( new BufferAttribute( scaleAttr, 3 ) ),\n\t\t};\n\n\t\tif ( mesh.instanceColor )\n\t\t\tattributes._COLOR_0 = writer.processAccessor( mesh.instanceColor );\n\n\t\tnodeDef.extensions = nodeDef.extensions || {};\n\t\tnodeDef.extensions[ this.name ] = { attributes };\n\n\t\twriter.extensionsUsed[ this.name ] = true;\n\t\twriter.extensionsRequired[ this.name ] = true;\n\n\t}\n\n}\n\n/**\n * Static utility functions\n *\n * @private\n */\nGLTFExporter.Utils = {\n\n\tinsertKeyframe: function ( track, time ) {\n\n\t\tconst tolerance = 0.001; // 1ms\n\t\tconst valueSize = track.getValueSize();\n\n\t\tconst times = new track.TimeBufferType( track.times.length + 1 );\n\t\tconst values = new track.ValueBufferType( track.values.length + valueSize );\n\t\tconst interpolant = track.createInterpolant( new track.ValueBufferType( valueSize ) );\n\n\t\tlet index;\n\n\t\tif ( track.times.length === 0 ) {\n\n\t\t\ttimes[ 0 ] = time;\n\n\t\t\tfor ( let i = 0; i < valueSize; i ++ ) {\n\n\t\t\t\tvalues[ i ] = 0;\n\n\t\t\t}\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time < track.times[ 0 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ 0 ] - time ) < tolerance ) return 0;\n\n\t\t\ttimes[ 0 ] = time;\n\t\t\ttimes.set( track.times, 1 );\n\n\t\t\tvalues.set( interpolant.evaluate( time ), 0 );\n\t\t\tvalues.set( track.values, valueSize );\n\n\t\t\tindex = 0;\n\n\t\t} else if ( time > track.times[ track.times.length - 1 ] ) {\n\n\t\t\tif ( Math.abs( track.times[ track.times.length - 1 ] - time ) < tolerance ) {\n\n\t\t\t\treturn track.times.length - 1;\n\n\t\t\t}\n\n\t\t\ttimes[ times.length - 1 ] = time;\n\t\t\ttimes.set( track.times, 0 );\n\n\t\t\tvalues.set( track.values, 0 );\n\t\t\tvalues.set( interpolant.evaluate( time ), track.values.length );\n\n\t\t\tindex = times.length - 1;\n\n\t\t} else {\n\n\t\t\tfor ( let i = 0; i < track.times.length; i ++ ) {\n\n\t\t\t\tif ( Math.abs( track.times[ i ] - time ) < tolerance ) return i;\n\n\t\t\t\tif ( track.times[ i ] < time && track.times[ i + 1 ] > time ) {\n\n\t\t\t\t\ttimes.set( track.times.slice( 0, i + 1 ), 0 );\n\t\t\t\t\ttimes[ i + 1 ] = time;\n\t\t\t\t\ttimes.set( track.times.slice( i + 1 ), i + 2 );\n\n\t\t\t\t\tvalues.set( track.values.slice( 0, ( i + 1 ) * valueSize ), 0 );\n\t\t\t\t\tvalues.set( interpolant.evaluate( time ), ( i + 1 ) * valueSize );\n\t\t\t\t\tvalues.set( track.values.slice( ( i + 1 ) * valueSize ), ( i + 2 ) * valueSize );\n\n\t\t\t\t\tindex = i + 1;\n\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\ttrack.times = times;\n\t\ttrack.values = values;\n\n\t\treturn index;\n\n\t},\n\n\tmergeMorphTargetTracks: function ( clip, root ) {\n\n\t\tconst tracks = [];\n\t\tconst mergedTracks = {};\n\t\tconst sourceTracks = clip.tracks;\n\n\t\tfor ( let i = 0; i < sourceTracks.length; ++ i ) {\n\n\t\t\tlet sourceTrack = sourceTracks[ i ];\n\t\t\tconst sourceTrackBinding = PropertyBinding.parseTrackName( sourceTrack.name );\n\t\t\tconst sourceTrackNode = PropertyBinding.findNode( root, sourceTrackBinding.nodeName );\n\n\t\t\tif ( sourceTrackBinding.propertyName !== 'morphTargetInfluences' || sourceTrackBinding.propertyIndex === undefined ) {\n\n\t\t\t\t// Tracks that don't affect morph targets, or that affect all morph targets together, can be left as-is.\n\t\t\t\ttracks.push( sourceTrack );\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tif ( sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodDiscrete\n\t\t\t\t&& sourceTrack.createInterpolant !== sourceTrack.InterpolantFactoryMethodLinear ) {\n\n\t\t\t\tif ( sourceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {\n\n\t\t\t\t\t// This should never happen, because glTF morph target animations\n\t\t\t\t\t// affect all targets already.\n\t\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.' );\n\n\t\t\t\t}\n\n\t\t\t\tconsole.warn( 'THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead.' );\n\n\t\t\t\tsourceTrack = sourceTrack.clone();\n\t\t\t\tsourceTrack.setInterpolation( InterpolateLinear );\n\n\t\t\t}\n\n\t\t\tconst targetCount = sourceTrackNode.morphTargetInfluences.length;\n\t\t\tconst targetIndex = sourceTrackNode.morphTargetDictionary[ sourceTrackBinding.propertyIndex ];\n\n\t\t\tif ( targetIndex === undefined ) {\n\n\t\t\t\tthrow new Error( 'THREE.GLTFExporter: Morph target name not found: ' + sourceTrackBinding.propertyIndex );\n\n\t\t\t}\n\n\t\t\tlet mergedTrack;\n\n\t\t\t// If this is the first time we've seen this object, create a new\n\t\t\t// track to store merged keyframe data for each morph target.\n\t\t\tif ( mergedTracks[ sourceTrackNode.uuid ] === undefined ) {\n\n\t\t\t\tmergedTrack = sourceTrack.clone();\n\n\t\t\t\tconst values = new mergedTrack.ValueBufferType( targetCount * mergedTrack.times.length );\n\n\t\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\t\tvalues[ j * targetCount + targetIndex ] = mergedTrack.values[ j ];\n\n\t\t\t\t}\n\n\t\t\t\t// We need to take into consideration the intended target node\n\t\t\t\t// of our original un-merged morphTarget animation.\n\t\t\t\tmergedTrack.name = ( sourceTrackBinding.nodeName || '' ) + '.morphTargetInfluences';\n\t\t\t\tmergedTrack.values = values;\n\n\t\t\t\tmergedTracks[ sourceTrackNode.uuid ] = mergedTrack;\n\t\t\t\ttracks.push( mergedTrack );\n\n\t\t\t\tcontinue;\n\n\t\t\t}\n\n\t\t\tconst sourceInterpolant = sourceTrack.createInterpolant( new sourceTrack.ValueBufferType( 1 ) );\n\n\t\t\tmergedTrack = mergedTracks[ sourceTrackNode.uuid ];\n\n\t\t\t// For every existing keyframe of the merged track, write a (possibly\n\t\t\t// interpolated) value from the source track.\n\t\t\tfor ( let j = 0; j < mergedTrack.times.length; j ++ ) {\n\n\t\t\t\tmergedTrack.values[ j * targetCount + targetIndex ] = sourceInterpolant.evaluate( mergedTrack.times[ j ] );\n\n\t\t\t}\n\n\t\t\t// For every existing keyframe of the source track, write a (possibly\n\t\t\t// new) keyframe to the merged track. Values from the previous loop may\n\t\t\t// be written again, but keyframes are de-duplicated.\n\t\t\tfor ( let j = 0; j < sourceTrack.times.length; j ++ ) {\n\n\t\t\t\tconst keyframeIndex = this.insertKeyframe( mergedTrack, sourceTrack.times[ j ] );\n\t\t\t\tmergedTrack.values[ keyframeIndex * targetCount + targetIndex ] = sourceTrack.values[ j ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tclip.tracks = tracks;\n\n\t\treturn clip;\n\n\t},\n\n\ttoFloat32BufferAttribute: function ( srcAttribute ) {\n\n\t\tconst dstAttribute = new BufferAttribute( new Float32Array( srcAttribute.count * srcAttribute.itemSize ), srcAttribute.itemSize, false );\n\n\t\tif ( ! srcAttribute.normalized && ! srcAttribute.isInterleavedBufferAttribute ) {\n\n\t\t\tdstAttribute.array.set( srcAttribute.array );\n\n\t\t\treturn dstAttribute;\n\n\t\t}\n\n\t\tfor ( let i = 0, il = srcAttribute.count; i < il; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < srcAttribute.itemSize; j ++ ) {\n\n\t\t\t\tdstAttribute.setComponent( i, j, srcAttribute.getComponent( i, j ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn dstAttribute;\n\n\t}\n\n};\n\n/**\n * Export options of `GLTFExporter`.\n *\n * @typedef {Object} GLTFExporter~Options\n * @property {boolean} [trs=false] - Export position, rotation and scale instead of matrix per node.\n * @property {boolean} [onlyVisible=true] - Export only visible 3D objects.\n * @property {boolean} [binary=false] - Export in binary (.glb) format, returning an ArrayBuffer.\n * @property {number} [maxTextureSize=Infinity] - Restricts the image maximum size (both width and height) to the given value.\n * @property {Array<AnimationClip>} [animations=[]] - List of animations to be included in the export.\n * @property {boolean} [includeCustomExtensions=false] - Export custom glTF extensions defined on an object's `userData.gltfExtensions` property.\n **/\n\n/**\n * onDone callback of `GLTFExporter`.\n *\n * @callback GLTFExporter~OnDone\n * @param {ArrayBuffer|string} result - The generated .gltf (JSON) or .glb (binary).\n */\n\n/**\n * onError callback of `GLTFExporter`.\n *\n * @callback GLTFExporter~OnError\n * @param {Error} error - The error object.\n */\n\nexport { GLTFExporter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}