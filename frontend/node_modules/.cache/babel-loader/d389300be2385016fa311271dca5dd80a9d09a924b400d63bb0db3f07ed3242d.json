{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport * as THREE from \"three\";\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\nexport default {\n  name: \"ThreeDBox\",\n  props: {\n    image: {\n      type: String,\n      required: false\n    },\n    imageFront: {\n      type: String,\n      required: false\n    },\n    imageSide: {\n      type: String,\n      required: false\n    },\n    imageBack: {\n      type: String,\n      required: false\n    },\n    imageTop: {\n      type: String,\n      required: false\n    },\n    imageBottom: {\n      type: String,\n      required: false\n    },\n    model3D: {\n      type: String,\n      required: false\n    },\n    shape: {\n      type: String,\n      default: \"box\" // box, pillow, cylinder\n    }\n  },\n  data() {\n    return {\n      // We don't want Vue to make these reactive because Three.js objects are complex\n      // and Vue's proxying can interfere with internal properties like modelViewMatrix\n    };\n  },\n  mounted() {\n    // Store Three.js objects as non-reactive properties on the instance\n    this.scene = null;\n    this.camera = null;\n    this.renderer = null;\n    this.cube = null;\n    this.model = null;\n    this.controls = null;\n    this.animationId = null;\n    this.initThree();\n    window.addEventListener(\"resize\", this.handleResize);\n  },\n  beforeUnmount() {\n    this.cleanup();\n    window.removeEventListener(\"resize\", this.handleResize);\n  },\n  methods: {\n    initThree() {\n      const container = this.$refs.container;\n      const width = container.clientWidth;\n      const height = container.clientHeight;\n\n      // Scene\n      this.scene = new THREE.Scene();\n      this.scene.background = new THREE.Color(0xf0f0f0);\n\n      // Camera\n      this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);\n      this.camera.position.z = 2;\n\n      // Renderer\n      this.renderer = new THREE.WebGLRenderer({\n        antialias: true\n      });\n      this.renderer.setSize(width, height);\n      container.appendChild(this.renderer.domElement);\n\n      // Controls\n      this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n      this.controls.enableDamping = true;\n      this.controls.dampingFactor = 0.05;\n      this.controls.autoRotate = true;\n      this.controls.autoRotateSpeed = 2.0;\n\n      // Lights\n      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);\n      this.scene.add(ambientLight);\n      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n      directionalLight.position.set(5, 5, 5);\n      this.scene.add(directionalLight);\n      const backLight = new THREE.DirectionalLight(0xffffff, 0.5);\n      backLight.position.set(-5, -5, -5);\n      this.scene.add(backLight);\n      const textureLoader = new THREE.TextureLoader();\n      if (this.model3D) {\n        this.loadModel();\n      } else {\n        // Check if we have front+back images (new format) or single image (legacy format)\n        const has2Images = this.imageFront && this.imageBack;\n        if (has2Images) {\n          if (this.shape === \"cylinder\") {\n            this.createCylinder(textureLoader);\n          } else if (this.shape === \"pillow\") {\n            this.createPillow(textureLoader);\n          } else if (this.shape === \"exact\") {\n            this.createExactShape(textureLoader);\n          } else {\n            this.loadAndCreateCubeWith3Images(textureLoader);\n          }\n        } else if (this.image) {\n          this.loadAndCreateCubeWithSingleImage(textureLoader);\n        } else {\n          console.error(\"No image or model provided\");\n        }\n      }\n      this.animate();\n    },\n    loadModel() {\n      const loader = new GLTFLoader();\n      loader.load(this.model3D, gltf => {\n        this.model = gltf.scene;\n\n        // Center the model\n        const box = new THREE.Box3().setFromObject(this.model);\n        const center = box.getCenter(new THREE.Vector3());\n        const size = box.getSize(new THREE.Vector3());\n        const maxDim = Math.max(size.x, size.y, size.z);\n        const scale = 1.5 / maxDim;\n        this.model.scale.setScalar(scale);\n        this.model.position.sub(center.multiplyScalar(scale));\n        this.scene.add(this.model);\n      }, () => {\n        // console.log((xhr.loaded / xhr.total * 100) + '% loaded');\n      }, error => {\n        console.error(\"An error happened loading the model:\", error);\n      });\n    },\n    loadAndCreateCubeWithSingleImage(textureLoader) {\n      textureLoader.load(this.image, texture => {\n        const geometry = new THREE.BoxGeometry(1, 1, 1);\n        const material = new THREE.MeshStandardMaterial({\n          map: texture\n        });\n        this.cube = new THREE.Mesh(geometry, material);\n        this.scene.add(this.cube);\n      }, undefined, err => {\n        console.error(\"Error loading texture:\", err);\n      });\n    },\n    createCylinder(textureLoader) {\n      const texturePromises = [this.loadTexture(textureLoader, this.imageFront), this.loadTexture(textureLoader, this.imageBack)];\n      Promise.all(texturePromises).then(([frontTexture, backTexture]) => {\n        // CylinderGeometry(radiusTop, radiusBottom, height, radialSegments)\n        const geometry = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 32);\n\n        // We need to map front texture to one half and back texture to the other half\n        // This is tricky with standard Cylinder mapping.\n        // A simpler approach is to use two half-cylinders or just map front to the whole thing if back is not critical for rotation continuity.\n        // Better approach: Create a canvas, draw front and back side-by-side, and use that as texture.\n\n        // For now, let's use a simple approach: Front texture wraps around.\n        // Or better: Use a Box but with cylinder-like smoothing? No.\n\n        // Let's try the Canvas approach to merge images\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = 1024;\n        canvas.height = 512;\n        const ctx = canvas.getContext(\"2d\");\n        const img1 = frontTexture.image;\n        const img2 = backTexture.image;\n\n        // Draw front on left half, back on right half\n        ctx.drawImage(img1, 0, 0, 512, 512);\n        ctx.drawImage(img2, 512, 0, 512, 512);\n        const mergedTexture = new THREE.CanvasTexture(canvas);\n        mergedTexture.colorSpace = THREE.SRGBColorSpace;\n        const material = new THREE.MeshStandardMaterial({\n          map: mergedTexture\n        });\n        this.cube = new THREE.Mesh(geometry, material);\n\n        // Rotate to show front first\n        this.cube.rotation.y = -Math.PI / 2;\n        this.scene.add(this.cube);\n      });\n    },\n    createPillow(textureLoader) {\n      const texturePromises = [this.loadTexture(textureLoader, this.imageFront), this.loadTexture(textureLoader, this.imageBack)];\n      Promise.all(texturePromises).then(([frontTexture, backTexture]) => {\n        // Create a box with many segments to manipulate vertices\n        const geometry = new THREE.BoxGeometry(0.7, 1.0, 0.2, 10, 10, 2);\n\n        // Access position attribute\n        const positionAttribute = geometry.attributes.position;\n        const vertex = new THREE.Vector3();\n        for (let i = 0; i < positionAttribute.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, i);\n\n          // Logic to \"pinch\" the edges (z-axis)\n          // If x is near edge or y is near edge, reduce z\n          const xFactor = Math.abs(vertex.x) / 0.35; // 0 to 1\n          const yFactor = Math.abs(vertex.y) / 0.5; // 0 to 1\n\n          // Pinch edges: reduce Z thickness as we get closer to edges\n          // Simple formula: z *= (1 - x^2) * (1 - y^2)\n          // But we want the center to be puffy.\n\n          // Only modify Z if it's not 0 (to keep center plane if any)\n          if (Math.abs(vertex.z) > 0.01) {\n            // Puffiness factor\n            const puff = Math.cos(xFactor * Math.PI * 0.4) * Math.cos(yFactor * Math.PI * 0.4);\n            vertex.z *= 0.2 + 1.5 * puff;\n          }\n          positionAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);\n        }\n        geometry.computeVertexNormals();\n\n        // Create a combined texture for sides by blending front and back\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = 512;\n        canvas.height = 512;\n        const ctx = canvas.getContext(\"2d\");\n\n        // Draw front image\n        const frontImg = frontTexture.image;\n        ctx.drawImage(frontImg, 0, 0, 256, 512);\n\n        // Draw back image blended or side by side\n        const backImg = backTexture.image;\n        ctx.globalAlpha = 0.5; // Blend back with front for sides\n        ctx.drawImage(backImg, 0, 0, 256, 512);\n        ctx.globalAlpha = 1.0;\n\n        // Draw back on the right half for wrapping effect\n        ctx.drawImage(backImg, 256, 0, 256, 512);\n        const sideTexture = new THREE.CanvasTexture(canvas);\n        sideTexture.colorSpace = THREE.SRGBColorSpace;\n        sideTexture.wrapS = THREE.RepeatWrapping;\n        sideTexture.wrapT = THREE.RepeatWrapping;\n        const materials = [new THREE.MeshStandardMaterial({\n          map: sideTexture\n        }),\n        // Right\n        new THREE.MeshStandardMaterial({\n          map: sideTexture\n        }),\n        // Left\n        new THREE.MeshStandardMaterial({\n          color: 0xcccccc\n        }),\n        // Top\n        new THREE.MeshStandardMaterial({\n          color: 0xcccccc\n        }),\n        // Bottom\n        new THREE.MeshStandardMaterial({\n          map: frontTexture\n        }),\n        // Front\n        new THREE.MeshStandardMaterial({\n          map: backTexture\n        }) // Back\n        ];\n        this.cube = new THREE.Mesh(geometry, materials);\n        this.scene.add(this.cube);\n      });\n    },\n    createExactShape(textureLoader) {\n      const img = new Image();\n      img.crossOrigin = \"Anonymous\";\n      img.src = this.imageFront || this.image;\n      img.onload = () => {\n        // 1. Draw image to canvas to analyze alpha\n        const canvas = document.createElement(\"canvas\");\n        const size = 256; // Resolution for shape analysis\n        canvas.width = size;\n        canvas.height = size;\n        const ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(img, 0, 0, size, size);\n        const imageData = ctx.getImageData(0, 0, size, size);\n        const data = imageData.data;\n\n        // 2. Find contour points\n        const points = this.getContour(data, size, size);\n        if (points.length < 3) {\n          console.warn(\"Could not determine shape, falling back to box\");\n          this.loadAndCreateCubeWith3Images(textureLoader);\n          return;\n        }\n\n        // 3. Create Shape\n        const shape = new THREE.Shape(points);\n\n        // 4. Extrude\n        const extrudeSettings = {\n          depth: 0.2,\n          // Thickness\n          bevelEnabled: true,\n          bevelThickness: 0.02,\n          bevelSize: 0.01,\n          bevelSegments: 3\n        };\n        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);\n\n        // 5. Fix UV Mapping\n        // The default UVs for ExtrudeGeometry are planar on Z, but we need to map 0..1 based on bounding box\n        geometry.computeBoundingBox();\n        const min = geometry.boundingBox.min;\n        const max = geometry.boundingBox.max;\n        const range = new THREE.Vector3().subVectors(max, min);\n        const uvAttribute = geometry.attributes.uv;\n        const posAttribute = geometry.attributes.position;\n        for (let i = 0; i < posAttribute.count; i++) {\n          const x = posAttribute.getX(i);\n          const y = posAttribute.getY(i);\n          // Map x,y to 0..1\n          const u = (x - min.x) / range.x;\n          const v = (y - min.y) / range.y;\n          uvAttribute.setXY(i, u, v);\n        }\n\n        // 6. Load Textures\n        const texturePromises = [this.loadTexture(textureLoader, this.imageFront), this.loadTexture(textureLoader, this.imageBack)];\n        Promise.all(texturePromises).then(([frontTexture]) => {\n          const materials = [new THREE.MeshStandardMaterial({\n            color: 0xcccccc\n          }),\n          // Side\n          new THREE.MeshStandardMaterial({\n            map: frontTexture\n          }) // Front\n          ];\n\n          // ExtrudeGeometry materials: [side, front/back]\n          // But wait, ExtrudeGeometry usually has 2 groups: 0 for sides, 1 for caps (front/back)\n          // We want front to have frontTexture, back to have backTexture.\n          // This is hard with single ExtrudeGeometry.\n          // Workaround: Use 2 materials, but front and back will share the same material (index 1).\n          // So we might see front image on back (mirrored).\n          // To fix this properly, we'd need to split the geometry or use MultiMaterial with custom face groups.\n          // For now, let's just use the front texture for both caps.\n\n          this.cube = new THREE.Mesh(geometry, materials);\n\n          // Center the mesh\n          geometry.center();\n          this.scene.add(this.cube);\n        });\n      };\n    },\n    getContour(data, width, height) {\n      // Simple Moore-Neighbor Tracing or just scanning\n      // Since we want a robust shape, let's do a \"Convex Hull\" style scan first\n      // Scan each row, find min X and max X\n\n      const leftProfile = [];\n      const rightProfile = [];\n      for (let y = 0; y < height; y++) {\n        let minX = -1;\n        let maxX = -1;\n        for (let x = 0; x < width; x++) {\n          const alpha = data[(y * width + x) * 4 + 3];\n          if (alpha > 50) {\n            if (minX === -1) minX = x;\n            maxX = x;\n          }\n        }\n        if (minX !== -1) {\n          // Normalize coordinates to -0.5 to 0.5 range (approx)\n          // Y is inverted in canvas (0 at top), Three.js (0 at bottom usually, but Shape uses 2D)\n          // Let's map 0..size to -1..1\n          const ny = 1 - y / height * 2;\n          const nxMin = minX / width * 2 - 1;\n          const nxMax = maxX / width * 2 - 1;\n\n          // Simplify: only add point if it changes significantly?\n          // For now, add all (or skip every N)\n          if (y % 2 === 0) {\n            leftProfile.push(new THREE.Vector2(nxMin, ny));\n            rightProfile.push(new THREE.Vector2(nxMax, ny));\n          }\n        }\n      }\n\n      // Combine profiles: Left (top to bottom) -> Right (bottom to top)\n      // leftProfile is ordered top-to-bottom (y=1 to y=-1)\n      // rightProfile is ordered top-to-bottom\n\n      // We want counter-clockwise order\n      // Start top-left, go down left side, cross to bottom-right, go up right side, close top\n\n      const points = [];\n\n      // Add left profile\n      points.push(...leftProfile);\n\n      // Add right profile in reverse (bottom to top)\n      for (let i = rightProfile.length - 1; i >= 0; i--) {\n        points.push(rightProfile[i]);\n      }\n\n      // Close shape\n      if (points.length > 0) {\n        points.push(points[0]);\n      }\n      return points;\n    },\n    loadAndCreateCubeWith3Images(textureLoader) {\n      // Load front and back images (required), side, top, and bottom optional\n      const texturePromises = [this.loadTexture(textureLoader, this.imageFront), this.loadTexture(textureLoader, this.imageBack), this.imageSide ? this.loadTexture(textureLoader, this.imageSide) : Promise.resolve(null), this.imageTop ? this.loadTexture(textureLoader, this.imageTop) : Promise.resolve(null), this.imageBottom ? this.loadTexture(textureLoader, this.imageBottom) : Promise.resolve(null)];\n      Promise.all(texturePromises).then(([frontTexture, backTexture, sideTexture, topTexture, bottomTexture]) => {\n        // Realistic packet dimensions: width x height x depth\n        // Typically product packets are taller than wide\n        const geometry = new THREE.BoxGeometry(0.6, 1.2, 0.3);\n\n        // Gray material for edges (top, bottom, left, right if no side image)\n        const grayMaterial = new THREE.MeshStandardMaterial({\n          color: 0xd0d0d0,\n          roughness: 0.7\n        });\n\n        // Create material array for 6 faces:\n        // [right(0), left(1), top(2), bottom(3), front(4), back(5)]\n        const materials = [];\n\n        // Left and right faces (use side image if available, else gray)\n        if (sideTexture) {\n          materials.push(new THREE.MeshStandardMaterial({\n            map: sideTexture\n          })); // right (0)\n          materials.push(new THREE.MeshStandardMaterial({\n            map: sideTexture\n          })); // left (1)\n        } else {\n          materials.push(grayMaterial.clone()); // right (0)\n          materials.push(grayMaterial.clone()); // left (1)\n        }\n\n        // Top and bottom faces (use separate images if available, else gray)\n        if (topTexture) {\n          materials.push(new THREE.MeshStandardMaterial({\n            map: topTexture\n          })); // top (2)\n        } else {\n          materials.push(grayMaterial.clone()); // top (2)\n        }\n        if (bottomTexture) {\n          materials.push(new THREE.MeshStandardMaterial({\n            map: bottomTexture\n          })); // bottom (3)\n        } else {\n          materials.push(grayMaterial.clone()); // bottom (3)\n        }\n\n        // Front and back faces (required)\n        materials.push(new THREE.MeshStandardMaterial({\n          map: frontTexture\n        })); // front (4)\n        materials.push(new THREE.MeshStandardMaterial({\n          map: backTexture\n        })); // back (5)\n\n        this.cube = new THREE.Mesh(geometry, materials);\n        this.scene.add(this.cube);\n      }).catch(err => {\n        console.error(\"Error loading textures:\", err);\n      });\n    },\n    loadTexture(textureLoader, imagePath) {\n      return new Promise((resolve, reject) => {\n        textureLoader.load(imagePath, texture => resolve(texture), undefined, err => reject(err));\n      });\n    },\n    animate() {\n      this.animationId = requestAnimationFrame(this.animate);\n      if (this.controls) {\n        this.controls.update();\n      }\n      if (this.renderer && this.scene && this.camera) {\n        this.renderer.render(this.scene, this.camera);\n      }\n    },\n    handleResize() {\n      if (!this.$refs.container) return;\n      const width = this.$refs.container.clientWidth;\n      const height = this.$refs.container.clientHeight;\n      if (this.camera) {\n        this.camera.aspect = width / height;\n        this.camera.updateProjectionMatrix();\n      }\n      if (this.renderer) {\n        this.renderer.setSize(width, height);\n      }\n    },\n    cleanup() {\n      if (this.animationId) cancelAnimationFrame(this.animationId);\n      if (this.renderer) {\n        this.renderer.dispose();\n        if (this.$refs.container && this.renderer.domElement) {\n          this.$refs.container.removeChild(this.renderer.domElement);\n        }\n      }\n      if (this.cube) {\n        this.cube.geometry.dispose();\n        if (Array.isArray(this.cube.material)) {\n          this.cube.material.forEach(m => m.dispose());\n        } else {\n          this.cube.material.dispose();\n        }\n      }\n      if (this.model) {\n        this.scene.remove(this.model);\n      }\n      if (this.controls) {\n        this.controls.dispose();\n      }\n    }\n  }\n};","map":{"version":3,"names":["THREE","GLTFLoader","OrbitControls","name","props","image","type","String","required","imageFront","imageSide","imageBack","imageTop","imageBottom","model3D","shape","default","data","mounted","scene","camera","renderer","cube","model","controls","animationId","initThree","window","addEventListener","handleResize","beforeUnmount","cleanup","removeEventListener","methods","container","$refs","width","clientWidth","height","clientHeight","Scene","background","Color","PerspectiveCamera","position","z","WebGLRenderer","antialias","setSize","appendChild","domElement","enableDamping","dampingFactor","autoRotate","autoRotateSpeed","ambientLight","AmbientLight","add","directionalLight","DirectionalLight","set","backLight","textureLoader","TextureLoader","loadModel","has2Images","createCylinder","createPillow","createExactShape","loadAndCreateCubeWith3Images","loadAndCreateCubeWithSingleImage","console","error","animate","loader","load","gltf","box","Box3","setFromObject","center","getCenter","Vector3","size","getSize","maxDim","Math","max","x","y","scale","setScalar","sub","multiplyScalar","texture","geometry","BoxGeometry","material","MeshStandardMaterial","map","Mesh","undefined","err","texturePromises","loadTexture","Promise","all","then","frontTexture","backTexture","CylinderGeometry","canvas","document","createElement","ctx","getContext","img1","img2","drawImage","mergedTexture","CanvasTexture","colorSpace","SRGBColorSpace","rotation","PI","positionAttribute","attributes","vertex","i","count","fromBufferAttribute","xFactor","abs","yFactor","puff","cos","setXYZ","computeVertexNormals","frontImg","backImg","globalAlpha","sideTexture","wrapS","RepeatWrapping","wrapT","materials","color","img","Image","crossOrigin","src","onload","imageData","getImageData","points","getContour","length","warn","Shape","extrudeSettings","depth","bevelEnabled","bevelThickness","bevelSize","bevelSegments","ExtrudeGeometry","computeBoundingBox","min","boundingBox","range","subVectors","uvAttribute","uv","posAttribute","getX","getY","u","v","setXY","leftProfile","rightProfile","minX","maxX","alpha","ny","nxMin","nxMax","push","Vector2","resolve","topTexture","bottomTexture","grayMaterial","roughness","clone","catch","imagePath","reject","requestAnimationFrame","update","render","aspect","updateProjectionMatrix","cancelAnimationFrame","dispose","removeChild","Array","isArray","forEach","m","remove"],"sources":["C:\\Users\\LENOVO\\Music\\OneDrive\\Pictures\\distribution-agency-project\\frontend\\src\\components\\ThreeDBox.vue"],"sourcesContent":["<template>\n  <div ref=\"container\" class=\"three-container\"></div>\n</template>\n\n<script>\nimport * as THREE from \"three\";\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\n\nexport default {\n  name: \"ThreeDBox\",\n  props: {\n    image: {\n      type: String,\n      required: false,\n    },\n    imageFront: {\n      type: String,\n      required: false,\n    },\n    imageSide: {\n      type: String,\n      required: false,\n    },\n    imageBack: {\n      type: String,\n      required: false,\n    },\n    imageTop: {\n      type: String,\n      required: false,\n    },\n    imageBottom: {\n      type: String,\n      required: false,\n    },\n    model3D: {\n      type: String,\n      required: false,\n    },\n    shape: {\n      type: String,\n      default: \"box\", // box, pillow, cylinder\n    },\n  },\n  data() {\n    return {\n      // We don't want Vue to make these reactive because Three.js objects are complex\n      // and Vue's proxying can interfere with internal properties like modelViewMatrix\n    };\n  },\n  mounted() {\n    // Store Three.js objects as non-reactive properties on the instance\n    this.scene = null;\n    this.camera = null;\n    this.renderer = null;\n    this.cube = null;\n    this.model = null;\n    this.controls = null;\n    this.animationId = null;\n\n    this.initThree();\n    window.addEventListener(\"resize\", this.handleResize);\n  },\n  beforeUnmount() {\n    this.cleanup();\n    window.removeEventListener(\"resize\", this.handleResize);\n  },\n  methods: {\n    initThree() {\n      const container = this.$refs.container;\n      const width = container.clientWidth;\n      const height = container.clientHeight;\n\n      // Scene\n      this.scene = new THREE.Scene();\n      this.scene.background = new THREE.Color(0xf0f0f0);\n\n      // Camera\n      this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);\n      this.camera.position.z = 2;\n\n      // Renderer\n      this.renderer = new THREE.WebGLRenderer({ antialias: true });\n      this.renderer.setSize(width, height);\n      container.appendChild(this.renderer.domElement);\n\n      // Controls\n      this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n      this.controls.enableDamping = true;\n      this.controls.dampingFactor = 0.05;\n      this.controls.autoRotate = true;\n      this.controls.autoRotateSpeed = 2.0;\n\n      // Lights\n      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);\n      this.scene.add(ambientLight);\n\n      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n      directionalLight.position.set(5, 5, 5);\n      this.scene.add(directionalLight);\n\n      const backLight = new THREE.DirectionalLight(0xffffff, 0.5);\n      backLight.position.set(-5, -5, -5);\n      this.scene.add(backLight);\n\n      const textureLoader = new THREE.TextureLoader();\n\n      if (this.model3D) {\n        this.loadModel();\n      } else {\n        // Check if we have front+back images (new format) or single image (legacy format)\n        const has2Images = this.imageFront && this.imageBack;\n\n        if (has2Images) {\n          if (this.shape === \"cylinder\") {\n            this.createCylinder(textureLoader);\n          } else if (this.shape === \"pillow\") {\n            this.createPillow(textureLoader);\n          } else if (this.shape === \"exact\") {\n            this.createExactShape(textureLoader);\n          } else {\n            this.loadAndCreateCubeWith3Images(textureLoader);\n          }\n        } else if (this.image) {\n          this.loadAndCreateCubeWithSingleImage(textureLoader);\n        } else {\n          console.error(\"No image or model provided\");\n        }\n      }\n\n      this.animate();\n    },\n\n    loadModel() {\n      const loader = new GLTFLoader();\n      loader.load(\n        this.model3D,\n        (gltf) => {\n          this.model = gltf.scene;\n\n          // Center the model\n          const box = new THREE.Box3().setFromObject(this.model);\n          const center = box.getCenter(new THREE.Vector3());\n          const size = box.getSize(new THREE.Vector3());\n\n          const maxDim = Math.max(size.x, size.y, size.z);\n          const scale = 1.5 / maxDim;\n          this.model.scale.setScalar(scale);\n\n          this.model.position.sub(center.multiplyScalar(scale));\n\n          this.scene.add(this.model);\n        },\n        () => {\n          // console.log((xhr.loaded / xhr.total * 100) + '% loaded');\n        },\n        (error) => {\n          console.error(\"An error happened loading the model:\", error);\n        }\n      );\n    },\n\n    loadAndCreateCubeWithSingleImage(textureLoader) {\n      textureLoader.load(\n        this.image,\n        (texture) => {\n          const geometry = new THREE.BoxGeometry(1, 1, 1);\n          const material = new THREE.MeshStandardMaterial({ map: texture });\n          this.cube = new THREE.Mesh(geometry, material);\n          this.scene.add(this.cube);\n        },\n        undefined,\n        (err) => {\n          console.error(\"Error loading texture:\", err);\n        }\n      );\n    },\n\n    createCylinder(textureLoader) {\n      const texturePromises = [\n        this.loadTexture(textureLoader, this.imageFront),\n        this.loadTexture(textureLoader, this.imageBack),\n      ];\n\n      Promise.all(texturePromises).then(([frontTexture, backTexture]) => {\n        // CylinderGeometry(radiusTop, radiusBottom, height, radialSegments)\n        const geometry = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 32);\n\n        // We need to map front texture to one half and back texture to the other half\n        // This is tricky with standard Cylinder mapping.\n        // A simpler approach is to use two half-cylinders or just map front to the whole thing if back is not critical for rotation continuity.\n        // Better approach: Create a canvas, draw front and back side-by-side, and use that as texture.\n\n        // For now, let's use a simple approach: Front texture wraps around.\n        // Or better: Use a Box but with cylinder-like smoothing? No.\n\n        // Let's try the Canvas approach to merge images\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = 1024;\n        canvas.height = 512;\n        const ctx = canvas.getContext(\"2d\");\n\n        const img1 = frontTexture.image;\n        const img2 = backTexture.image;\n\n        // Draw front on left half, back on right half\n        ctx.drawImage(img1, 0, 0, 512, 512);\n        ctx.drawImage(img2, 512, 0, 512, 512);\n\n        const mergedTexture = new THREE.CanvasTexture(canvas);\n        mergedTexture.colorSpace = THREE.SRGBColorSpace;\n\n        const material = new THREE.MeshStandardMaterial({ map: mergedTexture });\n        this.cube = new THREE.Mesh(geometry, material);\n\n        // Rotate to show front first\n        this.cube.rotation.y = -Math.PI / 2;\n\n        this.scene.add(this.cube);\n      });\n    },\n\n    createPillow(textureLoader) {\n      const texturePromises = [\n        this.loadTexture(textureLoader, this.imageFront),\n        this.loadTexture(textureLoader, this.imageBack),\n      ];\n\n      Promise.all(texturePromises).then(([frontTexture, backTexture]) => {\n        // Create a box with many segments to manipulate vertices\n        const geometry = new THREE.BoxGeometry(0.7, 1.0, 0.2, 10, 10, 2);\n\n        // Access position attribute\n        const positionAttribute = geometry.attributes.position;\n        const vertex = new THREE.Vector3();\n\n        for (let i = 0; i < positionAttribute.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, i);\n\n          // Logic to \"pinch\" the edges (z-axis)\n          // If x is near edge or y is near edge, reduce z\n          const xFactor = Math.abs(vertex.x) / 0.35; // 0 to 1\n          const yFactor = Math.abs(vertex.y) / 0.5; // 0 to 1\n\n          // Pinch edges: reduce Z thickness as we get closer to edges\n          // Simple formula: z *= (1 - x^2) * (1 - y^2)\n          // But we want the center to be puffy.\n\n          // Only modify Z if it's not 0 (to keep center plane if any)\n          if (Math.abs(vertex.z) > 0.01) {\n            // Puffiness factor\n            const puff =\n              Math.cos(xFactor * Math.PI * 0.4) *\n              Math.cos(yFactor * Math.PI * 0.4);\n            vertex.z *= 0.2 + 1.5 * puff;\n          }\n\n          positionAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);\n        }\n\n        geometry.computeVertexNormals();\n\n        // Create a combined texture for sides by blending front and back\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = 512;\n        canvas.height = 512;\n        const ctx = canvas.getContext(\"2d\");\n\n        // Draw front image\n        const frontImg = frontTexture.image;\n        ctx.drawImage(frontImg, 0, 0, 256, 512);\n\n        // Draw back image blended or side by side\n        const backImg = backTexture.image;\n        ctx.globalAlpha = 0.5; // Blend back with front for sides\n        ctx.drawImage(backImg, 0, 0, 256, 512);\n        ctx.globalAlpha = 1.0;\n\n        // Draw back on the right half for wrapping effect\n        ctx.drawImage(backImg, 256, 0, 256, 512);\n\n        const sideTexture = new THREE.CanvasTexture(canvas);\n        sideTexture.colorSpace = THREE.SRGBColorSpace;\n        sideTexture.wrapS = THREE.RepeatWrapping;\n        sideTexture.wrapT = THREE.RepeatWrapping;\n\n        const materials = [\n          new THREE.MeshStandardMaterial({ map: sideTexture }), // Right\n          new THREE.MeshStandardMaterial({ map: sideTexture }), // Left\n          new THREE.MeshStandardMaterial({ color: 0xcccccc }), // Top\n          new THREE.MeshStandardMaterial({ color: 0xcccccc }), // Bottom\n          new THREE.MeshStandardMaterial({ map: frontTexture }), // Front\n          new THREE.MeshStandardMaterial({ map: backTexture }), // Back\n        ];\n\n        this.cube = new THREE.Mesh(geometry, materials);\n        this.scene.add(this.cube);\n      });\n    },\n\n    createExactShape(textureLoader) {\n      const img = new Image();\n      img.crossOrigin = \"Anonymous\";\n      img.src = this.imageFront || this.image;\n\n      img.onload = () => {\n        // 1. Draw image to canvas to analyze alpha\n        const canvas = document.createElement(\"canvas\");\n        const size = 256; // Resolution for shape analysis\n        canvas.width = size;\n        canvas.height = size;\n        const ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(img, 0, 0, size, size);\n\n        const imageData = ctx.getImageData(0, 0, size, size);\n        const data = imageData.data;\n\n        // 2. Find contour points\n        const points = this.getContour(data, size, size);\n\n        if (points.length < 3) {\n          console.warn(\"Could not determine shape, falling back to box\");\n          this.loadAndCreateCubeWith3Images(textureLoader);\n          return;\n        }\n\n        // 3. Create Shape\n        const shape = new THREE.Shape(points);\n\n        // 4. Extrude\n        const extrudeSettings = {\n          depth: 0.2, // Thickness\n          bevelEnabled: true,\n          bevelThickness: 0.02,\n          bevelSize: 0.01,\n          bevelSegments: 3,\n        };\n\n        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);\n\n        // 5. Fix UV Mapping\n        // The default UVs for ExtrudeGeometry are planar on Z, but we need to map 0..1 based on bounding box\n        geometry.computeBoundingBox();\n        const min = geometry.boundingBox.min;\n        const max = geometry.boundingBox.max;\n        const range = new THREE.Vector3().subVectors(max, min);\n\n        const uvAttribute = geometry.attributes.uv;\n        const posAttribute = geometry.attributes.position;\n\n        for (let i = 0; i < posAttribute.count; i++) {\n          const x = posAttribute.getX(i);\n          const y = posAttribute.getY(i);\n          // Map x,y to 0..1\n          const u = (x - min.x) / range.x;\n          const v = (y - min.y) / range.y;\n          uvAttribute.setXY(i, u, v);\n        }\n\n        // 6. Load Textures\n        const texturePromises = [\n          this.loadTexture(textureLoader, this.imageFront),\n          this.loadTexture(textureLoader, this.imageBack),\n        ];\n\n        Promise.all(texturePromises).then(([frontTexture]) => {\n          const materials = [\n            new THREE.MeshStandardMaterial({ color: 0xcccccc }), // Side\n            new THREE.MeshStandardMaterial({ map: frontTexture }), // Front\n          ];\n\n          // ExtrudeGeometry materials: [side, front/back]\n          // But wait, ExtrudeGeometry usually has 2 groups: 0 for sides, 1 for caps (front/back)\n          // We want front to have frontTexture, back to have backTexture.\n          // This is hard with single ExtrudeGeometry.\n          // Workaround: Use 2 materials, but front and back will share the same material (index 1).\n          // So we might see front image on back (mirrored).\n          // To fix this properly, we'd need to split the geometry or use MultiMaterial with custom face groups.\n          // For now, let's just use the front texture for both caps.\n\n          this.cube = new THREE.Mesh(geometry, materials);\n\n          // Center the mesh\n          geometry.center();\n\n          this.scene.add(this.cube);\n        });\n      };\n    },\n\n    getContour(data, width, height) {\n      // Simple Moore-Neighbor Tracing or just scanning\n      // Since we want a robust shape, let's do a \"Convex Hull\" style scan first\n      // Scan each row, find min X and max X\n\n      const leftProfile = [];\n      const rightProfile = [];\n\n      for (let y = 0; y < height; y++) {\n        let minX = -1;\n        let maxX = -1;\n\n        for (let x = 0; x < width; x++) {\n          const alpha = data[(y * width + x) * 4 + 3];\n          if (alpha > 50) {\n            if (minX === -1) minX = x;\n            maxX = x;\n          }\n        }\n\n        if (minX !== -1) {\n          // Normalize coordinates to -0.5 to 0.5 range (approx)\n          // Y is inverted in canvas (0 at top), Three.js (0 at bottom usually, but Shape uses 2D)\n          // Let's map 0..size to -1..1\n          const ny = 1 - (y / height) * 2;\n          const nxMin = (minX / width) * 2 - 1;\n          const nxMax = (maxX / width) * 2 - 1;\n\n          // Simplify: only add point if it changes significantly?\n          // For now, add all (or skip every N)\n          if (y % 2 === 0) {\n            leftProfile.push(new THREE.Vector2(nxMin, ny));\n            rightProfile.push(new THREE.Vector2(nxMax, ny));\n          }\n        }\n      }\n\n      // Combine profiles: Left (top to bottom) -> Right (bottom to top)\n      // leftProfile is ordered top-to-bottom (y=1 to y=-1)\n      // rightProfile is ordered top-to-bottom\n\n      // We want counter-clockwise order\n      // Start top-left, go down left side, cross to bottom-right, go up right side, close top\n\n      const points = [];\n\n      // Add left profile\n      points.push(...leftProfile);\n\n      // Add right profile in reverse (bottom to top)\n      for (let i = rightProfile.length - 1; i >= 0; i--) {\n        points.push(rightProfile[i]);\n      }\n\n      // Close shape\n      if (points.length > 0) {\n        points.push(points[0]);\n      }\n\n      return points;\n    },\n\n    loadAndCreateCubeWith3Images(textureLoader) {\n      // Load front and back images (required), side, top, and bottom optional\n      const texturePromises = [\n        this.loadTexture(textureLoader, this.imageFront),\n        this.loadTexture(textureLoader, this.imageBack),\n        this.imageSide\n          ? this.loadTexture(textureLoader, this.imageSide)\n          : Promise.resolve(null),\n        this.imageTop\n          ? this.loadTexture(textureLoader, this.imageTop)\n          : Promise.resolve(null),\n        this.imageBottom\n          ? this.loadTexture(textureLoader, this.imageBottom)\n          : Promise.resolve(null),\n      ];\n\n      Promise.all(texturePromises)\n        .then(\n          ([\n            frontTexture,\n            backTexture,\n            sideTexture,\n            topTexture,\n            bottomTexture,\n          ]) => {\n            // Realistic packet dimensions: width x height x depth\n            // Typically product packets are taller than wide\n            const geometry = new THREE.BoxGeometry(0.6, 1.2, 0.3);\n\n            // Gray material for edges (top, bottom, left, right if no side image)\n            const grayMaterial = new THREE.MeshStandardMaterial({\n              color: 0xd0d0d0,\n              roughness: 0.7,\n            });\n\n            // Create material array for 6 faces:\n            // [right(0), left(1), top(2), bottom(3), front(4), back(5)]\n            const materials = [];\n\n            // Left and right faces (use side image if available, else gray)\n            if (sideTexture) {\n              materials.push(\n                new THREE.MeshStandardMaterial({ map: sideTexture })\n              ); // right (0)\n              materials.push(\n                new THREE.MeshStandardMaterial({ map: sideTexture })\n              ); // left (1)\n            } else {\n              materials.push(grayMaterial.clone()); // right (0)\n              materials.push(grayMaterial.clone()); // left (1)\n            }\n\n            // Top and bottom faces (use separate images if available, else gray)\n            if (topTexture) {\n              materials.push(\n                new THREE.MeshStandardMaterial({ map: topTexture })\n              ); // top (2)\n            } else {\n              materials.push(grayMaterial.clone()); // top (2)\n            }\n\n            if (bottomTexture) {\n              materials.push(\n                new THREE.MeshStandardMaterial({ map: bottomTexture })\n              ); // bottom (3)\n            } else {\n              materials.push(grayMaterial.clone()); // bottom (3)\n            }\n\n            // Front and back faces (required)\n            materials.push(\n              new THREE.MeshStandardMaterial({ map: frontTexture })\n            ); // front (4)\n            materials.push(\n              new THREE.MeshStandardMaterial({ map: backTexture })\n            ); // back (5)\n\n            this.cube = new THREE.Mesh(geometry, materials);\n            this.scene.add(this.cube);\n          }\n        )\n        .catch((err) => {\n          console.error(\"Error loading textures:\", err);\n        });\n    },\n\n    loadTexture(textureLoader, imagePath) {\n      return new Promise((resolve, reject) => {\n        textureLoader.load(\n          imagePath,\n          (texture) => resolve(texture),\n          undefined,\n          (err) => reject(err)\n        );\n      });\n    },\n    animate() {\n      this.animationId = requestAnimationFrame(this.animate);\n\n      if (this.controls) {\n        this.controls.update();\n      }\n\n      if (this.renderer && this.scene && this.camera) {\n        this.renderer.render(this.scene, this.camera);\n      }\n    },\n    handleResize() {\n      if (!this.$refs.container) return;\n      const width = this.$refs.container.clientWidth;\n      const height = this.$refs.container.clientHeight;\n\n      if (this.camera) {\n        this.camera.aspect = width / height;\n        this.camera.updateProjectionMatrix();\n      }\n\n      if (this.renderer) {\n        this.renderer.setSize(width, height);\n      }\n    },\n    cleanup() {\n      if (this.animationId) cancelAnimationFrame(this.animationId);\n      if (this.renderer) {\n        this.renderer.dispose();\n        if (this.$refs.container && this.renderer.domElement) {\n          this.$refs.container.removeChild(this.renderer.domElement);\n        }\n      }\n      if (this.cube) {\n        this.cube.geometry.dispose();\n        if (Array.isArray(this.cube.material)) {\n          this.cube.material.forEach((m) => m.dispose());\n        } else {\n          this.cube.material.dispose();\n        }\n      }\n      if (this.model) {\n        this.scene.remove(this.model);\n      }\n      if (this.controls) {\n        this.controls.dispose();\n      }\n    },\n  },\n};\n</script>\n\n<style scoped>\n.three-container {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n</style>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}