{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { EventDispatcher, NeutralToneMapping, Vector2, WebGLRenderer } from 'three';\nimport { $updateEnvironment } from '../features/environment.js';\nimport { $canvas, $tick, $updateSize } from '../model-viewer-base.js';\nimport { clamp, isDebugMode } from '../utilities.js';\nimport { ARRenderer } from './ARRenderer.js';\nimport { CachingGLTFLoader } from './CachingGLTFLoader.js';\nimport { ModelViewerGLTFInstance } from './gltf-instance/ModelViewerGLTFInstance.js';\nimport TextureUtils from './TextureUtils.js';\n// Between 0 and 1: larger means the average responds faster and is less smooth.\nconst DURATION_DECAY = 0.2;\nconst LOW_FRAME_DURATION_MS = 40;\nconst HIGH_FRAME_DURATION_MS = 60;\nconst MAX_AVG_CHANGE_MS = 5;\nconst SCALE_STEPS = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];\nconst DEFAULT_LAST_STEP = 3;\nexport const DEFAULT_POWER_PREFERENCE = 'high-performance';\nconst COMMERCE_EXPOSURE = 1.3;\n/**\n * Registers canvases with Canvas2DRenderingContexts and renders them\n * all in the same WebGLRenderingContext, spitting out textures to apply\n * to the canvases. Creates a fullscreen WebGL canvas that is not added\n * to the DOM, and on each frame, renders each registered canvas on a portion\n * of the WebGL canvas, and applies the texture on the registered canvas.\n *\n * In the future, can use ImageBitmapRenderingContext instead of\n * Canvas2DRenderingContext if supported for cheaper transferring of\n * the texture.\n */\nexport class Renderer extends EventDispatcher {\n  static get singleton() {\n    if (!this._singleton) {\n      this._singleton = new Renderer({\n        powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,\n        debug: isDebugMode()\n      });\n    }\n    return this._singleton;\n  }\n  static resetSingleton() {\n    const elements = this._singleton.dispose();\n    for (const element of elements) {\n      element.disconnectedCallback();\n    }\n    this._singleton = new Renderer({\n      powerPreference: (self.ModelViewerElement || {}).powerPreference || DEFAULT_POWER_PREFERENCE,\n      debug: isDebugMode()\n    });\n    for (const element of elements) {\n      element.connectedCallback();\n    }\n  }\n  get canRender() {\n    return this.threeRenderer != null;\n  }\n  get scaleFactor() {\n    return SCALE_STEPS[this.scaleStep];\n  }\n  set minScale(scale) {\n    let i = 1;\n    while (i < SCALE_STEPS.length) {\n      if (SCALE_STEPS[i] < scale) {\n        break;\n      }\n      ++i;\n    }\n    this.lastStep = i - 1;\n  }\n  constructor(options) {\n    super();\n    this.loader = new CachingGLTFLoader(ModelViewerGLTFInstance);\n    this.width = 0;\n    this.height = 0;\n    this.dpr = 1;\n    this.scenes = new Set();\n    this.multipleScenesVisible = false;\n    this.lastTick = performance.now();\n    this.renderedLastFrame = false;\n    this.scaleStep = 0;\n    this.lastStep = DEFAULT_LAST_STEP;\n    this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    this.onWebGLContextLost = event => {\n      this.dispatchEvent({\n        type: 'contextlost',\n        sourceEvent: event\n      });\n    };\n    this.onWebGLContextRestored = () => {\n      var _a;\n      (_a = this.textureUtils) === null || _a === void 0 ? void 0 : _a.dispose();\n      this.textureUtils = new TextureUtils(this.threeRenderer);\n      for (const scene of this.scenes) {\n        scene.element[$updateEnvironment]();\n      }\n    };\n    this.dpr = window.devicePixelRatio;\n    this.canvas3D = document.createElement('canvas');\n    this.canvas3D.id = 'webgl-canvas';\n    this.canvas3D.classList.add('show');\n    try {\n      this.threeRenderer = new WebGLRenderer({\n        canvas: this.canvas3D,\n        alpha: true,\n        antialias: true,\n        powerPreference: options.powerPreference,\n        preserveDrawingBuffer: true\n      });\n      this.threeRenderer.autoClear = true;\n      this.threeRenderer.setPixelRatio(1); // handle pixel ratio externally\n      this.threeRenderer.debug = {\n        checkShaderErrors: !!options.debug,\n        onShaderError: null\n      };\n      // ACESFilmicToneMapping appears to be the most \"saturated\",\n      // and similar to Filament's gltf-viewer.\n      this.threeRenderer.toneMapping = NeutralToneMapping;\n    } catch (error) {\n      console.warn(error);\n    }\n    this.arRenderer = new ARRenderer(this);\n    this.textureUtils = this.canRender ? new TextureUtils(this.threeRenderer) : null;\n    CachingGLTFLoader.initializeKTX2Loader(this.threeRenderer);\n    this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.addEventListener('webglcontextrestored', this.onWebGLContextRestored);\n    this.updateRendererSize();\n  }\n  registerScene(scene) {\n    this.scenes.add(scene);\n    scene.forceRescale();\n    const size = new Vector2();\n    this.threeRenderer.getSize(size);\n    scene.canvas.width = size.x;\n    scene.canvas.height = size.y;\n    if (this.canRender && this.scenes.size > 0) {\n      this.threeRenderer.setAnimationLoop((time, frame) => this.render(time, frame));\n    }\n  }\n  unregisterScene(scene) {\n    this.scenes.delete(scene);\n    if (this.canvas3D.parentElement === scene.canvas.parentElement) {\n      scene.canvas.parentElement.removeChild(this.canvas3D);\n    }\n    if (this.canRender && this.scenes.size === 0) {\n      this.threeRenderer.setAnimationLoop(null);\n    }\n  }\n  displayCanvas(scene) {\n    return scene.element.modelIsVisible && !this.multipleScenesVisible ? this.canvas3D : scene.element[$canvas];\n  }\n  /**\n   * The function enables an optimization, where when there is only a single\n   * <model-viewer> element, we can use the renderer's 3D canvas directly for\n   * display. Otherwise we need to use the element's 2D canvas and copy the\n   * renderer's result into it.\n   */\n  countVisibleScenes() {\n    const {\n      canvas3D\n    } = this;\n    let visibleScenes = 0;\n    let canvas3DScene = null;\n    for (const scene of this.scenes) {\n      const {\n        element\n      } = scene;\n      if (element.modelIsVisible && scene.externalRenderer == null) {\n        ++visibleScenes;\n      }\n      if (canvas3D.parentElement === scene.canvas.parentElement) {\n        canvas3DScene = scene;\n      }\n    }\n    const multipleScenesVisible = visibleScenes > 1;\n    if (canvas3DScene != null) {\n      const newlyMultiple = multipleScenesVisible && !this.multipleScenesVisible;\n      const disappearing = !canvas3DScene.element.modelIsVisible;\n      if (newlyMultiple || disappearing) {\n        const {\n          width,\n          height\n        } = this.sceneSize(canvas3DScene);\n        this.copyPixels(canvas3DScene, width, height);\n        canvas3D.parentElement.removeChild(canvas3D);\n      }\n    }\n    this.multipleScenesVisible = multipleScenesVisible;\n  }\n  /**\n   * Updates the renderer's size based on the largest scene and any changes to\n   * device pixel ratio.\n   */\n  updateRendererSize() {\n    var _a;\n    const dpr = window.devicePixelRatio;\n    if (dpr !== this.dpr) {\n      // If the device pixel ratio has changed due to page zoom, elements\n      // specified by % width do not fire a resize event even though their CSS\n      // pixel dimensions change, so we force them to update their size here.\n      for (const scene of this.scenes) {\n        const {\n          element\n        } = scene;\n        element[$updateSize](element.getBoundingClientRect());\n      }\n    }\n    // Make the renderer the size of the largest scene\n    let width = 0;\n    let height = 0;\n    for (const scene of this.scenes) {\n      width = Math.max(width, scene.width);\n      height = Math.max(height, scene.height);\n    }\n    if (width === this.width && height === this.height && dpr === this.dpr) {\n      return;\n    }\n    this.width = width;\n    this.height = height;\n    this.dpr = dpr;\n    width = Math.ceil(width * dpr);\n    height = Math.ceil(height * dpr);\n    if (this.canRender) {\n      this.threeRenderer.setSize(width, height, false);\n    }\n    // Each scene's canvas must match the renderer size. In general they can be\n    // larger than the element that contains them, but the overflow is hidden\n    // and only the portion that is shown is copied over.\n    for (const scene of this.scenes) {\n      const {\n        canvas\n      } = scene;\n      canvas.width = width;\n      canvas.height = height;\n      scene.forceRescale();\n      (_a = scene.effectRenderer) === null || _a === void 0 ? void 0 : _a.setSize(width, height);\n    }\n  }\n  updateRendererScale(delta) {\n    const scaleStep = this.scaleStep;\n    this.avgFrameDuration += clamp(DURATION_DECAY * (delta - this.avgFrameDuration), -MAX_AVG_CHANGE_MS, MAX_AVG_CHANGE_MS);\n    if (this.avgFrameDuration > HIGH_FRAME_DURATION_MS) {\n      ++this.scaleStep;\n    } else if (this.avgFrameDuration < LOW_FRAME_DURATION_MS && this.scaleStep > 0) {\n      --this.scaleStep;\n    }\n    this.scaleStep = Math.min(this.scaleStep, this.lastStep);\n    if (scaleStep !== this.scaleStep) {\n      this.avgFrameDuration = (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    }\n  }\n  shouldRender(scene) {\n    if (!scene.shouldRender()) {\n      // The first frame we stop rendering the scene (because it stops moving),\n      // trigger one extra render at full scale.\n      if (scene.scaleStep != 0) {\n        scene.scaleStep = 0;\n        this.rescaleCanvas(scene);\n      } else {\n        return false;\n      }\n    } else if (scene.scaleStep != this.scaleStep) {\n      // Update render scale\n      scene.scaleStep = this.scaleStep;\n      this.rescaleCanvas(scene);\n    }\n    return true;\n  }\n  rescaleCanvas(scene) {\n    const scale = SCALE_STEPS[scene.scaleStep];\n    const width = Math.ceil(this.width / scale);\n    const height = Math.ceil(this.height / scale);\n    const {\n      style\n    } = scene.canvas;\n    style.width = `${width}px`;\n    style.height = `${height}px`;\n    this.canvas3D.style.width = `${width}px`;\n    this.canvas3D.style.height = `${height}px`;\n    const renderedDpr = this.dpr * scale;\n    const reason = scale < 1 ? 'GPU throttling' : this.dpr !== window.devicePixelRatio ? 'No meta viewport tag' : '';\n    scene.element.dispatchEvent(new CustomEvent('render-scale', {\n      detail: {\n        reportedDpr: window.devicePixelRatio,\n        renderedDpr: renderedDpr,\n        minimumDpr: this.dpr * SCALE_STEPS[this.lastStep],\n        pixelWidth: Math.ceil(scene.width * renderedDpr),\n        pixelHeight: Math.ceil(scene.height * renderedDpr),\n        reason: reason\n      }\n    }));\n  }\n  sceneSize(scene) {\n    const {\n      dpr\n    } = this;\n    const scaleFactor = SCALE_STEPS[scene.scaleStep];\n    // We avoid using the Three.js PixelRatio and handle it ourselves here so\n    // that we can do proper rounding and avoid white boundary pixels.\n    const width = Math.min(Math.ceil(scene.width * scaleFactor * dpr), this.canvas3D.width);\n    const height = Math.min(Math.ceil(scene.height * scaleFactor * dpr), this.canvas3D.height);\n    return {\n      width,\n      height\n    };\n  }\n  copyPixels(scene, width, height) {\n    const context2D = scene.context;\n    if (context2D == null) {\n      console.log('could not acquire 2d context');\n      return;\n    }\n    context2D.clearRect(0, 0, width, height);\n    context2D.drawImage(this.canvas3D, 0, 0, width, height, 0, 0, width, height);\n    scene.canvas.classList.add('show');\n  }\n  /**\n   * Returns an array version of this.scenes where the non-visible ones are\n   * first. This allows eager scenes to be rendered before they are visible,\n   * without needing the multi-canvas render path.\n   */\n  orderedScenes() {\n    const scenes = [];\n    for (const visible of [false, true]) {\n      for (const scene of this.scenes) {\n        if (scene.element.modelIsVisible === visible) {\n          scenes.push(scene);\n        }\n      }\n    }\n    return scenes;\n  }\n  get isPresenting() {\n    return this.arRenderer.isPresenting;\n  }\n  /**\n   * This method takes care of updating the element and renderer state based on\n   * the time that has passed since the last rendered frame.\n   */\n  preRender(scene, t, delta) {\n    const {\n      element,\n      exposure,\n      toneMapping\n    } = scene;\n    element[$tick](t, delta);\n    const exposureIsNumber = typeof exposure === 'number' && !Number.isNaN(exposure);\n    const env = element.environmentImage;\n    const sky = element.skyboxImage;\n    const compensateExposure = toneMapping === NeutralToneMapping && (env === 'neutral' || env === 'legacy' || !env && !sky);\n    this.threeRenderer.toneMappingExposure = (exposureIsNumber ? exposure : 1.0) * (compensateExposure ? COMMERCE_EXPOSURE : 1.0);\n  }\n  render(t, frame) {\n    if (frame != null) {\n      this.arRenderer.onWebXRFrame(t, frame);\n      return;\n    }\n    const delta = t - this.lastTick;\n    this.lastTick = t;\n    if (!this.canRender || this.isPresenting) {\n      return;\n    }\n    this.countVisibleScenes();\n    this.updateRendererSize();\n    if (this.renderedLastFrame) {\n      this.updateRendererScale(delta);\n      this.renderedLastFrame = false;\n    }\n    const {\n      canvas3D\n    } = this;\n    for (const scene of this.orderedScenes()) {\n      const {\n        element\n      } = scene;\n      if (!element.loaded || !element.modelIsVisible && scene.renderCount > 0) {\n        continue;\n      }\n      this.preRender(scene, t, delta);\n      if (!this.shouldRender(scene)) {\n        continue;\n      }\n      if (scene.externalRenderer != null) {\n        const camera = scene.getCamera();\n        camera.updateMatrix();\n        const {\n          matrix,\n          projectionMatrix\n        } = camera;\n        const viewMatrix = matrix.elements.slice();\n        const target = scene.getTarget();\n        viewMatrix[12] += target.x;\n        viewMatrix[13] += target.y;\n        viewMatrix[14] += target.z;\n        scene.externalRenderer.render({\n          viewMatrix: viewMatrix,\n          projectionMatrix: projectionMatrix.elements\n        });\n        continue;\n      }\n      if (!element.modelIsVisible && !this.multipleScenesVisible) {\n        // Here we are pre-rendering on the visible canvas, so we must mark the\n        // visible scene dirty to ensure it overwrites us.\n        for (const visibleScene of this.scenes) {\n          if (visibleScene.element.modelIsVisible) {\n            visibleScene.queueRender();\n          }\n        }\n      }\n      const {\n        width,\n        height\n      } = this.sceneSize(scene);\n      scene.renderShadow(this.threeRenderer);\n      // Need to set the render target in order to prevent\n      // clearing the depth from a different buffer\n      this.threeRenderer.setRenderTarget(null);\n      this.threeRenderer.setViewport(0, Math.ceil(this.height * this.dpr) - height, width, height);\n      if (scene.effectRenderer != null) {\n        scene.effectRenderer.render(delta);\n      } else {\n        this.threeRenderer.autoClear = true; // this might get reset by the effectRenderer\n        this.threeRenderer.toneMapping = scene.toneMapping;\n        this.threeRenderer.render(scene, scene.camera);\n      }\n      if (this.multipleScenesVisible || !scene.element.modelIsVisible && scene.renderCount === 0) {\n        this.copyPixels(scene, width, height);\n      } else if (canvas3D.parentElement !== scene.canvas.parentElement) {\n        scene.canvas.parentElement.appendChild(canvas3D);\n        scene.canvas.classList.remove('show');\n      }\n      scene.hasRendered();\n      ++scene.renderCount;\n      this.renderedLastFrame = true;\n    }\n  }\n  dispose() {\n    if (this.textureUtils != null) {\n      this.textureUtils.dispose();\n    }\n    if (this.threeRenderer != null) {\n      this.threeRenderer.dispose();\n    }\n    this.textureUtils = null;\n    this.threeRenderer = null;\n    const elements = [];\n    for (const scene of this.scenes) {\n      elements.push(scene.element);\n    }\n    this.canvas3D.removeEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.removeEventListener('webglcontextrestored', this.onWebGLContextRestored);\n    return elements;\n  }\n}","map":{"version":3,"names":["EventDispatcher","NeutralToneMapping","Vector2","WebGLRenderer","$updateEnvironment","$canvas","$tick","$updateSize","clamp","isDebugMode","ARRenderer","CachingGLTFLoader","ModelViewerGLTFInstance","TextureUtils","DURATION_DECAY","LOW_FRAME_DURATION_MS","HIGH_FRAME_DURATION_MS","MAX_AVG_CHANGE_MS","SCALE_STEPS","DEFAULT_LAST_STEP","DEFAULT_POWER_PREFERENCE","COMMERCE_EXPOSURE","Renderer","singleton","_singleton","powerPreference","self","ModelViewerElement","debug","resetSingleton","elements","dispose","element","disconnectedCallback","connectedCallback","canRender","threeRenderer","scaleFactor","scaleStep","minScale","scale","i","length","lastStep","constructor","options","loader","width","height","dpr","scenes","Set","multipleScenesVisible","lastTick","performance","now","renderedLastFrame","avgFrameDuration","onWebGLContextLost","event","dispatchEvent","type","sourceEvent","onWebGLContextRestored","_a","textureUtils","scene","window","devicePixelRatio","canvas3D","document","createElement","id","classList","add","canvas","alpha","antialias","preserveDrawingBuffer","autoClear","setPixelRatio","checkShaderErrors","onShaderError","toneMapping","error","console","warn","arRenderer","initializeKTX2Loader","addEventListener","updateRendererSize","registerScene","forceRescale","size","getSize","x","y","setAnimationLoop","time","frame","render","unregisterScene","delete","parentElement","removeChild","displayCanvas","modelIsVisible","countVisibleScenes","visibleScenes","canvas3DScene","externalRenderer","newlyMultiple","disappearing","sceneSize","copyPixels","getBoundingClientRect","Math","max","ceil","setSize","effectRenderer","updateRendererScale","delta","min","shouldRender","rescaleCanvas","style","renderedDpr","reason","CustomEvent","detail","reportedDpr","minimumDpr","pixelWidth","pixelHeight","context2D","context","log","clearRect","drawImage","orderedScenes","visible","push","isPresenting","preRender","t","exposure","exposureIsNumber","Number","isNaN","env","environmentImage","sky","skyboxImage","compensateExposure","toneMappingExposure","onWebXRFrame","loaded","renderCount","camera","getCamera","updateMatrix","matrix","projectionMatrix","viewMatrix","slice","target","getTarget","z","visibleScene","queueRender","renderShadow","setRenderTarget","setViewport","appendChild","remove","hasRendered","removeEventListener"],"sources":["../../src/three-components/Renderer.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Event, EventDispatcher, NeutralToneMapping, Vector2, WebGLRenderer} from 'three';\n\nimport {$updateEnvironment} from '../features/environment.js';\nimport {ModelViewerGlobalConfig} from '../features/loading.js';\nimport ModelViewerElementBase, {$canvas, $tick, $updateSize} from '../model-viewer-base.js';\nimport {clamp, isDebugMode} from '../utilities.js';\n\nimport {ARRenderer} from './ARRenderer.js';\nimport {CachingGLTFLoader} from './CachingGLTFLoader.js';\nimport {ModelViewerGLTFInstance} from './gltf-instance/ModelViewerGLTFInstance.js';\nimport {ModelScene} from './ModelScene.js';\nimport TextureUtils from './TextureUtils.js';\n\nexport interface RendererOptions {\n  powerPreference: string;\n  debug?: boolean;\n}\n\nexport interface ContextLostEvent extends Event {\n  type: 'contextlost';\n  sourceEvent: WebGLContextEvent;\n}\n\n// Between 0 and 1: larger means the average responds faster and is less smooth.\nconst DURATION_DECAY = 0.2;\nconst LOW_FRAME_DURATION_MS = 40;\nconst HIGH_FRAME_DURATION_MS = 60;\nconst MAX_AVG_CHANGE_MS = 5;\nconst SCALE_STEPS = [1, 0.79, 0.62, 0.5, 0.4, 0.31, 0.25];\nconst DEFAULT_LAST_STEP = 3;\n\nexport const DEFAULT_POWER_PREFERENCE: string = 'high-performance';\nconst COMMERCE_EXPOSURE = 1.3;\n\n/**\n * Registers canvases with Canvas2DRenderingContexts and renders them\n * all in the same WebGLRenderingContext, spitting out textures to apply\n * to the canvases. Creates a fullscreen WebGL canvas that is not added\n * to the DOM, and on each frame, renders each registered canvas on a portion\n * of the WebGL canvas, and applies the texture on the registered canvas.\n *\n * In the future, can use ImageBitmapRenderingContext instead of\n * Canvas2DRenderingContext if supported for cheaper transferring of\n * the texture.\n */\nexport class Renderer extends\n    EventDispatcher<{contextlost: {sourceEvent: WebGLContextEvent}}> {\n  private static _singleton: Renderer;\n\n  static get singleton() {\n    if (!this._singleton) {\n      this._singleton = new Renderer({\n        powerPreference: (((self as any).ModelViewerElement || {}) as\n                          ModelViewerGlobalConfig)\n                             .powerPreference ||\n            DEFAULT_POWER_PREFERENCE,\n        debug: isDebugMode()\n      });\n    }\n    return this._singleton;\n  }\n\n  static resetSingleton() {\n    const elements = this._singleton.dispose();\n    for (const element of elements) {\n      element.disconnectedCallback();\n    }\n\n    this._singleton = new Renderer({\n      powerPreference:\n          (((self as any).ModelViewerElement || {}) as ModelViewerGlobalConfig)\n              .powerPreference ||\n          DEFAULT_POWER_PREFERENCE,\n      debug: isDebugMode()\n    });\n\n    for (const element of elements) {\n      element.connectedCallback();\n    }\n  }\n\n  public threeRenderer!: WebGLRenderer;\n  public canvas3D: HTMLCanvasElement;\n  public textureUtils: TextureUtils|null;\n  public arRenderer: ARRenderer;\n  public loader = new CachingGLTFLoader(ModelViewerGLTFInstance);\n  public width = 0;\n  public height = 0;\n  public dpr = 1;\n\n  private scenes: Set<ModelScene> = new Set();\n  private multipleScenesVisible = false;\n  private lastTick = performance.now();\n  private renderedLastFrame = false;\n  private scaleStep = 0;\n  private lastStep = DEFAULT_LAST_STEP;\n  private avgFrameDuration =\n      (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n\n  get canRender() {\n    return this.threeRenderer != null;\n  }\n\n  get scaleFactor() {\n    return SCALE_STEPS[this.scaleStep];\n  }\n\n  set minScale(scale: number) {\n    let i = 1;\n    while (i < SCALE_STEPS.length) {\n      if (SCALE_STEPS[i] < scale) {\n        break;\n      }\n      ++i;\n    }\n    this.lastStep = i - 1;\n  }\n\n  constructor(options: RendererOptions) {\n    super();\n\n    this.dpr = window.devicePixelRatio;\n\n    this.canvas3D = document.createElement('canvas');\n    this.canvas3D.id = 'webgl-canvas';\n    this.canvas3D.classList.add('show');\n\n    try {\n      this.threeRenderer = new WebGLRenderer({\n        canvas: this.canvas3D,\n        alpha: true,\n        antialias: true,\n        powerPreference: options.powerPreference as WebGLPowerPreference,\n        preserveDrawingBuffer: true,\n      });\n      this.threeRenderer.autoClear = true;\n      this.threeRenderer.setPixelRatio(1);  // handle pixel ratio externally\n\n      this.threeRenderer.debug = {\n        checkShaderErrors: !!options.debug,\n        onShaderError: null\n      };\n\n      // ACESFilmicToneMapping appears to be the most \"saturated\",\n      // and similar to Filament's gltf-viewer.\n      this.threeRenderer.toneMapping = NeutralToneMapping;\n    } catch (error) {\n      console.warn(error);\n    }\n\n    this.arRenderer = new ARRenderer(this);\n    this.textureUtils =\n        this.canRender ? new TextureUtils(this.threeRenderer) : null;\n    CachingGLTFLoader.initializeKTX2Loader(this.threeRenderer);\n\n    this.canvas3D.addEventListener('webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.addEventListener(\n        'webglcontextrestored', this.onWebGLContextRestored);\n\n    this.updateRendererSize();\n  }\n\n  registerScene(scene: ModelScene) {\n    this.scenes.add(scene);\n\n    scene.forceRescale();\n\n    const size = new Vector2();\n    this.threeRenderer.getSize(size);\n    scene.canvas.width = size.x;\n    scene.canvas.height = size.y;\n\n    if (this.canRender && this.scenes.size > 0) {\n      this.threeRenderer.setAnimationLoop(\n          (time: number, frame?: any) => this.render(time, frame));\n    }\n  }\n\n  unregisterScene(scene: ModelScene) {\n    this.scenes.delete(scene);\n\n    if (this.canvas3D.parentElement === scene.canvas.parentElement) {\n      scene.canvas.parentElement!.removeChild(this.canvas3D);\n    }\n\n    if (this.canRender && this.scenes.size === 0) {\n      this.threeRenderer.setAnimationLoop(null);\n    }\n  }\n\n  displayCanvas(scene: ModelScene): HTMLCanvasElement {\n    return scene.element.modelIsVisible && !this.multipleScenesVisible ?\n        this.canvas3D :\n        scene.element[$canvas];\n  }\n\n  /**\n   * The function enables an optimization, where when there is only a single\n   * <model-viewer> element, we can use the renderer's 3D canvas directly for\n   * display. Otherwise we need to use the element's 2D canvas and copy the\n   * renderer's result into it.\n   */\n  private countVisibleScenes() {\n    const {canvas3D} = this;\n    let visibleScenes = 0;\n    let canvas3DScene = null;\n    for (const scene of this.scenes) {\n      const {element} = scene;\n      if (element.modelIsVisible && scene.externalRenderer == null) {\n        ++visibleScenes;\n      }\n      if (canvas3D.parentElement === scene.canvas.parentElement) {\n        canvas3DScene = scene;\n      }\n    }\n    const multipleScenesVisible = visibleScenes > 1;\n\n    if (canvas3DScene != null) {\n      const newlyMultiple =\n          multipleScenesVisible && !this.multipleScenesVisible;\n      const disappearing = !canvas3DScene.element.modelIsVisible;\n      if (newlyMultiple || disappearing) {\n        const {width, height} = this.sceneSize(canvas3DScene);\n        this.copyPixels(canvas3DScene, width, height);\n        canvas3D.parentElement!.removeChild(canvas3D);\n      }\n    }\n    this.multipleScenesVisible = multipleScenesVisible;\n  }\n\n  /**\n   * Updates the renderer's size based on the largest scene and any changes to\n   * device pixel ratio.\n   */\n  private updateRendererSize() {\n    const dpr = window.devicePixelRatio;\n    if (dpr !== this.dpr) {\n      // If the device pixel ratio has changed due to page zoom, elements\n      // specified by % width do not fire a resize event even though their CSS\n      // pixel dimensions change, so we force them to update their size here.\n      for (const scene of this.scenes) {\n        const {element} = scene;\n        element[$updateSize](element.getBoundingClientRect());\n      }\n    }\n\n    // Make the renderer the size of the largest scene\n    let width = 0;\n    let height = 0;\n    for (const scene of this.scenes) {\n      width = Math.max(width, scene.width);\n      height = Math.max(height, scene.height);\n    }\n\n    if (width === this.width && height === this.height && dpr === this.dpr) {\n      return;\n    }\n    this.width = width;\n    this.height = height;\n    this.dpr = dpr;\n    width = Math.ceil(width * dpr);\n    height = Math.ceil(height * dpr);\n\n    if (this.canRender) {\n      this.threeRenderer.setSize(width, height, false);\n    }\n\n    // Each scene's canvas must match the renderer size. In general they can be\n    // larger than the element that contains them, but the overflow is hidden\n    // and only the portion that is shown is copied over.\n    for (const scene of this.scenes) {\n      const {canvas} = scene;\n      canvas.width = width;\n      canvas.height = height;\n      scene.forceRescale();\n      scene.effectRenderer?.setSize(width, height);\n    }\n  }\n\n  private updateRendererScale(delta: number) {\n    const scaleStep = this.scaleStep;\n\n    this.avgFrameDuration += clamp(\n        DURATION_DECAY * (delta - this.avgFrameDuration),\n        -MAX_AVG_CHANGE_MS,\n        MAX_AVG_CHANGE_MS);\n\n    if (this.avgFrameDuration > HIGH_FRAME_DURATION_MS) {\n      ++this.scaleStep;\n    } else if (\n        this.avgFrameDuration < LOW_FRAME_DURATION_MS && this.scaleStep > 0) {\n      --this.scaleStep;\n    }\n    this.scaleStep = Math.min(this.scaleStep, this.lastStep);\n\n    if (scaleStep !== this.scaleStep) {\n      this.avgFrameDuration =\n          (HIGH_FRAME_DURATION_MS + LOW_FRAME_DURATION_MS) / 2;\n    }\n  }\n\n  private shouldRender(scene: ModelScene): boolean {\n    if (!scene.shouldRender()) {\n      // The first frame we stop rendering the scene (because it stops moving),\n      // trigger one extra render at full scale.\n      if (scene.scaleStep != 0) {\n        scene.scaleStep = 0;\n        this.rescaleCanvas(scene);\n      } else {\n        return false;\n      }\n    } else if (scene.scaleStep != this.scaleStep) {\n      // Update render scale\n      scene.scaleStep = this.scaleStep;\n      this.rescaleCanvas(scene);\n    }\n    return true;\n  }\n\n  private rescaleCanvas(scene: ModelScene) {\n    const scale = SCALE_STEPS[scene.scaleStep];\n    const width = Math.ceil(this.width / scale);\n    const height = Math.ceil(this.height / scale);\n\n    const {style} = scene.canvas;\n    style.width = `${width}px`;\n    style.height = `${height}px`;\n    this.canvas3D.style.width = `${width}px`;\n    this.canvas3D.style.height = `${height}px`;\n\n    const renderedDpr = this.dpr * scale;\n    const reason = scale < 1                 ? 'GPU throttling' :\n        this.dpr !== window.devicePixelRatio ? 'No meta viewport tag' :\n                                               '';\n    scene.element.dispatchEvent(new CustomEvent('render-scale', {\n      detail: {\n        reportedDpr: window.devicePixelRatio,\n        renderedDpr: renderedDpr,\n        minimumDpr: this.dpr * SCALE_STEPS[this.lastStep],\n        pixelWidth: Math.ceil(scene.width * renderedDpr),\n        pixelHeight: Math.ceil(scene.height * renderedDpr),\n        reason: reason\n      }\n    }));\n  }\n\n  private sceneSize(scene: ModelScene) {\n    const {dpr} = this;\n    const scaleFactor = SCALE_STEPS[scene.scaleStep];\n    // We avoid using the Three.js PixelRatio and handle it ourselves here so\n    // that we can do proper rounding and avoid white boundary pixels.\n    const width = Math.min(\n        Math.ceil(scene.width * scaleFactor * dpr), this.canvas3D.width);\n    const height = Math.min(\n        Math.ceil(scene.height * scaleFactor * dpr), this.canvas3D.height);\n    return {width, height};\n  }\n\n  private copyPixels(scene: ModelScene, width: number, height: number) {\n    const context2D = scene.context;\n    if (context2D == null) {\n      console.log('could not acquire 2d context');\n      return;\n    }\n    context2D.clearRect(0, 0, width, height);\n    context2D.drawImage(\n        this.canvas3D, 0, 0, width, height, 0, 0, width, height);\n    scene.canvas.classList.add('show');\n  }\n\n  /**\n   * Returns an array version of this.scenes where the non-visible ones are\n   * first. This allows eager scenes to be rendered before they are visible,\n   * without needing the multi-canvas render path.\n   */\n  private orderedScenes(): Array<ModelScene> {\n    const scenes = [];\n    for (const visible of [false, true]) {\n      for (const scene of this.scenes) {\n        if (scene.element.modelIsVisible === visible) {\n          scenes.push(scene);\n        }\n      }\n    }\n    return scenes;\n  }\n\n  get isPresenting(): boolean {\n    return this.arRenderer.isPresenting;\n  }\n\n  /**\n   * This method takes care of updating the element and renderer state based on\n   * the time that has passed since the last rendered frame.\n   */\n  preRender(scene: ModelScene, t: number, delta: number) {\n    const {element, exposure, toneMapping} = scene;\n\n    element[$tick](t, delta);\n\n    const exposureIsNumber =\n        typeof exposure === 'number' && !Number.isNaN(exposure);\n    const env = element.environmentImage;\n    const sky = element.skyboxImage;\n    const compensateExposure = toneMapping === NeutralToneMapping &&\n        (env === 'neutral' || env === 'legacy' || (!env && !sky));\n    this.threeRenderer.toneMappingExposure =\n        (exposureIsNumber ? exposure : 1.0) *\n        (compensateExposure ? COMMERCE_EXPOSURE : 1.0);\n  }\n\n  render(t: number, frame?: XRFrame) {\n    if (frame != null) {\n      this.arRenderer.onWebXRFrame(t, frame);\n      return;\n    }\n\n    const delta = t - this.lastTick;\n    this.lastTick = t;\n\n    if (!this.canRender || this.isPresenting) {\n      return;\n    }\n\n    this.countVisibleScenes();\n    this.updateRendererSize();\n    if (this.renderedLastFrame) {\n      this.updateRendererScale(delta);\n      this.renderedLastFrame = false;\n    }\n\n    const {canvas3D} = this;\n\n    for (const scene of this.orderedScenes()) {\n      const {element} = scene;\n      if (!element.loaded ||\n          (!element.modelIsVisible && scene.renderCount > 0)) {\n        continue;\n      }\n\n      this.preRender(scene, t, delta);\n\n      if (!this.shouldRender(scene)) {\n        continue;\n      }\n\n      if (scene.externalRenderer != null) {\n        const camera = scene.getCamera();\n        camera.updateMatrix();\n        const {matrix, projectionMatrix} = camera;\n        const viewMatrix = matrix.elements.slice();\n        const target = scene.getTarget();\n        viewMatrix[12] += target.x;\n        viewMatrix[13] += target.y;\n        viewMatrix[14] += target.z;\n\n        scene.externalRenderer.render({\n          viewMatrix: viewMatrix,\n          projectionMatrix: projectionMatrix.elements\n        });\n        continue;\n      }\n\n      if (!element.modelIsVisible && !this.multipleScenesVisible) {\n        // Here we are pre-rendering on the visible canvas, so we must mark the\n        // visible scene dirty to ensure it overwrites us.\n        for (const visibleScene of this.scenes) {\n          if (visibleScene.element.modelIsVisible) {\n            visibleScene.queueRender();\n          }\n        }\n      }\n\n      const {width, height} = this.sceneSize(scene);\n\n      scene.renderShadow(this.threeRenderer);\n\n      // Need to set the render target in order to prevent\n      // clearing the depth from a different buffer\n      this.threeRenderer.setRenderTarget(null);\n      this.threeRenderer.setViewport(\n          0, Math.ceil(this.height * this.dpr) - height, width, height);\n      if (scene.effectRenderer != null) {\n        scene.effectRenderer.render(delta);\n      } else {\n        this.threeRenderer.autoClear =\n            true;  // this might get reset by the effectRenderer\n        this.threeRenderer.toneMapping = scene.toneMapping;\n        this.threeRenderer.render(scene, scene.camera);\n      }\n      if (this.multipleScenesVisible ||\n          (!scene.element.modelIsVisible && scene.renderCount === 0)) {\n        this.copyPixels(scene, width, height);\n      } else if (canvas3D.parentElement !== scene.canvas.parentElement) {\n        scene.canvas.parentElement!.appendChild(canvas3D);\n        scene.canvas.classList.remove('show');\n      }\n\n      scene.hasRendered();\n      ++scene.renderCount;\n      this.renderedLastFrame = true;\n    }\n  }\n\n  dispose(): Array<ModelViewerElementBase> {\n    if (this.textureUtils != null) {\n      this.textureUtils.dispose();\n    }\n\n    if (this.threeRenderer != null) {\n      this.threeRenderer.dispose();\n    }\n\n    this.textureUtils = null;\n    (this as any).threeRenderer = null;\n\n    const elements = [];\n    for (const scene of this.scenes) {\n      elements.push(scene.element);\n    }\n\n    this.canvas3D.removeEventListener(\n        'webglcontextlost', this.onWebGLContextLost);\n    this.canvas3D.removeEventListener(\n        'webglcontextrestored', this.onWebGLContextRestored);\n\n    return elements;\n  }\n\n  onWebGLContextLost = (event: Event) => {\n    this.dispatchEvent(\n        {type: 'contextlost', sourceEvent: event} as ContextLostEvent);\n  };\n\n  onWebGLContextRestored = () => {\n    this.textureUtils?.dispose();\n    this.textureUtils = new TextureUtils(this.threeRenderer);\n    for (const scene of this.scenes) {\n      (scene.element as any)[$updateEnvironment]();\n    }\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}