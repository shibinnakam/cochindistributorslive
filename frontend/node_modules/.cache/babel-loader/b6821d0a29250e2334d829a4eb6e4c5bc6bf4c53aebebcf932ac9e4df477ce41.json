{"ast":null,"code":"import { openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  ref: \"container\",\n  class: \"three-container\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, null, 512 /* NEED_PATCH */);\n}","map":{"version":3,"names":["ref","class","_createElementBlock","_hoisted_1"],"sources":["C:\\Users\\LENOVO\\Music\\OneDrive\\Pictures\\distribution-agency-project\\frontend\\src\\components\\ThreeDBox.vue"],"sourcesContent":["<template>\n  <div ref=\"container\" class=\"three-container\"></div>\n</template>\n\n<script>\nimport * as THREE from \"three\";\n\nexport default {\n  name: \"ThreeDBox\",\n  props: {\n    image: {\n      type: String,\n      required: false,\n    },\n    imageFront: {\n      type: String,\n      required: false,\n    },\n    imageSide: {\n      type: String,\n      required: false,\n    },\n    imageBack: {\n      type: String,\n      required: false,\n    },\n  },\n  data() {\n    return {\n      // We don't want Vue to make these reactive because Three.js objects are complex\n      // and Vue's proxying can interfere with internal properties like modelViewMatrix\n    };\n  },\n  mounted() {\n    // Store Three.js objects as non-reactive properties on the instance\n    this.scene = null;\n    this.camera = null;\n    this.renderer = null;\n    this.cube = null;\n    this.animationId = null;\n\n    this.initThree();\n    window.addEventListener(\"resize\", this.handleResize);\n  },\n  beforeUnmount() {\n    this.cleanup();\n    window.removeEventListener(\"resize\", this.handleResize);\n  },\n  methods: {\n    initThree() {\n      const container = this.$refs.container;\n      const width = container.clientWidth;\n      const height = container.clientHeight;\n\n      // Scene\n      this.scene = new THREE.Scene();\n      this.scene.background = new THREE.Color(0xf0f0f0);\n\n      // Camera\n      this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);\n      this.camera.position.z = 2;\n\n      // Renderer\n      this.renderer = new THREE.WebGLRenderer({ antialias: true });\n      this.renderer.setSize(width, height);\n      container.appendChild(this.renderer.domElement);\n\n      // Lights\n      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);\n      this.scene.add(ambientLight);\n\n      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);\n      directionalLight.position.set(1, 1, 1);\n      this.scene.add(directionalLight);\n\n      const textureLoader = new THREE.TextureLoader();\n\n      // Check if we have 3 images (new format) or single image (legacy format)\n      const has3Images = this.imageFront && this.imageSide && this.imageBack;\n\n      if (has3Images) {\n        this.loadAndCreateCubeWith3Images(textureLoader);\n      } else if (this.image) {\n        this.loadAndCreateCubeWithSingleImage(textureLoader);\n      } else {\n        console.error(\"No image provided\");\n      }\n\n      this.animate();\n    },\n\n    loadAndCreateCubeWithSingleImage(textureLoader) {\n      textureLoader.load(\n        this.image,\n        (texture) => {\n          const geometry = new THREE.BoxGeometry(1, 1, 1);\n          const material = new THREE.MeshStandardMaterial({ map: texture });\n          this.cube = new THREE.Mesh(geometry, material);\n          this.scene.add(this.cube);\n        },\n        undefined,\n        (err) => {\n          console.error(\"Error loading texture:\", err);\n        }\n      );\n    },\n\n    loadAndCreateCubeWith3Images(textureLoader) {\n      const texturePromises = [\n        this.loadTexture(textureLoader, this.imageFront),\n        this.loadTexture(textureLoader, this.imageSide),\n        this.loadTexture(textureLoader, this.imageBack),\n      ];\n\n      Promise.all(texturePromises)\n        .then(([frontTexture, sideTexture, backTexture]) => {\n          const geometry = new THREE.BoxGeometry(1, 1, 1);\n\n          // Default gray material for top and bottom\n          const defaultMaterial = new THREE.MeshStandardMaterial({\n            color: 0xcccccc,\n          });\n\n          // Create material array for 6 faces:\n          // [right(0), left(1), top(2), bottom(3), front(4), back(5)]\n          const materials = [\n            new THREE.MeshStandardMaterial({ map: sideTexture }), // right (0)\n            new THREE.MeshStandardMaterial({ map: sideTexture }), // left (1)\n            defaultMaterial, // top (2)\n            defaultMaterial, // bottom (3)\n            new THREE.MeshStandardMaterial({ map: frontTexture }), // front (4)\n            new THREE.MeshStandardMaterial({ map: backTexture }), // back (5)\n          ];\n\n          this.cube = new THREE.Mesh(geometry, materials);\n          this.scene.add(this.cube);\n        })\n        .catch((err) => {\n          console.error(\"Error loading textures:\", err);\n        });\n    },\n\n    loadTexture(textureLoader, imagePath) {\n      return new Promise((resolve, reject) => {\n        textureLoader.load(\n          imagePath,\n          (texture) => resolve(texture),\n          undefined,\n          (err) => reject(err)\n        );\n      });\n    },\n    animate() {\n      this.animationId = requestAnimationFrame(this.animate);\n\n      if (this.cube) {\n        this.cube.rotation.x += 0.005;\n        this.cube.rotation.y += 0.01;\n      }\n\n      if (this.renderer && this.scene && this.camera) {\n        this.renderer.render(this.scene, this.camera);\n      }\n    },\n    handleResize() {\n      if (!this.$refs.container) return;\n      const width = this.$refs.container.clientWidth;\n      const height = this.$refs.container.clientHeight;\n\n      if (this.camera) {\n        this.camera.aspect = width / height;\n        this.camera.updateProjectionMatrix();\n      }\n\n      if (this.renderer) {\n        this.renderer.setSize(width, height);\n      }\n    },\n    cleanup() {\n      if (this.animationId) cancelAnimationFrame(this.animationId);\n      if (this.renderer) {\n        this.renderer.dispose();\n        if (this.$refs.container && this.renderer.domElement) {\n          this.$refs.container.removeChild(this.renderer.domElement);\n        }\n      }\n      if (this.cube) {\n        this.cube.geometry.dispose();\n        if (Array.isArray(this.cube.material)) {\n          this.cube.material.forEach((m) => m.dispose());\n        } else {\n          this.cube.material.dispose();\n        }\n      }\n    },\n  },\n};\n</script>\n\n<style scoped>\n.three-container {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n</style>\n"],"mappings":";;EACOA,GAAG,EAAC,WAAW;EAACC,KAAK,EAAC;;;uBAA3BC,mBAAA,CAAmD,OAAnDC,UAAmD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}