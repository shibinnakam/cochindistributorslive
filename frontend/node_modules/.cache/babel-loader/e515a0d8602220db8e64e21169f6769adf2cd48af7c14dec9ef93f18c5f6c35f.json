{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BoxGeometry, BufferGeometry, DoubleSide, Float32BufferAttribute, Mesh, PlaneGeometry, Vector2 } from 'three';\nimport { Damper } from './Damper.js';\nconst RADIUS = 0.2;\nconst LINE_WIDTH = 0.03;\nconst MAX_OPACITY = 0.75;\nconst SEGMENTS = 12;\nconst DELTA_PHI = Math.PI / (2 * SEGMENTS);\nconst vector2 = new Vector2();\n/**\n * Adds a quarter-annulus of vertices to the array, centered on cornerX,\n * cornerY.\n */\nconst addCorner = (vertices, cornerX, cornerY) => {\n  let phi = cornerX > 0 ? cornerY > 0 ? 0 : -Math.PI / 2 : cornerY > 0 ? Math.PI / 2 : Math.PI;\n  for (let i = 0; i <= SEGMENTS; ++i) {\n    vertices.push(cornerX + (RADIUS - LINE_WIDTH) * Math.cos(phi), cornerY + (RADIUS - LINE_WIDTH) * Math.sin(phi), 0, cornerX + RADIUS * Math.cos(phi), cornerY + RADIUS * Math.sin(phi), 0);\n    phi += DELTA_PHI;\n  }\n};\n/**\n * This class is a set of two coincident planes. The first is just a cute box\n * outline with rounded corners and damped opacity to indicate the floor extents\n * of a scene. It is purposely larger than the scene's bounding box by RADIUS on\n * all sides so that small scenes are still visible / selectable. Its center is\n * actually carved out by vertices to ensure its fragment shader doesn't add\n * much time.\n *\n * The child plane is a simple plane with the same extents for use in hit\n * testing (translation is triggered when the touch hits the plane, rotation\n * otherwise).\n */\nexport class PlacementBox extends Mesh {\n  constructor(scene, side) {\n    const geometry = new BufferGeometry();\n    const triangles = [];\n    const vertices = [];\n    const {\n      size,\n      boundingBox\n    } = scene;\n    const x = size.x / 2;\n    const y = (side === 'back' ? size.y : size.z) / 2;\n    addCorner(vertices, x, y);\n    addCorner(vertices, -x, y);\n    addCorner(vertices, -x, -y);\n    addCorner(vertices, x, -y);\n    const numVertices = vertices.length / 3;\n    for (let i = 0; i < numVertices - 2; i += 2) {\n      triangles.push(i, i + 1, i + 3, i, i + 3, i + 2);\n    }\n    const i = numVertices - 2;\n    triangles.push(i, i + 1, 1, i, 1, 0);\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setIndex(triangles);\n    super(geometry);\n    this.side = side;\n    const material = this.material;\n    material.side = DoubleSide;\n    material.transparent = true;\n    material.opacity = 0;\n    this.goalOpacity = 0;\n    this.opacityDamper = new Damper();\n    this.hitPlane = new Mesh(new PlaneGeometry(2 * (x + RADIUS), 2 * (y + RADIUS)));\n    this.hitPlane.visible = false;\n    this.hitPlane.material.side = DoubleSide;\n    this.add(this.hitPlane);\n    // The box matches the dimensions of the plane (extra radius all around),\n    // but only the top is expanded by radius, not the bottom.\n    this.hitBox = new Mesh(new BoxGeometry(size.x + 2 * RADIUS, size.y + RADIUS, size.z + 2 * RADIUS));\n    this.hitBox.visible = false;\n    this.hitBox.material.side = DoubleSide;\n    this.add(this.hitBox);\n    boundingBox.getCenter(this.position);\n    switch (side) {\n      case 'bottom':\n        this.rotateX(-Math.PI / 2);\n        this.shadowHeight = boundingBox.min.y;\n        this.position.y = this.shadowHeight;\n        break;\n      case 'back':\n        this.shadowHeight = boundingBox.min.z;\n        this.position.z = this.shadowHeight;\n    }\n    scene.target.add(this);\n    this.hitBox.position.y = (size.y + RADIUS) / 2 + boundingBox.min.y;\n    scene.target.add(this.hitBox);\n    this.offsetHeight = 0;\n  }\n  /**\n   * Get the world hit position if the touch coordinates hit the box, and null\n   * otherwise. Pass the scene in to get access to its raycaster.\n   */\n  getHit(scene, screenX, screenY) {\n    vector2.set(screenX, -screenY);\n    this.hitPlane.visible = true;\n    const hitResult = scene.positionAndNormalFromPoint(vector2, this.hitPlane);\n    this.hitPlane.visible = false;\n    return hitResult == null ? null : hitResult.position;\n  }\n  getExpandedHit(scene, screenX, screenY) {\n    this.hitPlane.scale.set(1000, 1000, 1000);\n    this.hitPlane.updateMatrixWorld();\n    const hitResult = this.getHit(scene, screenX, screenY);\n    this.hitPlane.scale.set(1, 1, 1);\n    return hitResult;\n  }\n  controllerIntersection(scene, controller) {\n    this.hitBox.visible = true;\n    const hitResult = scene.hitFromController(controller, this.hitBox);\n    this.hitBox.visible = false;\n    return hitResult;\n  }\n  /**\n   * Offset the height of the box relative to the bottom of the scene. Positive\n   * is up, so generally only negative values are used.\n   */\n  set offsetHeight(offset) {\n    offset -= 0.001; // push 1 mm below shadow to avoid z-fighting\n    if (this.side === 'back') {\n      this.position.z = this.shadowHeight + offset;\n    } else {\n      this.position.y = this.shadowHeight + offset;\n    }\n  }\n  get offsetHeight() {\n    if (this.side === 'back') {\n      return this.position.z - this.shadowHeight;\n    } else {\n      return this.position.y - this.shadowHeight;\n    }\n  }\n  /**\n   * Set the box's visibility; it will fade in and out.\n   */\n  set show(visible) {\n    this.goalOpacity = visible ? MAX_OPACITY : 0;\n  }\n  /**\n   * Call on each frame with the frame delta to fade the box.\n   */\n  updateOpacity(delta) {\n    const material = this.material;\n    material.opacity = this.opacityDamper.update(material.opacity, this.goalOpacity, delta, 1);\n    this.visible = material.opacity > 0;\n  }\n  /**\n   * Call this to clean up Three's cache when you remove the box.\n   */\n  dispose() {\n    const {\n      geometry,\n      material\n    } = this.hitPlane;\n    geometry.dispose();\n    material.dispose();\n    this.hitBox.geometry.dispose();\n    this.hitBox.material.dispose();\n    this.geometry.dispose();\n    this.material.dispose();\n    this.hitBox.removeFromParent();\n    this.removeFromParent();\n  }\n}","map":{"version":3,"names":["BoxGeometry","BufferGeometry","DoubleSide","Float32BufferAttribute","Mesh","PlaneGeometry","Vector2","Damper","RADIUS","LINE_WIDTH","MAX_OPACITY","SEGMENTS","DELTA_PHI","Math","PI","vector2","addCorner","vertices","cornerX","cornerY","phi","i","push","cos","sin","PlacementBox","constructor","scene","side","geometry","triangles","size","boundingBox","x","y","z","numVertices","length","setAttribute","setIndex","material","transparent","opacity","goalOpacity","opacityDamper","hitPlane","visible","add","hitBox","getCenter","position","rotateX","shadowHeight","min","target","offsetHeight","getHit","screenX","screenY","set","hitResult","positionAndNormalFromPoint","getExpandedHit","scale","updateMatrixWorld","controllerIntersection","controller","hitFromController","offset","show","updateOpacity","delta","update","dispose","removeFromParent"],"sources":["../../src/three-components/PlacementBox.ts"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {BoxGeometry, BufferGeometry, DoubleSide, Float32BufferAttribute, Material, Mesh, MeshBasicMaterial, PlaneGeometry, Vector2, Vector3, XRTargetRaySpace} from 'three';\n\nimport {Damper} from './Damper.js';\nimport {ModelScene} from './ModelScene.js';\nimport {Side} from './Shadow.js';\n\nconst RADIUS = 0.2;\nconst LINE_WIDTH = 0.03;\nconst MAX_OPACITY = 0.75;\nconst SEGMENTS = 12;\nconst DELTA_PHI = Math.PI / (2 * SEGMENTS);\n\nconst vector2 = new Vector2();\n\n/**\n * Adds a quarter-annulus of vertices to the array, centered on cornerX,\n * cornerY.\n */\nconst addCorner =\n    (vertices: Array<number>, cornerX: number, cornerY: number) => {\n      let phi = cornerX > 0 ? (cornerY > 0 ? 0 : -Math.PI / 2) :\n                              (cornerY > 0 ? Math.PI / 2 : Math.PI);\n      for (let i = 0; i <= SEGMENTS; ++i) {\n        vertices.push(\n            cornerX + (RADIUS - LINE_WIDTH) * Math.cos(phi),\n            cornerY + (RADIUS - LINE_WIDTH) * Math.sin(phi),\n            0,\n            cornerX + RADIUS * Math.cos(phi),\n            cornerY + RADIUS * Math.sin(phi),\n            0);\n        phi += DELTA_PHI;\n      }\n    };\n\n/**\n * This class is a set of two coincident planes. The first is just a cute box\n * outline with rounded corners and damped opacity to indicate the floor extents\n * of a scene. It is purposely larger than the scene's bounding box by RADIUS on\n * all sides so that small scenes are still visible / selectable. Its center is\n * actually carved out by vertices to ensure its fragment shader doesn't add\n * much time.\n *\n * The child plane is a simple plane with the same extents for use in hit\n * testing (translation is triggered when the touch hits the plane, rotation\n * otherwise).\n */\nexport class PlacementBox extends Mesh {\n  private hitPlane: Mesh;\n  private hitBox: Mesh;\n  private shadowHeight: number;\n  private side: Side;\n  private goalOpacity: number;\n  private opacityDamper: Damper;\n\n  constructor(scene: ModelScene, side: Side) {\n    const geometry = new BufferGeometry();\n    const triangles: Array<number> = [];\n    const vertices: Array<number> = [];\n    const {size, boundingBox} = scene;\n\n    const x = size.x / 2;\n    const y = (side === 'back' ? size.y : size.z) / 2;\n    addCorner(vertices, x, y);\n    addCorner(vertices, -x, y);\n    addCorner(vertices, -x, -y);\n    addCorner(vertices, x, -y);\n\n    const numVertices = vertices.length / 3;\n    for (let i = 0; i < numVertices - 2; i += 2) {\n      triangles.push(i, i + 1, i + 3, i, i + 3, i + 2);\n    }\n    const i = numVertices - 2;\n    triangles.push(i, i + 1, 1, i, 1, 0);\n\n    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));\n    geometry.setIndex(triangles);\n\n    super(geometry);\n\n    this.side = side;\n    const material = this.material as MeshBasicMaterial;\n    material.side = DoubleSide;\n    material.transparent = true;\n    material.opacity = 0;\n    this.goalOpacity = 0;\n    this.opacityDamper = new Damper();\n\n    this.hitPlane =\n        new Mesh(new PlaneGeometry(2 * (x + RADIUS), 2 * (y + RADIUS)));\n    this.hitPlane.visible = false;\n    (this.hitPlane.material as Material).side = DoubleSide;\n    this.add(this.hitPlane);\n\n    // The box matches the dimensions of the plane (extra radius all around),\n    // but only the top is expanded by radius, not the bottom.\n    this.hitBox = new Mesh(new BoxGeometry(\n        size.x + 2 * RADIUS, size.y + RADIUS, size.z + 2 * RADIUS));\n    this.hitBox.visible = false;\n    (this.hitBox.material as Material).side = DoubleSide;\n    this.add(this.hitBox);\n\n    boundingBox.getCenter(this.position);\n\n    switch (side) {\n      case 'bottom':\n        this.rotateX(-Math.PI / 2);\n        this.shadowHeight = boundingBox.min.y;\n        this.position.y = this.shadowHeight;\n        break;\n      case 'back':\n        this.shadowHeight = boundingBox.min.z;\n        this.position.z = this.shadowHeight;\n    }\n\n    scene.target.add(this);\n    this.hitBox.position.y = (size.y + RADIUS) / 2 + boundingBox.min.y;\n    scene.target.add(this.hitBox);\n    this.offsetHeight = 0;\n  }\n\n  /**\n   * Get the world hit position if the touch coordinates hit the box, and null\n   * otherwise. Pass the scene in to get access to its raycaster.\n   */\n  getHit(scene: ModelScene, screenX: number, screenY: number): Vector3|null {\n    vector2.set(screenX, -screenY);\n    this.hitPlane.visible = true;\n    const hitResult = scene.positionAndNormalFromPoint(vector2, this.hitPlane);\n    this.hitPlane.visible = false;\n    return hitResult == null ? null : hitResult.position;\n  }\n\n  getExpandedHit(scene: ModelScene, screenX: number, screenY: number): Vector3\n      |null {\n    this.hitPlane.scale.set(1000, 1000, 1000);\n    this.hitPlane.updateMatrixWorld();\n    const hitResult = this.getHit(scene, screenX, screenY);\n    this.hitPlane.scale.set(1, 1, 1);\n    return hitResult;\n  }\n\n  controllerIntersection(scene: ModelScene, controller: XRTargetRaySpace) {\n    this.hitBox.visible = true;\n    const hitResult = scene.hitFromController(controller, this.hitBox);\n    this.hitBox.visible = false;\n    return hitResult;\n  }\n\n  /**\n   * Offset the height of the box relative to the bottom of the scene. Positive\n   * is up, so generally only negative values are used.\n   */\n  set offsetHeight(offset: number) {\n    offset -= 0.001;  // push 1 mm below shadow to avoid z-fighting\n    if (this.side === 'back') {\n      this.position.z = this.shadowHeight + offset;\n    } else {\n      this.position.y = this.shadowHeight + offset;\n    }\n  }\n\n  get offsetHeight(): number {\n    if (this.side === 'back') {\n      return this.position.z - this.shadowHeight;\n    } else {\n      return this.position.y - this.shadowHeight;\n    }\n  }\n\n  /**\n   * Set the box's visibility; it will fade in and out.\n   */\n  set show(visible: boolean) {\n    this.goalOpacity = visible ? MAX_OPACITY : 0;\n  }\n\n  /**\n   * Call on each frame with the frame delta to fade the box.\n   */\n  updateOpacity(delta: number) {\n    const material = this.material as MeshBasicMaterial;\n    material.opacity =\n        this.opacityDamper.update(material.opacity, this.goalOpacity, delta, 1);\n    this.visible = material.opacity > 0;\n  }\n\n  /**\n   * Call this to clean up Three's cache when you remove the box.\n   */\n  dispose() {\n    const {geometry, material} = this.hitPlane;\n    geometry.dispose();\n    (material as Material).dispose();\n    this.hitBox.geometry.dispose();\n    (this.hitBox.material as Material).dispose();\n    this.geometry.dispose();\n    (this.material as Material).dispose();\n    this.hitBox.removeFromParent();\n    this.removeFromParent();\n  }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}