{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { HDRJPGLoader } from '@monogrid/gainmap-js';\nimport { BackSide, BoxGeometry, CubeCamera, EquirectangularReflectionMapping, HalfFloatType, LinearSRGBColorSpace, Mesh, NoBlending, NoToneMapping, RGBAFormat, Scene, ShaderMaterial, SRGBColorSpace, TextureLoader, Vector3, WebGLCubeRenderTarget } from 'three';\nimport { RGBELoader } from 'three/examples/jsm/loaders/RGBELoader.js';\nimport { deserializeUrl, timePasses } from '../utilities.js';\nimport EnvironmentScene from './EnvironmentScene.js';\nconst GENERATED_SIGMA = 0.04;\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\nconst HDR_FILE_RE = /\\.hdr(\\.js)?$/;\nexport default class TextureUtils {\n  constructor(threeRenderer) {\n    this.threeRenderer = threeRenderer;\n    this.lottieLoaderUrl = '';\n    this._ldrLoader = null;\n    this._imageLoader = null;\n    this._hdrLoader = null;\n    this._lottieLoader = null;\n    this.generatedEnvironmentMap = null;\n    this.generatedEnvironmentMapAlt = null;\n    this.skyboxCache = new Map();\n    this.blurMaterial = null;\n    this.blurScene = null;\n  }\n  ldrLoader(withCredentials) {\n    if (this._ldrLoader == null) {\n      this._ldrLoader = new TextureLoader();\n    }\n    this._ldrLoader.setWithCredentials(withCredentials);\n    return this._ldrLoader;\n  }\n  imageLoader(withCredentials) {\n    if (this._imageLoader == null) {\n      this._imageLoader = new HDRJPGLoader(this.threeRenderer);\n    }\n    this._imageLoader.setWithCredentials(withCredentials);\n    return this._imageLoader;\n  }\n  hdrLoader(withCredentials) {\n    if (this._hdrLoader == null) {\n      this._hdrLoader = new RGBELoader();\n      this._hdrLoader.setDataType(HalfFloatType);\n    }\n    this._hdrLoader.setWithCredentials(withCredentials);\n    return this._hdrLoader;\n  }\n  async getLottieLoader(withCredentials) {\n    if (this._lottieLoader == null) {\n      const {\n        LottieLoader\n      } = await import(/* webpackIgnore: true */this.lottieLoaderUrl);\n      this._lottieLoader = new LottieLoader();\n    }\n    this._lottieLoader.setWithCredentials(withCredentials);\n    return this._lottieLoader;\n  }\n  async loadImage(url, withCredentials) {\n    const texture = await new Promise((resolve, reject) => this.ldrLoader(withCredentials).load(url, resolve, () => {}, reject));\n    texture.name = url;\n    texture.flipY = false;\n    return texture;\n  }\n  async loadLottie(url, quality, withCredentials) {\n    const loader = await this.getLottieLoader(withCredentials);\n    loader.setQuality(quality);\n    const texture = await new Promise((resolve, reject) => loader.load(url, resolve, () => {}, reject));\n    texture.name = url;\n    return texture;\n  }\n  async loadEquirect(url, withCredentials = false, progressCallback = () => {}) {\n    try {\n      const isHDR = HDR_FILE_RE.test(url);\n      const loader = isHDR ? this.hdrLoader(withCredentials) : this.imageLoader(withCredentials);\n      const texture = await new Promise((resolve, reject) => loader.load(url, result => {\n        const {\n          renderTarget\n        } = result;\n        if (renderTarget != null) {\n          const {\n            texture\n          } = renderTarget;\n          result.dispose(false);\n          resolve(texture);\n        } else {\n          resolve(result);\n        }\n      }, event => {\n        progressCallback(event.loaded / event.total * 0.9);\n      }, reject));\n      progressCallback(1.0);\n      texture.name = url;\n      texture.mapping = EquirectangularReflectionMapping;\n      if (!isHDR) {\n        texture.colorSpace = SRGBColorSpace;\n      }\n      return texture;\n    } finally {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n    }\n  }\n  /**\n   * Returns a { skybox, environmentMap } object with the targets/textures\n   * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n   * is a Texture from a WebGLRenderCubeTarget.\n   */\n  async generateEnvironmentMapAndSkybox(skyboxUrl = null, environmentMapUrl = null, progressCallback = () => {}, withCredentials = false) {\n    const useAltEnvironment = environmentMapUrl !== 'legacy';\n    if (environmentMapUrl === 'legacy' || environmentMapUrl === 'neutral') {\n      environmentMapUrl = null;\n    }\n    environmentMapUrl = deserializeUrl(environmentMapUrl);\n    let skyboxLoads = Promise.resolve(null);\n    let environmentMapLoads;\n    // If we have a skybox URL, attempt to load it as a cubemap\n    if (!!skyboxUrl) {\n      skyboxLoads = this.loadEquirectFromUrl(skyboxUrl, withCredentials, progressCallback);\n    }\n    if (!!environmentMapUrl) {\n      // We have an available environment map URL\n      environmentMapLoads = this.loadEquirectFromUrl(environmentMapUrl, withCredentials, progressCallback);\n    } else if (!!skyboxUrl) {\n      // Fallback to deriving the environment map from an available skybox\n      environmentMapLoads = this.loadEquirectFromUrl(skyboxUrl, withCredentials, progressCallback);\n    } else {\n      // Fallback to generating the environment map\n      environmentMapLoads = useAltEnvironment ? this.loadGeneratedEnvironmentMapAlt() : this.loadGeneratedEnvironmentMap();\n    }\n    const [environmentMap, skybox] = await Promise.all([environmentMapLoads, skyboxLoads]);\n    if (environmentMap == null) {\n      throw new Error('Failed to load environment map.');\n    }\n    return {\n      environmentMap,\n      skybox\n    };\n  }\n  /**\n   * Loads an equirect Texture from a given URL, for use as a skybox.\n   */\n  async loadEquirectFromUrl(url, withCredentials, progressCallback) {\n    if (!this.skyboxCache.has(url)) {\n      const skyboxMapLoads = this.loadEquirect(url, withCredentials, progressCallback);\n      this.skyboxCache.set(url, skyboxMapLoads);\n    }\n    return this.skyboxCache.get(url);\n  }\n  async GenerateEnvironmentMap(scene, name) {\n    await timePasses();\n    const renderer = this.threeRenderer;\n    const cubeTarget = new WebGLCubeRenderTarget(256, {\n      generateMipmaps: false,\n      type: HalfFloatType,\n      format: RGBAFormat,\n      colorSpace: LinearSRGBColorSpace,\n      depthBuffer: true\n    });\n    const cubeCamera = new CubeCamera(0.1, 100, cubeTarget);\n    const generatedEnvironmentMap = cubeCamera.renderTarget.texture;\n    generatedEnvironmentMap.name = name;\n    const outputColorSpace = renderer.outputColorSpace;\n    const toneMapping = renderer.toneMapping;\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputColorSpace = LinearSRGBColorSpace;\n    cubeCamera.update(renderer, scene);\n    this.blurCubemap(cubeTarget, GENERATED_SIGMA);\n    renderer.toneMapping = toneMapping;\n    renderer.outputColorSpace = outputColorSpace;\n    return generatedEnvironmentMap;\n  }\n  /**\n   * Loads a dynamically generated environment map.\n   */\n  async loadGeneratedEnvironmentMap() {\n    if (this.generatedEnvironmentMap == null) {\n      this.generatedEnvironmentMap = this.GenerateEnvironmentMap(new EnvironmentScene('legacy'), 'legacy');\n    }\n    return this.generatedEnvironmentMap;\n  }\n  /**\n   * Loads a dynamically generated environment map, designed to be neutral and\n   * color-preserving. Shows less contrast around the different sides of the\n   * object.\n   */\n  async loadGeneratedEnvironmentMapAlt() {\n    if (this.generatedEnvironmentMapAlt == null) {\n      this.generatedEnvironmentMapAlt = this.GenerateEnvironmentMap(new EnvironmentScene('neutral'), 'neutral');\n    }\n    return this.generatedEnvironmentMapAlt;\n  }\n  blurCubemap(cubeTarget, sigma) {\n    if (this.blurMaterial == null) {\n      this.blurMaterial = this.getBlurShader(MAX_SAMPLES);\n      const box = new BoxGeometry();\n      const blurMesh = new Mesh(box, this.blurMaterial);\n      this.blurScene = new Scene();\n      this.blurScene.add(blurMesh);\n    }\n    const tempTarget = cubeTarget.clone();\n    this.halfblur(cubeTarget, tempTarget, sigma, 'latitudinal');\n    this.halfblur(tempTarget, cubeTarget, sigma, 'longitudinal');\n    // Disposing this target after we're done with it somehow corrupts Safari's\n    // whole graphics driver. It's random, but occurs more frequently on\n    // lower-powered GPUs (macbooks with intel graphics, older iPhones). It goes\n    // beyond just messing up the PMREM, as it also occasionally causes\n    // visible corruption on the canvas and even on the rest of the page.\n    /** tempTarget.dispose(); */\n  }\n  halfblur(targetIn, targetOut, sigmaRadians, direction) {\n    // Number of standard deviations at which to cut off the discrete\n    // approximation.\n    const STANDARD_DEVIATIONS = 3;\n    const pixels = targetIn.width;\n    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n    const weights = [];\n    let sum = 0;\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n      if (i == 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n    const blurUniforms = this.blurMaterial.uniforms;\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n    blurUniforms['dTheta'].value = radiansPerPixel;\n    const cubeCamera = new CubeCamera(0.1, 100, targetOut);\n    cubeCamera.update(this.threeRenderer, this.blurScene);\n  }\n  getBlurShader(maxSamples) {\n    const weights = new Float32Array(maxSamples);\n    const poleAxis = new Vector3(0, 1, 0);\n    const shaderMaterial = new ShaderMaterial({\n      name: 'SphericalGaussianBlur',\n      defines: {\n        'n': maxSamples\n      },\n      uniforms: {\n        'envMap': {\n          value: null\n        },\n        'samples': {\n          value: 1\n        },\n        'weights': {\n          value: weights\n        },\n        'latitudinal': {\n          value: false\n        },\n        'dTheta': {\n          value: 0\n        },\n        'poleAxis': {\n          value: poleAxis\n        }\n      },\n      vertexShader: /* glsl */`\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    `,\n      fragmentShader: /* glsl */`\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      `,\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      side: BackSide\n    });\n    return shaderMaterial;\n  }\n  async dispose() {\n    for (const [, promise] of this.skyboxCache) {\n      const skybox = await promise;\n      skybox.dispose();\n    }\n    if (this.generatedEnvironmentMap != null) {\n      (await this.generatedEnvironmentMap).dispose();\n      this.generatedEnvironmentMap = null;\n    }\n    if (this.generatedEnvironmentMapAlt != null) {\n      (await this.generatedEnvironmentMapAlt).dispose();\n      this.generatedEnvironmentMapAlt = null;\n    }\n    if (this.blurMaterial != null) {\n      this.blurMaterial.dispose();\n    }\n  }\n}","map":{"version":3,"names":["HDRJPGLoader","BackSide","BoxGeometry","CubeCamera","EquirectangularReflectionMapping","HalfFloatType","LinearSRGBColorSpace","Mesh","NoBlending","NoToneMapping","RGBAFormat","Scene","ShaderMaterial","SRGBColorSpace","TextureLoader","Vector3","WebGLCubeRenderTarget","RGBELoader","deserializeUrl","timePasses","EnvironmentScene","GENERATED_SIGMA","MAX_SAMPLES","HDR_FILE_RE","TextureUtils","constructor","threeRenderer","lottieLoaderUrl","_ldrLoader","_imageLoader","_hdrLoader","_lottieLoader","generatedEnvironmentMap","generatedEnvironmentMapAlt","skyboxCache","Map","blurMaterial","blurScene","ldrLoader","withCredentials","setWithCredentials","imageLoader","hdrLoader","setDataType","getLottieLoader","LottieLoader","loadImage","url","texture","Promise","resolve","reject","load","name","flipY","loadLottie","quality","loader","setQuality","loadEquirect","progressCallback","isHDR","test","result","renderTarget","dispose","event","loaded","total","mapping","colorSpace","generateEnvironmentMapAndSkybox","skyboxUrl","environmentMapUrl","useAltEnvironment","skyboxLoads","environmentMapLoads","loadEquirectFromUrl","loadGeneratedEnvironmentMapAlt","loadGeneratedEnvironmentMap","environmentMap","skybox","all","Error","has","skyboxMapLoads","set","get","GenerateEnvironmentMap","scene","renderer","cubeTarget","generateMipmaps","type","format","depthBuffer","cubeCamera","outputColorSpace","toneMapping","update","blurCubemap","sigma","getBlurShader","box","blurMesh","add","tempTarget","clone","halfblur","targetIn","targetOut","sigmaRadians","direction","STANDARD_DEVIATIONS","pixels","width","radiansPerPixel","isFinite","Math","PI","sigmaPixels","samples","floor","console","warn","weights","sum","i","x","weight","exp","push","length","blurUniforms","uniforms","value","maxSamples","Float32Array","poleAxis","shaderMaterial","defines","vertexShader","fragmentShader","blending","depthTest","depthWrite","side","promise"],"sources":["../../src/three-components/TextureUtils.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {GainMapDecoderMaterial, HDRJPGLoader, QuadRenderer} from '@monogrid/gainmap-js';\nimport {BackSide, BoxGeometry, CubeCamera, CubeTexture, DataTexture, EquirectangularReflectionMapping, HalfFloatType, LinearSRGBColorSpace, Loader, Mesh, NoBlending, NoToneMapping, RGBAFormat, Scene, ShaderMaterial, SRGBColorSpace, Texture, TextureLoader, Vector3, WebGLCubeRenderTarget, WebGLRenderer} from 'three';\nimport {RGBELoader} from 'three/examples/jsm/loaders/RGBELoader.js';\n\nimport {deserializeUrl, timePasses} from '../utilities.js';\n\nimport EnvironmentScene from './EnvironmentScene.js';\n\nexport interface EnvironmentMapAndSkybox {\n  environmentMap: Texture;\n  skybox: Texture|null;\n}\n\nconst GENERATED_SIGMA = 0.04;\n// The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\nconst MAX_SAMPLES = 20;\n\nconst HDR_FILE_RE = /\\.hdr(\\.js)?$/;\n\nexport default class TextureUtils {\n  public lottieLoaderUrl = '';\n\n  private _ldrLoader: TextureLoader|null = null;\n  private _imageLoader: HDRJPGLoader|null = null;\n  private _hdrLoader: RGBELoader|null = null;\n  private _lottieLoader: Loader|null = null;\n\n  private generatedEnvironmentMap: Promise<CubeTexture>|null = null;\n  private generatedEnvironmentMapAlt: Promise<CubeTexture>|null = null;\n\n  private skyboxCache = new Map<string, Promise<Texture>>();\n\n  private blurMaterial: ShaderMaterial|null = null;\n  private blurScene: Scene|null = null;\n\n  constructor(private threeRenderer: WebGLRenderer) {\n  }\n\n  private ldrLoader(withCredentials: boolean): TextureLoader {\n    if (this._ldrLoader == null) {\n      this._ldrLoader = new TextureLoader();\n    }\n    this._ldrLoader.setWithCredentials(withCredentials);\n    return this._ldrLoader;\n  }\n\n  private imageLoader(withCredentials: boolean): HDRJPGLoader {\n    if (this._imageLoader == null) {\n      this._imageLoader = new HDRJPGLoader(this.threeRenderer);\n    }\n    this._imageLoader.setWithCredentials(withCredentials);\n    return this._imageLoader;\n  }\n\n  private hdrLoader(withCredentials: boolean): RGBELoader {\n    if (this._hdrLoader == null) {\n      this._hdrLoader = new RGBELoader();\n      this._hdrLoader.setDataType(HalfFloatType);\n    }\n    this._hdrLoader.setWithCredentials(withCredentials);\n    return this._hdrLoader;\n  }\n\n  async getLottieLoader(withCredentials: boolean): Promise<any> {\n    if (this._lottieLoader == null) {\n      const {LottieLoader} =\n          await import(/* webpackIgnore: true */ this.lottieLoaderUrl);\n      this._lottieLoader = new LottieLoader() as Loader;\n    }\n    this._lottieLoader.setWithCredentials(withCredentials);\n    return this._lottieLoader;\n  }\n\n  async loadImage(url: string, withCredentials: boolean): Promise<Texture> {\n    const texture: Texture = await new Promise<Texture>(\n        (resolve, reject) => this.ldrLoader(withCredentials)\n                                 .load(url, resolve, () => {}, reject));\n    texture.name = url;\n    texture.flipY = false;\n\n    return texture;\n  }\n\n  async loadLottie(url: string, quality: number, withCredentials: boolean):\n      Promise<Texture> {\n    const loader = await this.getLottieLoader(withCredentials);\n    loader.setQuality(quality);\n    const texture: Texture = await new Promise<Texture>(\n        (resolve, reject) => loader.load(url, resolve, () => {}, reject));\n    texture.name = url;\n\n    return texture;\n  }\n\n  async loadEquirect(\n      url: string, withCredentials = false,\n      progressCallback: (progress: number) => void = () => {}):\n      Promise<Texture> {\n    try {\n      const isHDR: boolean = HDR_FILE_RE.test(url);\n      const loader = isHDR ? this.hdrLoader(withCredentials) :\n                             this.imageLoader(withCredentials);\n      const texture: Texture = await new Promise<Texture>(\n          (resolve, reject) => loader.load(\n              url,\n              (result) => {\n                const {renderTarget} =\n                    result as QuadRenderer<1016, GainMapDecoderMaterial>;\n                if (renderTarget != null) {\n                  const {texture} = renderTarget;\n                  result.dispose(false);\n                  resolve(texture);\n                } else {\n                  resolve(result as DataTexture);\n                }\n              },\n              (event: {loaded: number, total: number}) => {\n                progressCallback(event.loaded / event.total * 0.9);\n              },\n              reject));\n\n      progressCallback(1.0);\n\n      texture.name = url;\n      texture.mapping = EquirectangularReflectionMapping;\n\n      if (!isHDR) {\n        texture.colorSpace = SRGBColorSpace;\n      }\n\n      return texture;\n\n    } finally {\n      if (progressCallback) {\n        progressCallback(1);\n      }\n    }\n  }\n\n  /**\n   * Returns a { skybox, environmentMap } object with the targets/textures\n   * accordingly. `skybox` is a WebGLRenderCubeTarget, and `environmentMap`\n   * is a Texture from a WebGLRenderCubeTarget.\n   */\n  async generateEnvironmentMapAndSkybox(\n      skyboxUrl: string|null = null, environmentMapUrl: string|null = null,\n      progressCallback: (progress: number) => void = () => {},\n      withCredentials = false): Promise<EnvironmentMapAndSkybox> {\n    const useAltEnvironment = environmentMapUrl !== 'legacy';\n    if (environmentMapUrl === 'legacy' || environmentMapUrl === 'neutral') {\n      environmentMapUrl = null;\n    }\n    environmentMapUrl = deserializeUrl(environmentMapUrl);\n\n    let skyboxLoads: Promise<Texture|null> = Promise.resolve(null);\n    let environmentMapLoads: Promise<Texture>;\n\n    // If we have a skybox URL, attempt to load it as a cubemap\n    if (!!skyboxUrl) {\n      skyboxLoads = this.loadEquirectFromUrl(\n          skyboxUrl, withCredentials, progressCallback);\n    }\n\n    if (!!environmentMapUrl) {\n      // We have an available environment map URL\n      environmentMapLoads = this.loadEquirectFromUrl(\n          environmentMapUrl, withCredentials, progressCallback);\n    } else if (!!skyboxUrl) {\n      // Fallback to deriving the environment map from an available skybox\n      environmentMapLoads = this.loadEquirectFromUrl(\n          skyboxUrl, withCredentials, progressCallback);\n    } else {\n      // Fallback to generating the environment map\n      environmentMapLoads = useAltEnvironment ?\n          this.loadGeneratedEnvironmentMapAlt() :\n          this.loadGeneratedEnvironmentMap();\n    }\n\n    const [environmentMap, skybox] =\n        await Promise.all([environmentMapLoads, skyboxLoads]);\n\n    if (environmentMap == null) {\n      throw new Error('Failed to load environment map.');\n    }\n\n    return {environmentMap, skybox};\n  }\n\n  /**\n   * Loads an equirect Texture from a given URL, for use as a skybox.\n   */\n  private async loadEquirectFromUrl(\n      url: string, withCredentials: boolean,\n      progressCallback: (progress: number) => void): Promise<Texture> {\n    if (!this.skyboxCache.has(url)) {\n      const skyboxMapLoads =\n          this.loadEquirect(url, withCredentials, progressCallback);\n\n      this.skyboxCache.set(url, skyboxMapLoads);\n    }\n\n    return this.skyboxCache.get(url)!;\n  }\n\n  private async GenerateEnvironmentMap(scene: Scene, name: string) {\n    await timePasses();\n\n    const renderer = this.threeRenderer;\n    const cubeTarget = new WebGLCubeRenderTarget(256, {\n      generateMipmaps: false,\n      type: HalfFloatType,\n      format: RGBAFormat,\n      colorSpace: LinearSRGBColorSpace,\n      depthBuffer: true\n    });\n    const cubeCamera = new CubeCamera(0.1, 100, cubeTarget);\n    const generatedEnvironmentMap = cubeCamera.renderTarget.texture;\n    generatedEnvironmentMap.name = name;\n\n    const outputColorSpace = renderer.outputColorSpace;\n    const toneMapping = renderer.toneMapping;\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputColorSpace = LinearSRGBColorSpace;\n\n    cubeCamera.update(renderer, scene);\n\n    this.blurCubemap(cubeTarget, GENERATED_SIGMA);\n\n    renderer.toneMapping = toneMapping;\n    renderer.outputColorSpace = outputColorSpace;\n\n    return generatedEnvironmentMap;\n  }\n\n  /**\n   * Loads a dynamically generated environment map.\n   */\n  private async loadGeneratedEnvironmentMap(): Promise<CubeTexture> {\n    if (this.generatedEnvironmentMap == null) {\n      this.generatedEnvironmentMap =\n          this.GenerateEnvironmentMap(new EnvironmentScene('legacy'), 'legacy');\n    }\n    return this.generatedEnvironmentMap;\n  }\n\n  /**\n   * Loads a dynamically generated environment map, designed to be neutral and\n   * color-preserving. Shows less contrast around the different sides of the\n   * object.\n   */\n  private async loadGeneratedEnvironmentMapAlt(): Promise<CubeTexture> {\n    if (this.generatedEnvironmentMapAlt == null) {\n      this.generatedEnvironmentMapAlt = this.GenerateEnvironmentMap(\n          new EnvironmentScene('neutral'), 'neutral');\n    }\n    return this.generatedEnvironmentMapAlt;\n  }\n\n  private blurCubemap(cubeTarget: WebGLCubeRenderTarget, sigma: number) {\n    if (this.blurMaterial == null) {\n      this.blurMaterial = this.getBlurShader(MAX_SAMPLES);\n      const box = new BoxGeometry();\n      const blurMesh = new Mesh(box, this.blurMaterial!);\n      this.blurScene = new Scene();\n      this.blurScene.add(blurMesh);\n    }\n    const tempTarget = cubeTarget.clone();\n    this.halfblur(cubeTarget, tempTarget, sigma, 'latitudinal');\n    this.halfblur(tempTarget, cubeTarget, sigma, 'longitudinal');\n    // Disposing this target after we're done with it somehow corrupts Safari's\n    // whole graphics driver. It's random, but occurs more frequently on\n    // lower-powered GPUs (macbooks with intel graphics, older iPhones). It goes\n    // beyond just messing up the PMREM, as it also occasionally causes\n    // visible corruption on the canvas and even on the rest of the page.\n    /** tempTarget.dispose(); */\n  }\n\n  private halfblur(\n      targetIn: WebGLCubeRenderTarget, targetOut: WebGLCubeRenderTarget,\n      sigmaRadians: number, direction: 'latitudinal'|'longitudinal') {\n    // Number of standard deviations at which to cut off the discrete\n    // approximation.\n    const STANDARD_DEVIATIONS = 3;\n\n    const pixels = targetIn.width;\n    const radiansPerPixel = isFinite(sigmaRadians) ?\n        Math.PI / (2 * pixels) :\n        2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ?\n        1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) :\n        MAX_SAMPLES;\n\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${\n          sigmaRadians}, is too large and will clip, as it requested ${\n          samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n\n    const weights = [];\n    let sum = 0;\n\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n\n      if (i == 0) {\n        sum += weight;\n\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n\n    const blurUniforms = this.blurMaterial!.uniforms;\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n    blurUniforms['dTheta'].value = radiansPerPixel;\n\n    const cubeCamera = new CubeCamera(0.1, 100, targetOut);\n    cubeCamera.update(this.threeRenderer, this.blurScene!);\n  }\n\n  private getBlurShader(maxSamples: number) {\n    const weights = new Float32Array(maxSamples);\n    const poleAxis = new Vector3(0, 1, 0);\n    const shaderMaterial = new ShaderMaterial({\n\n      name: 'SphericalGaussianBlur',\n\n      defines: {'n': maxSamples},\n\n      uniforms: {\n        'envMap': {value: null},\n        'samples': {value: 1},\n        'weights': {value: weights},\n        'latitudinal': {value: false},\n        'dTheta': {value: 0},\n        'poleAxis': {value: poleAxis}\n      },\n\n      vertexShader: /* glsl */ `\n      \n      varying vec3 vOutputDirection;\n  \n      void main() {\n  \n        vOutputDirection = vec3( position );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  \n      }\n    `,\n\n      fragmentShader: /* glsl */ `\n        varying vec3 vOutputDirection;\n  \n        uniform samplerCube envMap;\n        uniform int samples;\n        uniform float weights[ n ];\n        uniform bool latitudinal;\n        uniform float dTheta;\n        uniform vec3 poleAxis;\n  \n        vec3 getSample( float theta, vec3 axis ) {\n  \n          float cosTheta = cos( theta );\n          // Rodrigues' axis-angle rotation\n          vec3 sampleDirection = vOutputDirection * cosTheta\n            + cross( axis, vOutputDirection ) * sin( theta )\n            + axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n  \n          return vec3( textureCube( envMap, sampleDirection ) );\n  \n        }\n  \n        void main() {\n  \n          vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n  \n          if ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n  \n            axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n  \n          }\n  \n          axis = normalize( axis );\n  \n          gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n          gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n  \n          for ( int i = 1; i < n; i++ ) {\n  \n            if ( i >= samples ) {\n  \n              break;\n  \n            }\n  \n            float theta = dTheta * float( i );\n            gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n            gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n  \n          }\n        }\n      `,\n\n      blending: NoBlending,\n      depthTest: false,\n      depthWrite: false,\n      side: BackSide\n\n    });\n\n    return shaderMaterial;\n  }\n\n  async dispose() {\n    for (const [, promise] of this.skyboxCache) {\n      const skybox = await promise;\n      skybox.dispose();\n    }\n    if (this.generatedEnvironmentMap != null) {\n      (await this.generatedEnvironmentMap).dispose();\n      this.generatedEnvironmentMap = null;\n    }\n    if (this.generatedEnvironmentMapAlt != null) {\n      (await this.generatedEnvironmentMapAlt).dispose();\n      this.generatedEnvironmentMapAlt = null;\n    }\n    if (this.blurMaterial != null) {\n      this.blurMaterial.dispose();\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}