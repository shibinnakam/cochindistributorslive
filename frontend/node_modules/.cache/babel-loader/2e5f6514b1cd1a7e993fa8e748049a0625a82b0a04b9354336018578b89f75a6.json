{"ast":null,"code":"import { openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  ref: \"container\",\n  class: \"three-container\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, null, 512 /* NEED_PATCH */);\n}","map":{"version":3,"names":["ref","class","_createElementBlock","_hoisted_1"],"sources":["C:\\Users\\LENOVO\\Music\\OneDrive\\Pictures\\distribution-agency-project\\frontend\\src\\components\\ThreeDBox.vue"],"sourcesContent":["<template>\n  <div ref=\"container\" class=\"three-container\"></div>\n</template>\n\n<script>\nimport * as THREE from \"three\";\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\n\nexport default {\n  name: \"ThreeDBox\",\n  props: {\n    image: {\n      type: String,\n      required: false,\n    },\n    imageFront: {\n      type: String,\n      required: false,\n    },\n    imageSide: {\n      type: String,\n      required: false,\n    },\n    imageBack: {\n      type: String,\n      required: false,\n    },\n    imageTop: {\n      type: String,\n      required: false,\n    },\n    imageBottom: {\n      type: String,\n      required: false,\n    },\n    model3D: {\n      type: String,\n      required: false,\n    },\n  },\n  data() {\n    return {\n      // We don't want Vue to make these reactive because Three.js objects are complex\n      // and Vue's proxying can interfere with internal properties like modelViewMatrix\n    };\n  },\n  mounted() {\n    // Store Three.js objects as non-reactive properties on the instance\n    this.scene = null;\n    this.camera = null;\n    this.renderer = null;\n    this.cube = null;\n    this.model = null;\n    this.controls = null;\n    this.animationId = null;\n\n    this.initThree();\n    window.addEventListener(\"resize\", this.handleResize);\n  },\n  beforeUnmount() {\n    this.cleanup();\n    window.removeEventListener(\"resize\", this.handleResize);\n  },\n  methods: {\n    initThree() {\n      const container = this.$refs.container;\n      const width = container.clientWidth;\n      const height = container.clientHeight;\n\n      // Scene\n      this.scene = new THREE.Scene();\n      this.scene.background = new THREE.Color(0xf0f0f0);\n\n      // Camera\n      this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);\n      this.camera.position.z = 2;\n\n      // Renderer\n      this.renderer = new THREE.WebGLRenderer({ antialias: true });\n      this.renderer.setSize(width, height);\n      container.appendChild(this.renderer.domElement);\n\n      // Controls\n      this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n      this.controls.enableDamping = true;\n      this.controls.dampingFactor = 0.05;\n      this.controls.autoRotate = true;\n      this.controls.autoRotateSpeed = 2.0;\n\n      // Lights\n      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);\n      this.scene.add(ambientLight);\n\n      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n      directionalLight.position.set(5, 5, 5);\n      this.scene.add(directionalLight);\n\n      const backLight = new THREE.DirectionalLight(0xffffff, 0.5);\n      backLight.position.set(-5, -5, -5);\n      this.scene.add(backLight);\n\n      const textureLoader = new THREE.TextureLoader();\n\n      if (this.model3D) {\n        this.loadModel();\n      } else {\n        // Check if we have front+back images (new format) or single image (legacy format)\n        const has2Images = this.imageFront && this.imageBack;\n\n        if (has2Images) {\n          this.loadAndCreateCubeWith3Images(textureLoader);\n        } else if (this.image) {\n          this.loadAndCreateCubeWithSingleImage(textureLoader);\n        } else {\n          console.error(\"No image or model provided\");\n        }\n      }\n\n      this.animate();\n    },\n\n    loadModel() {\n      const loader = new GLTFLoader();\n      loader.load(\n        this.model3D,\n        (gltf) => {\n          this.model = gltf.scene;\n\n          // Center the model\n          const box = new THREE.Box3().setFromObject(this.model);\n          const center = box.getCenter(new THREE.Vector3());\n          const size = box.getSize(new THREE.Vector3());\n\n          const maxDim = Math.max(size.x, size.y, size.z);\n          const scale = 1.5 / maxDim;\n          this.model.scale.setScalar(scale);\n\n          this.model.position.sub(center.multiplyScalar(scale));\n\n          this.scene.add(this.model);\n        },\n        () => {\n          // console.log((xhr.loaded / xhr.total * 100) + '% loaded');\n        },\n        (error) => {\n          console.error(\"An error happened loading the model:\", error);\n        }\n      );\n    },\n\n    loadAndCreateCubeWithSingleImage(textureLoader) {\n      textureLoader.load(\n        this.image,\n        (texture) => {\n          const geometry = new THREE.BoxGeometry(1, 1, 1);\n          const material = new THREE.MeshStandardMaterial({ map: texture });\n          this.cube = new THREE.Mesh(geometry, material);\n          this.scene.add(this.cube);\n        },\n        undefined,\n        (err) => {\n          console.error(\"Error loading texture:\", err);\n        }\n      );\n    },\n\n    loadAndCreateCubeWith3Images(textureLoader) {\n      // Load front and back images (required), side, top, and bottom optional\n      const texturePromises = [\n        this.loadTexture(textureLoader, this.imageFront),\n        this.loadTexture(textureLoader, this.imageBack),\n        this.imageSide\n          ? this.loadTexture(textureLoader, this.imageSide)\n          : Promise.resolve(null),\n        this.imageTop\n          ? this.loadTexture(textureLoader, this.imageTop)\n          : Promise.resolve(null),\n        this.imageBottom\n          ? this.loadTexture(textureLoader, this.imageBottom)\n          : Promise.resolve(null),\n      ];\n\n      Promise.all(texturePromises)\n        .then(\n          ([\n            frontTexture,\n            backTexture,\n            sideTexture,\n            topTexture,\n            bottomTexture,\n          ]) => {\n            // Realistic packet dimensions: width x height x depth\n            // Typically product packets are taller than wide\n            const geometry = new THREE.BoxGeometry(0.6, 1.2, 0.3);\n\n            // Gray material for edges (top, bottom, left, right if no side image)\n            const grayMaterial = new THREE.MeshStandardMaterial({\n              color: 0xd0d0d0,\n              roughness: 0.7,\n            });\n\n            // Create material array for 6 faces:\n            // [right(0), left(1), top(2), bottom(3), front(4), back(5)]\n            const materials = [];\n\n            // Left and right faces (use side image if available, else gray)\n            if (sideTexture) {\n              materials.push(\n                new THREE.MeshStandardMaterial({ map: sideTexture })\n              ); // right (0)\n              materials.push(\n                new THREE.MeshStandardMaterial({ map: sideTexture })\n              ); // left (1)\n            } else {\n              materials.push(grayMaterial.clone()); // right (0)\n              materials.push(grayMaterial.clone()); // left (1)\n            }\n\n            // Top and bottom faces (use separate images if available, else gray)\n            if (topTexture) {\n              materials.push(\n                new THREE.MeshStandardMaterial({ map: topTexture })\n              ); // top (2)\n            } else {\n              materials.push(grayMaterial.clone()); // top (2)\n            }\n\n            if (bottomTexture) {\n              materials.push(\n                new THREE.MeshStandardMaterial({ map: bottomTexture })\n              ); // bottom (3)\n            } else {\n              materials.push(grayMaterial.clone()); // bottom (3)\n            }\n\n            // Front and back faces (required)\n            materials.push(\n              new THREE.MeshStandardMaterial({ map: frontTexture })\n            ); // front (4)\n            materials.push(\n              new THREE.MeshStandardMaterial({ map: backTexture })\n            ); // back (5)\n\n            this.cube = new THREE.Mesh(geometry, materials);\n            this.scene.add(this.cube);\n          }\n        )\n        .catch((err) => {\n          console.error(\"Error loading textures:\", err);\n        });\n    },\n\n    loadTexture(textureLoader, imagePath) {\n      return new Promise((resolve, reject) => {\n        textureLoader.load(\n          imagePath,\n          (texture) => resolve(texture),\n          undefined,\n          (err) => reject(err)\n        );\n      });\n    },\n    animate() {\n      this.animationId = requestAnimationFrame(this.animate);\n\n      if (this.controls) {\n        this.controls.update();\n      }\n\n      if (this.renderer && this.scene && this.camera) {\n        this.renderer.render(this.scene, this.camera);\n      }\n    },\n    handleResize() {\n      if (!this.$refs.container) return;\n      const width = this.$refs.container.clientWidth;\n      const height = this.$refs.container.clientHeight;\n\n      if (this.camera) {\n        this.camera.aspect = width / height;\n        this.camera.updateProjectionMatrix();\n      }\n\n      if (this.renderer) {\n        this.renderer.setSize(width, height);\n      }\n    },\n    cleanup() {\n      if (this.animationId) cancelAnimationFrame(this.animationId);\n      if (this.renderer) {\n        this.renderer.dispose();\n        if (this.$refs.container && this.renderer.domElement) {\n          this.$refs.container.removeChild(this.renderer.domElement);\n        }\n      }\n      if (this.cube) {\n        this.cube.geometry.dispose();\n        if (Array.isArray(this.cube.material)) {\n          this.cube.material.forEach((m) => m.dispose());\n        } else {\n          this.cube.material.dispose();\n        }\n      }\n      if (this.model) {\n        this.scene.remove(this.model);\n      }\n      if (this.controls) {\n        this.controls.dispose();\n      }\n    },\n  },\n};\n</script>\n\n<style scoped>\n.three-container {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n</style>\n"],"mappings":";;EACOA,GAAG,EAAC,WAAW;EAACC,KAAK,EAAC;;;uBAA3BC,mBAAA,CAAmD,OAAnDC,UAAmD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}