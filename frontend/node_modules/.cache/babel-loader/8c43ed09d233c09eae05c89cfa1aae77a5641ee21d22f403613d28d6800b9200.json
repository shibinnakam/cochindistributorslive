{"ast":null,"code":"import { openBlock as _openBlock, createElementBlock as _createElementBlock } from \"vue\";\nconst _hoisted_1 = {\n  ref: \"container\",\n  class: \"three-container\"\n};\nexport function render(_ctx, _cache, $props, $setup, $data, $options) {\n  return _openBlock(), _createElementBlock(\"div\", _hoisted_1, null, 512 /* NEED_PATCH */);\n}","map":{"version":3,"names":["ref","class","_createElementBlock","_hoisted_1"],"sources":["C:\\Users\\LENOVO\\Music\\OneDrive\\Pictures\\distribution-agency-project\\frontend\\src\\components\\ThreeDBox.vue"],"sourcesContent":["<template>\n  <div ref=\"container\" class=\"three-container\"></div>\n</template>\n\n<script>\nimport * as THREE from \"three\";\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader\";\nimport { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\n\nexport default {\n  name: \"ThreeDBox\",\n  props: {\n    image: {\n      type: String,\n      required: false,\n    },\n    imageFront: {\n      type: String,\n      required: false,\n    },\n    imageSide: {\n      type: String,\n      required: false,\n    },\n    imageBack: {\n      type: String,\n      required: false,\n    },\n    imageTop: {\n      type: String,\n      required: false,\n    },\n    imageBottom: {\n      type: String,\n      required: false,\n    },\n    model3D: {\n      type: String,\n      required: false,\n    },\n    shape: {\n      type: String,\n      default: \"box\", // box, pillow, cylinder\n    },\n  },\n  data() {\n    return {\n      // We don't want Vue to make these reactive because Three.js objects are complex\n      // and Vue's proxying can interfere with internal properties like modelViewMatrix\n    };\n  },\n  mounted() {\n    // Store Three.js objects as non-reactive properties on the instance\n    this.scene = null;\n    this.camera = null;\n    this.renderer = null;\n    this.cube = null;\n    this.model = null;\n    this.controls = null;\n    this.animationId = null;\n\n    this.initThree();\n    window.addEventListener(\"resize\", this.handleResize);\n  },\n  beforeUnmount() {\n    this.cleanup();\n    window.removeEventListener(\"resize\", this.handleResize);\n  },\n  methods: {\n    initThree() {\n      const container = this.$refs.container;\n      const width = container.clientWidth;\n      const height = container.clientHeight;\n\n      // Scene\n      this.scene = new THREE.Scene();\n      this.scene.background = new THREE.Color(0xf0f0f0);\n\n      // Camera\n      this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);\n      this.camera.position.z = 2;\n\n      // Renderer\n      this.renderer = new THREE.WebGLRenderer({ antialias: true });\n      this.renderer.setSize(width, height);\n      container.appendChild(this.renderer.domElement);\n\n      // Controls\n      this.controls = new OrbitControls(this.camera, this.renderer.domElement);\n      this.controls.enableDamping = true;\n      this.controls.dampingFactor = 0.05;\n      this.controls.autoRotate = true;\n      this.controls.autoRotateSpeed = 2.0;\n\n      // Lights\n      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);\n      this.scene.add(ambientLight);\n\n      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);\n      directionalLight.position.set(5, 5, 5);\n      this.scene.add(directionalLight);\n\n      const backLight = new THREE.DirectionalLight(0xffffff, 0.5);\n      backLight.position.set(-5, -5, -5);\n      this.scene.add(backLight);\n\n      const textureLoader = new THREE.TextureLoader();\n\n      if (this.model3D) {\n        this.loadModel();\n      } else {\n        // Check if we have front+back images (new format) or single image (legacy format)\n        const has2Images = this.imageFront && this.imageBack;\n\n        if (has2Images) {\n          if (this.shape === \"cylinder\") {\n            this.createCylinder(textureLoader);\n          } else if (this.shape === \"pillow\") {\n            this.createPillow(textureLoader);\n          } else if (this.shape === \"exact\") {\n            this.createExactShape(textureLoader);\n          } else {\n            this.loadAndCreateCubeWith3Images(textureLoader);\n          }\n        } else if (this.image) {\n          this.loadAndCreateCubeWithSingleImage(textureLoader);\n        } else {\n          console.error(\"No image or model provided\");\n        }\n      }\n\n      this.animate();\n    },\n\n    loadModel() {\n      const loader = new GLTFLoader();\n      loader.load(\n        this.model3D,\n        (gltf) => {\n          this.model = gltf.scene;\n\n          // Center the model\n          const box = new THREE.Box3().setFromObject(this.model);\n          const center = box.getCenter(new THREE.Vector3());\n          const size = box.getSize(new THREE.Vector3());\n\n          const maxDim = Math.max(size.x, size.y, size.z);\n          const scale = 1.5 / maxDim;\n          this.model.scale.setScalar(scale);\n\n          this.model.position.sub(center.multiplyScalar(scale));\n\n          this.scene.add(this.model);\n        },\n        () => {\n          // console.log((xhr.loaded / xhr.total * 100) + '% loaded');\n        },\n        (error) => {\n          console.error(\"An error happened loading the model:\", error);\n        }\n      );\n    },\n\n    loadAndCreateCubeWithSingleImage(textureLoader) {\n      textureLoader.load(\n        this.image,\n        (texture) => {\n          const geometry = new THREE.BoxGeometry(1, 1, 1);\n          const material = new THREE.MeshStandardMaterial({ map: texture });\n          this.cube = new THREE.Mesh(geometry, material);\n          this.scene.add(this.cube);\n        },\n        undefined,\n        (err) => {\n          console.error(\"Error loading texture:\", err);\n        }\n      );\n    },\n\n    createCylinder(textureLoader) {\n      const texturePromises = [\n        this.loadTexture(textureLoader, this.imageFront),\n        this.loadTexture(textureLoader, this.imageBack),\n      ];\n\n      Promise.all(texturePromises).then(([frontTexture, backTexture]) => {\n        // CylinderGeometry(radiusTop, radiusBottom, height, radialSegments)\n        const geometry = new THREE.CylinderGeometry(0.4, 0.4, 1.2, 32);\n\n        // We need to map front texture to one half and back texture to the other half\n        // This is tricky with standard Cylinder mapping.\n        // A simpler approach is to use two half-cylinders or just map front to the whole thing if back is not critical for rotation continuity.\n        // Better approach: Create a canvas, draw front and back side-by-side, and use that as texture.\n\n        // For now, let's use a simple approach: Front texture wraps around.\n        // Or better: Use a Box but with cylinder-like smoothing? No.\n\n        // Let's try the Canvas approach to merge images\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = 1024;\n        canvas.height = 512;\n        const ctx = canvas.getContext(\"2d\");\n\n        const img1 = frontTexture.image;\n        const img2 = backTexture.image;\n\n        // Draw front on left half, back on right half\n        ctx.drawImage(img1, 0, 0, 512, 512);\n        ctx.drawImage(img2, 512, 0, 512, 512);\n\n        const mergedTexture = new THREE.CanvasTexture(canvas);\n        mergedTexture.colorSpace = THREE.SRGBColorSpace;\n\n        const material = new THREE.MeshStandardMaterial({ map: mergedTexture });\n        this.cube = new THREE.Mesh(geometry, material);\n\n        // Rotate to show front first\n        this.cube.rotation.y = -Math.PI / 2;\n\n        this.scene.add(this.cube);\n      });\n    },\n\n    createPillow(textureLoader) {\n      const texturePromises = [\n        this.loadTexture(textureLoader, this.imageFront),\n        this.loadTexture(textureLoader, this.imageBack),\n      ];\n\n      Promise.all(texturePromises).then(([frontTexture, backTexture]) => {\n        // Create a box with many segments to manipulate vertices\n        const geometry = new THREE.BoxGeometry(0.7, 1.0, 0.2, 10, 10, 2);\n\n        // Access position attribute\n        const positionAttribute = geometry.attributes.position;\n        const vertex = new THREE.Vector3();\n\n        for (let i = 0; i < positionAttribute.count; i++) {\n          vertex.fromBufferAttribute(positionAttribute, i);\n\n          // Logic to \"pinch\" the edges (z-axis)\n          // If x is near edge or y is near edge, reduce z\n          const xFactor = Math.abs(vertex.x) / 0.35; // 0 to 1\n          const yFactor = Math.abs(vertex.y) / 0.5; // 0 to 1\n\n          // Pinch edges: reduce Z thickness as we get closer to edges\n          // Simple formula: z *= (1 - x^2) * (1 - y^2)\n          // But we want the center to be puffy.\n\n          // Only modify Z if it's not 0 (to keep center plane if any)\n          if (Math.abs(vertex.z) > 0.01) {\n            // Puffiness factor\n            const puff =\n              Math.cos(xFactor * Math.PI * 0.4) *\n              Math.cos(yFactor * Math.PI * 0.4);\n            vertex.z *= 0.2 + 1.5 * puff;\n          }\n\n          positionAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);\n        }\n\n        geometry.computeVertexNormals();\n\n        // Create a combined texture for sides by blending front and back\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = 512;\n        canvas.height = 512;\n        const ctx = canvas.getContext(\"2d\");\n\n        // Draw front image\n        const frontImg = frontTexture.image;\n        ctx.drawImage(frontImg, 0, 0, 256, 512);\n\n        // Draw back image blended or side by side\n        const backImg = backTexture.image;\n        ctx.globalAlpha = 0.5; // Blend back with front for sides\n        ctx.drawImage(backImg, 0, 0, 256, 512);\n        ctx.globalAlpha = 1.0;\n\n        // Draw back on the right half for wrapping effect\n        ctx.drawImage(backImg, 256, 0, 256, 512);\n\n        const sideTexture = new THREE.CanvasTexture(canvas);\n        sideTexture.colorSpace = THREE.SRGBColorSpace;\n        sideTexture.wrapS = THREE.RepeatWrapping;\n        sideTexture.wrapT = THREE.RepeatWrapping;\n\n        // Create a top/bottom texture by averaging front and back colors\n        const topBottomCanvas = document.createElement(\"canvas\");\n        topBottomCanvas.width = 256;\n        topBottomCanvas.height = 256;\n        const topCtx = topBottomCanvas.getContext(\"2d\");\n\n        // Draw front and back blended for top/bottom\n        topCtx.globalAlpha = 0.5;\n        topCtx.drawImage(frontImg, 0, 0, 256, 256);\n        topCtx.drawImage(backImg, 0, 0, 256, 256);\n        topCtx.globalAlpha = 1.0;\n\n        const topBottomTexture = new THREE.CanvasTexture(topBottomCanvas);\n        topBottomTexture.colorSpace = THREE.SRGBColorSpace;\n\n        const materials = [\n          new THREE.MeshStandardMaterial({ map: sideTexture }), // Right\n          new THREE.MeshStandardMaterial({ map: sideTexture }), // Left\n          new THREE.MeshStandardMaterial({ map: topBottomTexture }), // Top\n          new THREE.MeshStandardMaterial({ map: topBottomTexture }), // Bottom\n          new THREE.MeshStandardMaterial({ map: frontTexture }), // Front\n          new THREE.MeshStandardMaterial({ map: backTexture }), // Back\n        ];\n\n        this.cube = new THREE.Mesh(geometry, materials);\n        this.scene.add(this.cube);\n      });\n    },\n\n    createExactShape(textureLoader) {\n      const img = new Image();\n      img.crossOrigin = \"Anonymous\";\n      img.src = this.imageFront || this.image;\n\n      img.onload = () => {\n        // 1. Draw image to canvas to analyze alpha\n        const canvas = document.createElement(\"canvas\");\n        const size = 256; // Resolution for shape analysis\n        canvas.width = size;\n        canvas.height = size;\n        const ctx = canvas.getContext(\"2d\");\n        ctx.drawImage(img, 0, 0, size, size);\n\n        const imageData = ctx.getImageData(0, 0, size, size);\n        const data = imageData.data;\n\n        // 2. Find contour points\n        const points = this.getContour(data, size, size);\n\n        if (points.length < 3) {\n          console.warn(\"Could not determine shape, falling back to box\");\n          this.loadAndCreateCubeWith3Images(textureLoader);\n          return;\n        }\n\n        // 3. Create Shape\n        const shape = new THREE.Shape(points);\n\n        // 4. Extrude\n        const extrudeSettings = {\n          depth: 0.2, // Thickness\n          bevelEnabled: true,\n          bevelThickness: 0.02,\n          bevelSize: 0.01,\n          bevelSegments: 3,\n        };\n\n        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);\n\n        // 5. Fix UV Mapping\n        // The default UVs for ExtrudeGeometry are planar on Z, but we need to map 0..1 based on bounding box\n        geometry.computeBoundingBox();\n        const min = geometry.boundingBox.min;\n        const max = geometry.boundingBox.max;\n        const range = new THREE.Vector3().subVectors(max, min);\n\n        const uvAttribute = geometry.attributes.uv;\n        const posAttribute = geometry.attributes.position;\n\n        for (let i = 0; i < posAttribute.count; i++) {\n          const x = posAttribute.getX(i);\n          const y = posAttribute.getY(i);\n          // Map x,y to 0..1\n          const u = (x - min.x) / range.x;\n          const v = (y - min.y) / range.y;\n          uvAttribute.setXY(i, u, v);\n        }\n\n        // 6. Load Textures\n        const texturePromises = [\n          this.loadTexture(textureLoader, this.imageFront),\n          this.loadTexture(textureLoader, this.imageBack),\n        ];\n\n        Promise.all(texturePromises).then(([frontTexture]) => {\n          const materials = [\n            new THREE.MeshStandardMaterial({ color: 0xcccccc }), // Side\n            new THREE.MeshStandardMaterial({ map: frontTexture }), // Front\n          ];\n\n          // ExtrudeGeometry materials: [side, front/back]\n          // But wait, ExtrudeGeometry usually has 2 groups: 0 for sides, 1 for caps (front/back)\n          // We want front to have frontTexture, back to have backTexture.\n          // This is hard with single ExtrudeGeometry.\n          // Workaround: Use 2 materials, but front and back will share the same material (index 1).\n          // So we might see front image on back (mirrored).\n          // To fix this properly, we'd need to split the geometry or use MultiMaterial with custom face groups.\n          // For now, let's just use the front texture for both caps.\n\n          this.cube = new THREE.Mesh(geometry, materials);\n\n          // Center the mesh\n          geometry.center();\n\n          this.scene.add(this.cube);\n        });\n      };\n    },\n\n    getContour(data, width, height) {\n      // Simple Moore-Neighbor Tracing or just scanning\n      // Since we want a robust shape, let's do a \"Convex Hull\" style scan first\n      // Scan each row, find min X and max X\n\n      const leftProfile = [];\n      const rightProfile = [];\n\n      for (let y = 0; y < height; y++) {\n        let minX = -1;\n        let maxX = -1;\n\n        for (let x = 0; x < width; x++) {\n          const alpha = data[(y * width + x) * 4 + 3];\n          if (alpha > 50) {\n            if (minX === -1) minX = x;\n            maxX = x;\n          }\n        }\n\n        if (minX !== -1) {\n          // Normalize coordinates to -0.5 to 0.5 range (approx)\n          // Y is inverted in canvas (0 at top), Three.js (0 at bottom usually, but Shape uses 2D)\n          // Let's map 0..size to -1..1\n          const ny = 1 - (y / height) * 2;\n          const nxMin = (minX / width) * 2 - 1;\n          const nxMax = (maxX / width) * 2 - 1;\n\n          // Simplify: only add point if it changes significantly?\n          // For now, add all (or skip every N)\n          if (y % 2 === 0) {\n            leftProfile.push(new THREE.Vector2(nxMin, ny));\n            rightProfile.push(new THREE.Vector2(nxMax, ny));\n          }\n        }\n      }\n\n      // Combine profiles: Left (top to bottom) -> Right (bottom to top)\n      // leftProfile is ordered top-to-bottom (y=1 to y=-1)\n      // rightProfile is ordered top-to-bottom\n\n      // We want counter-clockwise order\n      // Start top-left, go down left side, cross to bottom-right, go up right side, close top\n\n      const points = [];\n\n      // Add left profile\n      points.push(...leftProfile);\n\n      // Add right profile in reverse (bottom to top)\n      for (let i = rightProfile.length - 1; i >= 0; i--) {\n        points.push(rightProfile[i]);\n      }\n\n      // Close shape\n      if (points.length > 0) {\n        points.push(points[0]);\n      }\n\n      return points;\n    },\n\n    loadAndCreateCubeWith3Images(textureLoader) {\n      // Load front and back images (required), side, top, and bottom optional\n      const texturePromises = [\n        this.loadTexture(textureLoader, this.imageFront),\n        this.loadTexture(textureLoader, this.imageBack),\n        this.imageSide\n          ? this.loadTexture(textureLoader, this.imageSide)\n          : Promise.resolve(null),\n        this.imageTop\n          ? this.loadTexture(textureLoader, this.imageTop)\n          : Promise.resolve(null),\n        this.imageBottom\n          ? this.loadTexture(textureLoader, this.imageBottom)\n          : Promise.resolve(null),\n      ];\n\n      Promise.all(texturePromises)\n        .then(\n          ([\n            frontTexture,\n            backTexture,\n            sideTexture,\n            topTexture,\n            bottomTexture,\n          ]) => {\n            // Realistic packet dimensions: width x height x depth\n            // Typically product packets are taller than wide\n            const geometry = new THREE.BoxGeometry(0.6, 1.2, 0.3);\n\n            // Gray material for edges (top, bottom, left, right if no side image)\n            const grayMaterial = new THREE.MeshStandardMaterial({\n              color: 0xd0d0d0,\n              roughness: 0.7,\n            });\n\n            // Create material array for 6 faces:\n            // [right(0), left(1), top(2), bottom(3), front(4), back(5)]\n            const materials = [];\n\n            // Left and right faces (use side image if available, else gray)\n            if (sideTexture) {\n              materials.push(\n                new THREE.MeshStandardMaterial({ map: sideTexture })\n              ); // right (0)\n              materials.push(\n                new THREE.MeshStandardMaterial({ map: sideTexture })\n              ); // left (1)\n            } else {\n              materials.push(grayMaterial.clone()); // right (0)\n              materials.push(grayMaterial.clone()); // left (1)\n            }\n\n            // Top and bottom faces (use separate images if available, else gray)\n            if (topTexture) {\n              materials.push(\n                new THREE.MeshStandardMaterial({ map: topTexture })\n              ); // top (2)\n            } else {\n              materials.push(grayMaterial.clone()); // top (2)\n            }\n\n            if (bottomTexture) {\n              materials.push(\n                new THREE.MeshStandardMaterial({ map: bottomTexture })\n              ); // bottom (3)\n            } else {\n              materials.push(grayMaterial.clone()); // bottom (3)\n            }\n\n            // Front and back faces (required)\n            materials.push(\n              new THREE.MeshStandardMaterial({ map: frontTexture })\n            ); // front (4)\n            materials.push(\n              new THREE.MeshStandardMaterial({ map: backTexture })\n            ); // back (5)\n\n            this.cube = new THREE.Mesh(geometry, materials);\n            this.scene.add(this.cube);\n          }\n        )\n        .catch((err) => {\n          console.error(\"Error loading textures:\", err);\n        });\n    },\n\n    loadTexture(textureLoader, imagePath) {\n      return new Promise((resolve, reject) => {\n        textureLoader.load(\n          imagePath,\n          (texture) => resolve(texture),\n          undefined,\n          (err) => reject(err)\n        );\n      });\n    },\n    animate() {\n      this.animationId = requestAnimationFrame(this.animate);\n\n      if (this.controls) {\n        this.controls.update();\n      }\n\n      if (this.renderer && this.scene && this.camera) {\n        this.renderer.render(this.scene, this.camera);\n      }\n    },\n    handleResize() {\n      if (!this.$refs.container) return;\n      const width = this.$refs.container.clientWidth;\n      const height = this.$refs.container.clientHeight;\n\n      if (this.camera) {\n        this.camera.aspect = width / height;\n        this.camera.updateProjectionMatrix();\n      }\n\n      if (this.renderer) {\n        this.renderer.setSize(width, height);\n      }\n    },\n    cleanup() {\n      if (this.animationId) cancelAnimationFrame(this.animationId);\n      if (this.renderer) {\n        this.renderer.dispose();\n        if (this.$refs.container && this.renderer.domElement) {\n          this.$refs.container.removeChild(this.renderer.domElement);\n        }\n      }\n      if (this.cube) {\n        this.cube.geometry.dispose();\n        if (Array.isArray(this.cube.material)) {\n          this.cube.material.forEach((m) => m.dispose());\n        } else {\n          this.cube.material.dispose();\n        }\n      }\n      if (this.model) {\n        this.scene.remove(this.model);\n      }\n      if (this.controls) {\n        this.controls.dispose();\n      }\n    },\n  },\n};\n</script>\n\n<style scoped>\n.three-container {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n</style>\n"],"mappings":";;EACOA,GAAG,EAAC,WAAW;EAACC,KAAK,EAAC;;;uBAA3BC,mBAAA,CAAmD,OAAnDC,UAAmD","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}