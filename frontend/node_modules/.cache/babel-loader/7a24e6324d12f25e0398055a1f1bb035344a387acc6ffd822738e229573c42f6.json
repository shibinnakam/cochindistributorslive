{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { BoxGeometry, BufferGeometry, EventDispatcher, Line, Matrix4, Mesh, PerspectiveCamera, Quaternion, Vector3 } from 'three';\nimport { XREstimatedLight } from 'three/examples/jsm/webxr/XREstimatedLight.js';\nimport { $currentBackground, $currentEnvironmentMap } from '../features/environment.js';\nimport { assertIsArCandidate } from '../utilities.js';\nimport { Damper } from './Damper.js';\nimport { PlacementBox } from './PlacementBox.js';\nimport { ChangeSource } from './SmoothControls.js';\n// number of initial null pose XRFrames allowed before we post not-tracking\nconst INIT_FRAMES = 30;\n// AR shadow is not user-configurable. This is to pave the way for AR lighting\n// estimation, which will be used once available in WebXR.\nconst AR_SHADOW_INTENSITY = 0.8;\nconst ROTATION_RATE = 1.5;\n// Angle down (towards bottom of screen) from camera center ray to use for hit\n// testing against the floor. This makes placement faster and more intuitive\n// assuming the phone is in portrait mode. This seems to be a reasonable\n// assumption for the start of the session and UI will lack landscape mode to\n// encourage upright use.\nconst HIT_ANGLE_DEG = 20;\nconst SCALE_SNAP = 0.2;\n// For automatic dynamic viewport scaling, don't let the scale drop below this\n// limit.\nconst MIN_VIEWPORT_SCALE = 0.25;\n// Furthest away you can move an object (meters).\nconst MAX_DISTANCE = 10;\n// Damper decay in milliseconds for the headset - screen uses default.\nconst DECAY = 150;\n// Longer controller/hand indicator line (meters).\nconst MAX_LINE_LENGTH = 5;\n// Maximum dimension of rotation indicator box on controller (meters).\nconst BOX_SIZE = 0.1;\nexport const ARStatus = {\n  NOT_PRESENTING: 'not-presenting',\n  SESSION_STARTED: 'session-started',\n  OBJECT_PLACED: 'object-placed',\n  FAILED: 'failed'\n};\nexport const ARTracking = {\n  TRACKING: 'tracking',\n  NOT_TRACKING: 'not-tracking'\n};\nconst vector3 = new Vector3();\nconst quaternion = new Quaternion();\nconst matrix4 = new Matrix4();\nconst hitPosition = new Vector3();\nconst camera = new PerspectiveCamera(45, 1, 0.1, 100);\nconst lineGeometry = new BufferGeometry().setFromPoints([new Vector3(0, 0, 0), new Vector3(0, 0, -1)]);\nconst boxGeometry = new BoxGeometry();\nexport class ARRenderer extends EventDispatcher {\n  constructor(renderer) {\n    super();\n    this.renderer = renderer;\n    this.currentSession = null;\n    this.placeOnWall = false;\n    this.placementBox = null;\n    this.lastTick = null;\n    this.turntableRotation = null;\n    this.oldShadowIntensity = null;\n    this.frame = null;\n    this.initialHitSource = null;\n    this.transientHitTestSource = null;\n    this.inputSource = null;\n    this._presentedScene = null;\n    this.resolveCleanup = null;\n    this.exitWebXRButtonContainer = null;\n    this.overlay = null;\n    this.xrLight = null;\n    this.xrMode = null;\n    this.controller1 = null;\n    this.controller2 = null;\n    this.selectedController = null;\n    this.tracking = true;\n    this.frames = 0;\n    this.initialized = false;\n    this.oldTarget = new Vector3();\n    this.placementComplete = false;\n    this.isTranslating = false;\n    this.isRotating = false;\n    this.isTwoFingering = false;\n    this.lastDragPosition = new Vector3();\n    this.relativeOrientation = new Quaternion();\n    this.scaleLine = new Line(lineGeometry);\n    this.firstRatio = 0;\n    this.lastAngle = 0;\n    this.goalPosition = new Vector3();\n    this.goalYaw = 0;\n    this.goalScale = 1;\n    this.xDamper = new Damper();\n    this.yDamper = new Damper();\n    this.zDamper = new Damper();\n    this.yawDamper = new Damper();\n    this.pitchDamper = new Damper();\n    this.rollDamper = new Damper();\n    this.scaleDamper = new Damper();\n    this.onExitWebXRButtonContainerClick = () => this.stopPresenting();\n    this.onControllerSelectStart = event => {\n      const scene = this.presentedScene;\n      const controller = event.target;\n      if (this.placementBox.controllerIntersection(scene, controller) != null) {\n        if (this.selectedController != null) {\n          this.selectedController.userData.line.visible = false;\n          if (scene.canScale) {\n            this.isTwoFingering = true;\n            this.firstRatio = this.controllerSeparation() / scene.pivot.scale.x;\n            this.scaleLine.visible = true;\n          }\n        }\n        controller.attach(scene.pivot);\n        this.selectedController = controller;\n        scene.setShadowIntensity(0.01);\n      } else {\n        const otherController = controller === this.controller1 ? this.controller2 : this.controller1;\n        this.relativeOrientation.copy(controller.quaternion).invert().multiply(scene.pivot.getWorldQuaternion(quaternion));\n        otherController.userData.turning = false;\n        controller.userData.turning = true;\n        controller.userData.line.visible = false;\n      }\n    };\n    this.onControllerSelectEnd = event => {\n      const controller = event.target;\n      controller.userData.turning = false;\n      controller.userData.line.visible = true;\n      this.isTwoFingering = false;\n      this.scaleLine.visible = false;\n      if (this.selectedController != null && this.selectedController != controller) {\n        return;\n      }\n      const scene = this.presentedScene;\n      // drop on floor\n      scene.attach(scene.pivot);\n      this.selectedController = null;\n      this.goalYaw = Math.atan2(scene.pivot.matrix.elements[8], scene.pivot.matrix.elements[10]);\n      this.goalPosition.x = scene.pivot.position.x;\n      this.goalPosition.z = scene.pivot.position.z;\n    };\n    this.onUpdateScene = () => {\n      if (this.placementBox != null && this.isPresenting) {\n        this.placementBox.dispose();\n        this.placementBox = new PlacementBox(this.presentedScene, this.placeOnWall ? 'back' : 'bottom');\n      }\n    };\n    this.onSelectStart = event => {\n      const hitSource = this.transientHitTestSource;\n      if (hitSource == null) {\n        return;\n      }\n      const fingers = this.frame.getHitTestResultsForTransientInput(hitSource);\n      const scene = this.presentedScene;\n      const box = this.placementBox;\n      if (fingers.length === 1) {\n        this.inputSource = event.inputSource;\n        const {\n          axes\n        } = this.inputSource.gamepad;\n        const hitPosition = box.getHit(this.presentedScene, axes[0], axes[1]);\n        box.show = true;\n        if (hitPosition != null) {\n          this.isTranslating = true;\n          this.lastDragPosition.copy(hitPosition);\n        } else if (this.placeOnWall === false) {\n          this.isRotating = true;\n          this.lastAngle = axes[0] * ROTATION_RATE;\n        }\n      } else if (fingers.length === 2) {\n        box.show = true;\n        this.isTwoFingering = true;\n        const {\n          separation\n        } = this.fingerPolar(fingers);\n        this.firstRatio = separation / scene.pivot.scale.x;\n      }\n    };\n    this.onSelectEnd = () => {\n      this.isTranslating = false;\n      this.isRotating = false;\n      this.isTwoFingering = false;\n      this.inputSource = null;\n      this.goalPosition.y += this.placementBox.offsetHeight * this.presentedScene.scale.x;\n      this.placementBox.show = false;\n    };\n    this.threeRenderer = renderer.threeRenderer;\n    this.threeRenderer.xr.enabled = true;\n  }\n  async resolveARSession() {\n    assertIsArCandidate();\n    const session = await navigator.xr.requestSession('immersive-ar', {\n      requiredFeatures: [],\n      optionalFeatures: ['hit-test', 'dom-overlay', 'light-estimation'],\n      domOverlay: this.overlay ? {\n        root: this.overlay\n      } : undefined\n    });\n    this.threeRenderer.xr.setReferenceSpaceType('local');\n    await this.threeRenderer.xr.setSession(session);\n    this.threeRenderer.xr.cameraAutoUpdate = false;\n    return session;\n  }\n  /**\n   * The currently presented scene, if any\n   */\n  get presentedScene() {\n    return this._presentedScene;\n  }\n  /**\n   * Resolves to true if the renderer has detected all the necessary qualities\n   * to support presentation in AR.\n   */\n  async supportsPresentation() {\n    try {\n      assertIsArCandidate();\n      return await navigator.xr.isSessionSupported('immersive-ar');\n    } catch (error) {\n      console.warn('Request to present in WebXR denied:');\n      console.warn(error);\n      console.warn('Falling back to next ar-mode');\n      return false;\n    }\n  }\n  /**\n   * Present a scene in AR\n   */\n  async present(scene, environmentEstimation = false) {\n    if (this.isPresenting) {\n      console.warn('Cannot present while a model is already presenting');\n    }\n    let waitForAnimationFrame = new Promise((resolve, _reject) => {\n      requestAnimationFrame(() => resolve());\n    });\n    scene.setHotspotsVisibility(false);\n    scene.queueRender();\n    // Render a frame to turn off the hotspots\n    await waitForAnimationFrame;\n    // This sets isPresenting to true\n    this._presentedScene = scene;\n    this.overlay = scene.element.shadowRoot.querySelector('div.default');\n    if (environmentEstimation === true) {\n      this.xrLight = new XREstimatedLight(this.threeRenderer);\n      this.xrLight.addEventListener('estimationstart', () => {\n        if (!this.isPresenting || this.xrLight == null) {\n          return;\n        }\n        const scene = this.presentedScene;\n        scene.add(this.xrLight);\n        scene.environment = this.xrLight.environment;\n      });\n    }\n    const currentSession = await this.resolveARSession();\n    currentSession.addEventListener('end', () => {\n      this.postSessionCleanup();\n    }, {\n      once: true\n    });\n    const exitButton = scene.element.shadowRoot.querySelector('.slot.exit-webxr-ar-button');\n    exitButton.classList.add('enabled');\n    exitButton.addEventListener('click', this.onExitWebXRButtonContainerClick);\n    this.exitWebXRButtonContainer = exitButton;\n    const viewerRefSpace = await currentSession.requestReferenceSpace('viewer');\n    this.xrMode = currentSession.interactionMode;\n    this.tracking = true;\n    this.frames = 0;\n    this.initialized = false;\n    this.turntableRotation = scene.yaw;\n    this.goalYaw = scene.yaw;\n    this.goalScale = 1;\n    scene.setBackground(null);\n    this.oldShadowIntensity = scene.shadowIntensity;\n    scene.setShadowIntensity(0.01); // invisible, but not changing the shader\n    this.oldTarget.copy(scene.getTarget());\n    scene.element.addEventListener('load', this.onUpdateScene);\n    const radians = HIT_ANGLE_DEG * Math.PI / 180;\n    const ray = this.placeOnWall === true ? undefined : new XRRay(new DOMPoint(0, 0, 0), {\n      x: 0,\n      y: -Math.sin(radians),\n      z: -Math.cos(radians)\n    });\n    currentSession.requestHitTestSource({\n      space: viewerRefSpace,\n      offsetRay: ray\n    }).then(hitTestSource => {\n      this.initialHitSource = hitTestSource;\n    });\n    if (this.xrMode !== 'screen-space') {\n      this.setupControllers();\n      this.xDamper.setDecayTime(DECAY);\n      this.yDamper.setDecayTime(DECAY);\n      this.zDamper.setDecayTime(DECAY);\n      this.yawDamper.setDecayTime(DECAY);\n      this.pitchDamper.setDecayTime(DECAY);\n      this.rollDamper.setDecayTime(DECAY);\n    }\n    this.currentSession = currentSession;\n    this.placementBox = new PlacementBox(scene, this.placeOnWall ? 'back' : 'bottom');\n    this.placementComplete = false;\n    this.lastTick = performance.now();\n    this.dispatchEvent({\n      type: 'status',\n      status: ARStatus.SESSION_STARTED\n    });\n  }\n  setupControllers() {\n    this.controller1 = this.threeRenderer.xr.getController(0);\n    this.controller1.addEventListener('selectstart', this.onControllerSelectStart);\n    this.controller1.addEventListener('selectend', this.onControllerSelectEnd);\n    this.controller2 = this.threeRenderer.xr.getController(1);\n    this.controller2.addEventListener('selectstart', this.onControllerSelectStart);\n    this.controller2.addEventListener('selectend', this.onControllerSelectEnd);\n    const scene = this.presentedScene;\n    scene.add(this.controller1);\n    scene.add(this.controller2);\n    if (!this.controller1.userData.line) {\n      const line = new Line(lineGeometry);\n      line.name = 'line';\n      line.scale.z = MAX_LINE_LENGTH;\n      this.controller1.userData.turning = false;\n      this.controller1.userData.line = line;\n      this.controller1.add(line);\n      this.controller2.userData.turning = false;\n      const line2 = line.clone();\n      this.controller2.userData.line = line2;\n      this.controller2.add(line2);\n      this.scaleLine.name = 'scale line';\n      this.scaleLine.visible = false;\n      this.controller1.add(this.scaleLine);\n      const {\n        size\n      } = scene;\n      const scale = BOX_SIZE / Math.max(size.x, size.y, size.z);\n      const box = new Mesh(boxGeometry);\n      box.name = 'box';\n      box.scale.copy(size).multiplyScalar(scale);\n      box.visible = false;\n      this.controller1.userData.box = box;\n      scene.add(box);\n      const box2 = box.clone();\n      this.controller2.userData.box = box2;\n      scene.add(box2);\n    }\n  }\n  hover(controller) {\n    // Do not highlight in mobile-ar\n    if (this.xrMode === 'screen-space' || this.selectedController == controller) {\n      return false;\n    }\n    const scene = this.presentedScene;\n    const intersection = this.placementBox.controllerIntersection(scene, controller);\n    controller.userData.box.visible = (intersection == null || controller.userData.turning) && !this.isTwoFingering;\n    controller.userData.line.scale.z = intersection == null ? MAX_LINE_LENGTH : intersection.distance;\n    return intersection != null;\n  }\n  controllerSeparation() {\n    return this.controller1.position.distanceTo(this.controller2.position);\n  }\n  /**\n   * If currently presenting a scene in AR, stops presentation and exits AR.\n   */\n  async stopPresenting() {\n    if (!this.isPresenting) {\n      return;\n    }\n    const cleanupPromise = new Promise(resolve => {\n      this.resolveCleanup = resolve;\n    });\n    try {\n      await this.currentSession.end();\n      await cleanupPromise;\n    } catch (error) {\n      console.warn('Error while trying to end WebXR AR session');\n      console.warn(error);\n      this.postSessionCleanup();\n    }\n  }\n  /**\n   * True if a scene is currently in the process of being presented in AR\n   */\n  get isPresenting() {\n    return this.presentedScene != null;\n  }\n  get target() {\n    return this.oldTarget;\n  }\n  updateTarget() {\n    const scene = this.presentedScene;\n    if (scene != null) {\n      const target = scene.getTarget();\n      this.oldTarget.copy(target);\n      if (this.placeOnWall) {\n        // Move the scene's target to the center of the back of the model's\n        // bounding box.\n        target.z = scene.boundingBox.min.z;\n      } else {\n        // Move the scene's target to the model's floor height.\n        target.y = scene.boundingBox.min.y;\n      }\n      scene.setTarget(target.x, target.y, target.z);\n    }\n  }\n  postSessionCleanup() {\n    const session = this.currentSession;\n    if (session != null) {\n      session.removeEventListener('selectstart', this.onSelectStart);\n      session.removeEventListener('selectend', this.onSelectEnd);\n      this.currentSession = null;\n    }\n    const scene = this.presentedScene;\n    this._presentedScene = null;\n    if (scene != null) {\n      const {\n        element\n      } = scene;\n      if (this.xrLight != null) {\n        scene.remove(this.xrLight);\n        this.xrLight.dispose();\n        this.xrLight = null;\n      }\n      scene.add(scene.pivot);\n      scene.pivot.quaternion.set(0, 0, 0, 1);\n      scene.pivot.position.set(0, 0, 0);\n      scene.pivot.scale.set(1, 1, 1);\n      scene.setShadowOffset(0);\n      const yaw = this.turntableRotation;\n      if (yaw != null) {\n        scene.yaw = yaw;\n      }\n      const intensity = this.oldShadowIntensity;\n      if (intensity != null) {\n        scene.setShadowIntensity(intensity);\n      }\n      scene.setEnvironmentAndSkybox(element[$currentEnvironmentMap], element[$currentBackground]);\n      const point = this.oldTarget;\n      scene.setTarget(point.x, point.y, point.z);\n      scene.xrCamera = null;\n      scene.element.removeEventListener('load', this.onUpdateScene);\n      scene.orientHotspots(0);\n      const {\n        width,\n        height\n      } = element.getBoundingClientRect();\n      scene.setSize(width, height);\n      requestAnimationFrame(() => {\n        scene.element.dispatchEvent(new CustomEvent('camera-change', {\n          detail: {\n            source: ChangeSource.NONE\n          }\n        }));\n      });\n    }\n    // Force the Renderer to update its size\n    this.renderer.height = 0;\n    const exitButton = this.exitWebXRButtonContainer;\n    if (exitButton != null) {\n      exitButton.classList.remove('enabled');\n      exitButton.removeEventListener('click', this.onExitWebXRButtonContainerClick);\n      this.exitWebXRButtonContainer = null;\n    }\n    const hitSource = this.transientHitTestSource;\n    if (hitSource != null) {\n      hitSource.cancel();\n      this.transientHitTestSource = null;\n    }\n    const hitSourceInitial = this.initialHitSource;\n    if (hitSourceInitial != null) {\n      hitSourceInitial.cancel();\n      this.initialHitSource = null;\n    }\n    if (this.placementBox != null) {\n      this.placementBox.dispose();\n      this.placementBox = null;\n    }\n    if (this.xrMode !== 'screen-space') {\n      if (this.controller1 != null) {\n        this.controller1.userData.turning = false;\n        this.controller1.userData.box.visible = false;\n        this.controller1.userData.line.visible = true;\n        this.controller1.removeEventListener('selectstart', this.onControllerSelectStart);\n        this.controller1.removeEventListener('selectend', this.onControllerSelectEnd);\n        this.controller1.removeFromParent();\n        this.controller1 = null;\n      }\n      if (this.controller2 != null) {\n        this.controller2.userData.turning = false;\n        this.controller2.userData.box.visible = false;\n        this.controller2.userData.line.visible = true;\n        this.controller2.removeEventListener('selectstart', this.onControllerSelectStart);\n        this.controller2.removeEventListener('selectend', this.onControllerSelectEnd);\n        this.controller2.removeFromParent();\n        this.controller2 = null;\n      }\n      this.selectedController = null;\n      this.scaleLine.visible = false;\n    }\n    this.isTranslating = false;\n    this.isRotating = false;\n    this.isTwoFingering = false;\n    this.lastTick = null;\n    this.turntableRotation = null;\n    this.oldShadowIntensity = null;\n    this.frame = null;\n    this.inputSource = null;\n    this.overlay = null;\n    if (this.resolveCleanup != null) {\n      this.resolveCleanup();\n    }\n    this.dispatchEvent({\n      type: 'status',\n      status: ARStatus.NOT_PRESENTING\n    });\n  }\n  updateView(view) {\n    const scene = this.presentedScene;\n    const xr = this.threeRenderer.xr;\n    xr.updateCamera(camera);\n    scene.xrCamera = xr.getCamera();\n    const {\n      elements\n    } = scene.getCamera().matrixWorld;\n    scene.orientHotspots(Math.atan2(elements[1], elements[5]));\n    if (!this.initialized) {\n      this.placeInitially();\n      this.initialized = true;\n    }\n    // Use automatic dynamic viewport scaling if supported.\n    if (view.requestViewportScale && view.recommendedViewportScale) {\n      const scale = view.recommendedViewportScale;\n      view.requestViewportScale(Math.max(scale, MIN_VIEWPORT_SCALE));\n    }\n    const layer = xr.getBaseLayer();\n    if (layer != null) {\n      const viewport = layer instanceof XRWebGLLayer ? layer.getViewport(view) : xr.getBinding().getViewSubImage(layer, view).viewport;\n      this.threeRenderer.setViewport(viewport.x, viewport.y, viewport.width, viewport.height);\n    }\n  }\n  placeInitially() {\n    const scene = this.presentedScene;\n    const {\n      pivot,\n      element\n    } = scene;\n    const {\n      position\n    } = pivot;\n    const xrCamera = scene.getCamera();\n    const {\n      width,\n      height\n    } = this.overlay.getBoundingClientRect();\n    scene.setSize(width, height);\n    xrCamera.projectionMatrixInverse.copy(xrCamera.projectionMatrix).invert();\n    const {\n      theta\n    } = element.getCameraOrbit();\n    // Orient model to match the 3D camera view\n    const cameraDirection = xrCamera.getWorldDirection(vector3);\n    scene.yaw = Math.atan2(-cameraDirection.x, -cameraDirection.z) - theta;\n    this.goalYaw = scene.yaw;\n    const radius = Math.max(1, 2 * scene.boundingSphere.radius);\n    position.copy(xrCamera.position).add(cameraDirection.multiplyScalar(radius));\n    this.updateTarget();\n    const target = scene.getTarget();\n    position.add(target).sub(this.oldTarget);\n    this.goalPosition.copy(position);\n    scene.setHotspotsVisibility(true);\n    if (this.xrMode === 'screen-space') {\n      const {\n        session\n      } = this.frame;\n      session.addEventListener('selectstart', this.onSelectStart);\n      session.addEventListener('selectend', this.onSelectEnd);\n      session.requestHitTestSourceForTransientInput({\n        profile: 'generic-touchscreen'\n      }).then(hitTestSource => {\n        this.transientHitTestSource = hitTestSource;\n      });\n    }\n  }\n  getTouchLocation() {\n    const {\n      axes\n    } = this.inputSource.gamepad;\n    let location = this.placementBox.getExpandedHit(this.presentedScene, axes[0], axes[1]);\n    if (location != null) {\n      vector3.copy(location).sub(this.presentedScene.getCamera().position);\n      if (vector3.length() > MAX_DISTANCE) return null;\n    }\n    return location;\n  }\n  getHitPoint(hitResult) {\n    const refSpace = this.threeRenderer.xr.getReferenceSpace();\n    const pose = hitResult.getPose(refSpace);\n    if (pose == null) {\n      return null;\n    }\n    const hitMatrix = matrix4.fromArray(pose.transform.matrix);\n    if (this.placeOnWall === true) {\n      // Orient the model to the wall's normal vector.\n      this.goalYaw = Math.atan2(hitMatrix.elements[4], hitMatrix.elements[6]);\n    }\n    // Check that the y-coordinate of the normal is large enough that the normal\n    // is pointing up for floor placement; opposite for wall placement.\n    return hitMatrix.elements[5] > 0.75 !== this.placeOnWall ? hitPosition.setFromMatrixPosition(hitMatrix) : null;\n  }\n  moveToFloor(frame) {\n    const hitSource = this.initialHitSource;\n    if (hitSource == null) {\n      return;\n    }\n    const hitTestResults = frame.getHitTestResults(hitSource);\n    if (hitTestResults.length == 0) {\n      return;\n    }\n    const hit = hitTestResults[0];\n    const hitPoint = this.getHitPoint(hit);\n    if (hitPoint == null) {\n      return;\n    }\n    this.placementBox.show = true;\n    // If the user is translating, let the finger hit-ray take precedence and\n    // ignore this hit result.\n    if (!this.isTranslating) {\n      if (this.placeOnWall) {\n        this.goalPosition.copy(hitPoint);\n      } else {\n        this.goalPosition.y = hitPoint.y;\n      }\n    }\n    hitSource.cancel();\n    this.initialHitSource = null;\n    this.dispatchEvent({\n      type: 'status',\n      status: ARStatus.OBJECT_PLACED\n    });\n  }\n  fingerPolar(fingers) {\n    const fingerOne = fingers[0].inputSource.gamepad.axes;\n    const fingerTwo = fingers[1].inputSource.gamepad.axes;\n    const deltaX = fingerTwo[0] - fingerOne[0];\n    const deltaY = fingerTwo[1] - fingerOne[1];\n    const angle = Math.atan2(deltaY, deltaX);\n    let deltaYaw = this.lastAngle - angle;\n    if (deltaYaw > Math.PI) {\n      deltaYaw -= 2 * Math.PI;\n    } else if (deltaYaw < -Math.PI) {\n      deltaYaw += 2 * Math.PI;\n    }\n    this.lastAngle = angle;\n    return {\n      separation: Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n      deltaYaw: deltaYaw\n    };\n  }\n  setScale(separation) {\n    const scale = separation / this.firstRatio;\n    this.goalScale = Math.abs(scale - 1) < SCALE_SNAP ? 1 : scale;\n  }\n  processInput(frame) {\n    const hitSource = this.transientHitTestSource;\n    if (hitSource == null) {\n      return;\n    }\n    if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) {\n      return;\n    }\n    const fingers = frame.getHitTestResultsForTransientInput(hitSource);\n    const scene = this.presentedScene;\n    const scale = scene.pivot.scale.x;\n    // Rotating, translating and scaling are mutually exclusive operations; only\n    // one can happen at a time, but we can switch during a gesture.\n    if (this.isTwoFingering) {\n      if (fingers.length < 2) {\n        // If we lose the second finger, stop scaling (in fact, stop processing\n        // input altogether until a new gesture starts).\n        this.isTwoFingering = false;\n      } else {\n        const {\n          separation,\n          deltaYaw\n        } = this.fingerPolar(fingers);\n        if (this.placeOnWall === false) {\n          this.goalYaw += deltaYaw;\n        }\n        if (scene.canScale) {\n          this.setScale(separation);\n        }\n      }\n      return;\n    } else if (fingers.length === 2) {\n      // If we were rotating or translating and we get a second finger, switch\n      // to scaling instead.\n      this.isTranslating = false;\n      this.isRotating = false;\n      this.isTwoFingering = true;\n      const {\n        separation\n      } = this.fingerPolar(fingers);\n      this.firstRatio = separation / scale;\n      return;\n    }\n    if (this.isRotating) {\n      const angle = this.inputSource.gamepad.axes[0] * ROTATION_RATE;\n      this.goalYaw += angle - this.lastAngle;\n      this.lastAngle = angle;\n    } else if (this.isTranslating) {\n      fingers.forEach(finger => {\n        if (finger.inputSource !== this.inputSource) {\n          return;\n        }\n        let hit = null;\n        if (finger.results.length > 0) {\n          hit = this.getHitPoint(finger.results[0]);\n        }\n        if (hit == null) {\n          hit = this.getTouchLocation();\n        }\n        if (hit == null) {\n          return;\n        }\n        this.goalPosition.sub(this.lastDragPosition);\n        if (this.placeOnWall === false) {\n          const offset = hit.y - this.lastDragPosition.y;\n          // When a lower floor is found, keep the model at the same height, but\n          // drop the placement box to the floor. The model falls on select end.\n          if (offset < 0) {\n            this.placementBox.offsetHeight = offset / scale;\n            this.presentedScene.setShadowOffset(offset);\n            // Interpolate hit ray up to drag plane\n            const cameraPosition = vector3.copy(scene.getCamera().position);\n            const alpha = -offset / (cameraPosition.y - hit.y);\n            cameraPosition.multiplyScalar(alpha);\n            hit.multiplyScalar(1 - alpha).add(cameraPosition);\n          }\n        }\n        this.goalPosition.add(hit);\n        this.lastDragPosition.copy(hit);\n      });\n    }\n  }\n  moveScene(delta) {\n    const scene = this.presentedScene;\n    const {\n      pivot\n    } = scene;\n    const box = this.placementBox;\n    box.updateOpacity(delta);\n    if (this.controller1) {\n      if (this.controller1.userData.turning) {\n        pivot.quaternion.copy(this.controller1.quaternion).multiply(this.relativeOrientation);\n        if (this.selectedController && this.selectedController === this.controller2) {\n          pivot.quaternion.premultiply(quaternion.copy(this.controller2.quaternion).invert());\n        }\n      }\n      this.controller1.userData.box.position.copy(this.controller1.position);\n      pivot.getWorldQuaternion(this.controller1.userData.box.quaternion);\n    }\n    if (this.controller2) {\n      if (this.controller2.userData.turning) {\n        pivot.quaternion.copy(this.controller2.quaternion).multiply(this.relativeOrientation);\n        if (this.selectedController && this.selectedController === this.controller1) {\n          pivot.quaternion.premultiply(quaternion.copy(this.controller1.quaternion).invert());\n        }\n      }\n      this.controller2.userData.box.position.copy(this.controller2.position);\n      pivot.getWorldQuaternion(this.controller2.userData.box.quaternion);\n    }\n    if (this.controller1 && this.controller2 && this.isTwoFingering) {\n      const dist = this.controllerSeparation();\n      this.setScale(dist);\n      this.scaleLine.scale.z = -dist;\n      this.scaleLine.lookAt(this.controller2.position);\n    }\n    const oldScale = scene.pivot.scale.x;\n    if (this.goalScale !== oldScale) {\n      const newScale = this.scaleDamper.update(oldScale, this.goalScale, delta, 1);\n      scene.pivot.scale.set(newScale, newScale, newScale);\n    }\n    if (pivot.parent !== scene) {\n      return; // attached to controller instead\n    }\n    const {\n      position\n    } = pivot;\n    const boundingRadius = scene.boundingSphere.radius;\n    const goal = this.goalPosition;\n    let source = ChangeSource.NONE;\n    if (!goal.equals(position)) {\n      source = ChangeSource.USER_INTERACTION;\n      let {\n        x,\n        y,\n        z\n      } = position;\n      x = this.xDamper.update(x, goal.x, delta, boundingRadius);\n      y = this.yDamper.update(y, goal.y, delta, boundingRadius);\n      z = this.zDamper.update(z, goal.z, delta, boundingRadius);\n      position.set(x, y, z);\n      if (this.xrMode === 'screen-space' && !this.isTranslating) {\n        const offset = goal.y - y;\n        if (this.placementComplete && this.placeOnWall === false) {\n          box.offsetHeight = offset / scene.pivot.scale.x;\n          scene.setShadowOffset(offset);\n        } else if (offset === 0) {\n          this.placementComplete = true;\n          box.show = false;\n          scene.setShadowIntensity(AR_SHADOW_INTENSITY);\n        }\n      }\n      if (this.xrMode !== 'screen-space' && goal.equals(position)) {\n        scene.setShadowIntensity(AR_SHADOW_INTENSITY);\n      }\n    }\n    scene.updateTarget(delta);\n    // yaw must be updated last, since this also updates the shadow position.\n    quaternion.setFromAxisAngle(vector3.set(0, 1, 0), this.goalYaw);\n    const angle = scene.pivot.quaternion.angleTo(quaternion);\n    const angleStep = angle - this.yawDamper.update(angle, 0, delta, Math.PI);\n    scene.pivot.quaternion.rotateTowards(quaternion, angleStep);\n    // camera changes on every frame - user-interaction only if touching the\n    // screen, plus damping time.\n    scene.element.dispatchEvent(new CustomEvent('camera-change', {\n      detail: {\n        source\n      }\n    }));\n  }\n  /**\n   * Only public to make it testable.\n   */\n  onWebXRFrame(time, frame) {\n    if (this.xrMode !== 'screen-space') {\n      const over1 = this.hover(this.controller1);\n      const over2 = this.hover(this.controller2);\n      this.placementBox.show = (over1 || over2) && !this.isTwoFingering;\n    }\n    this.frame = frame;\n    ++this.frames;\n    const refSpace = this.threeRenderer.xr.getReferenceSpace();\n    const pose = frame.getViewerPose(refSpace);\n    if (pose == null && this.tracking === true && this.frames > INIT_FRAMES) {\n      this.tracking = false;\n      this.dispatchEvent({\n        type: 'tracking',\n        status: ARTracking.NOT_TRACKING\n      });\n    }\n    const scene = this.presentedScene;\n    if (pose == null || scene == null || !scene.element.loaded) {\n      this.threeRenderer.clear();\n      return;\n    }\n    if (this.tracking === false) {\n      this.tracking = true;\n      this.dispatchEvent({\n        type: 'tracking',\n        status: ARTracking.TRACKING\n      });\n    }\n    // WebXR may return multiple views, i.e. for headset AR. This\n    // isn't really supported at this point, but make a best-effort\n    // attempt to render other views also, using the first view\n    // as the main viewpoint.\n    let isFirstView = true;\n    for (const view of pose.views) {\n      this.updateView(view);\n      if (isFirstView) {\n        this.moveToFloor(frame);\n        this.processInput(frame);\n        const delta = time - this.lastTick;\n        this.moveScene(delta);\n        this.renderer.preRender(scene, time, delta);\n        this.lastTick = time;\n        scene.renderShadow(this.threeRenderer);\n      }\n      this.threeRenderer.render(scene, scene.getCamera());\n      isFirstView = false;\n    }\n  }\n}","map":{"version":3,"names":["BoxGeometry","BufferGeometry","EventDispatcher","Line","Matrix4","Mesh","PerspectiveCamera","Quaternion","Vector3","XREstimatedLight","$currentBackground","$currentEnvironmentMap","assertIsArCandidate","Damper","PlacementBox","ChangeSource","INIT_FRAMES","AR_SHADOW_INTENSITY","ROTATION_RATE","HIT_ANGLE_DEG","SCALE_SNAP","MIN_VIEWPORT_SCALE","MAX_DISTANCE","DECAY","MAX_LINE_LENGTH","BOX_SIZE","ARStatus","NOT_PRESENTING","SESSION_STARTED","OBJECT_PLACED","FAILED","ARTracking","TRACKING","NOT_TRACKING","vector3","quaternion","matrix4","hitPosition","camera","lineGeometry","setFromPoints","boxGeometry","ARRenderer","constructor","renderer","currentSession","placeOnWall","placementBox","lastTick","turntableRotation","oldShadowIntensity","frame","initialHitSource","transientHitTestSource","inputSource","_presentedScene","resolveCleanup","exitWebXRButtonContainer","overlay","xrLight","xrMode","controller1","controller2","selectedController","tracking","frames","initialized","oldTarget","placementComplete","isTranslating","isRotating","isTwoFingering","lastDragPosition","relativeOrientation","scaleLine","firstRatio","lastAngle","goalPosition","goalYaw","goalScale","xDamper","yDamper","zDamper","yawDamper","pitchDamper","rollDamper","scaleDamper","onExitWebXRButtonContainerClick","stopPresenting","onControllerSelectStart","event","scene","presentedScene","controller","target","controllerIntersection","userData","line","visible","canScale","controllerSeparation","pivot","scale","x","attach","setShadowIntensity","otherController","copy","invert","multiply","getWorldQuaternion","turning","onControllerSelectEnd","Math","atan2","matrix","elements","position","z","onUpdateScene","isPresenting","dispose","onSelectStart","hitSource","fingers","getHitTestResultsForTransientInput","box","length","axes","gamepad","getHit","show","separation","fingerPolar","onSelectEnd","y","offsetHeight","threeRenderer","xr","enabled","resolveARSession","session","navigator","requestSession","requiredFeatures","optionalFeatures","domOverlay","root","undefined","setReferenceSpaceType","setSession","cameraAutoUpdate","supportsPresentation","isSessionSupported","error","console","warn","present","environmentEstimation","waitForAnimationFrame","Promise","resolve","_reject","requestAnimationFrame","setHotspotsVisibility","queueRender","element","shadowRoot","querySelector","addEventListener","add","environment","postSessionCleanup","once","exitButton","classList","viewerRefSpace","requestReferenceSpace","interactionMode","yaw","setBackground","shadowIntensity","getTarget","radians","PI","ray","XRRay","DOMPoint","sin","cos","requestHitTestSource","space","offsetRay","then","hitTestSource","setupControllers","setDecayTime","performance","now","dispatchEvent","type","status","getController","name","line2","clone","size","max","multiplyScalar","box2","hover","intersection","distance","distanceTo","cleanupPromise","end","updateTarget","boundingBox","min","setTarget","removeEventListener","remove","set","setShadowOffset","intensity","setEnvironmentAndSkybox","point","xrCamera","orientHotspots","width","height","getBoundingClientRect","setSize","CustomEvent","detail","source","NONE","cancel","hitSourceInitial","removeFromParent","updateView","view","updateCamera","getCamera","matrixWorld","placeInitially","requestViewportScale","recommendedViewportScale","layer","getBaseLayer","viewport","XRWebGLLayer","getViewport","getBinding","getViewSubImage","setViewport","projectionMatrixInverse","projectionMatrix","theta","getCameraOrbit","cameraDirection","getWorldDirection","radius","boundingSphere","sub","requestHitTestSourceForTransientInput","profile","getTouchLocation","location","getExpandedHit","getHitPoint","hitResult","refSpace","getReferenceSpace","pose","getPose","hitMatrix","fromArray","transform","setFromMatrixPosition","moveToFloor","hitTestResults","getHitTestResults","hit","hitPoint","fingerOne","fingerTwo","deltaX","deltaY","angle","deltaYaw","sqrt","setScale","abs","processInput","forEach","finger","results","offset","cameraPosition","alpha","moveScene","delta","updateOpacity","premultiply","dist","lookAt","oldScale","newScale","update","parent","boundingRadius","goal","equals","USER_INTERACTION","setFromAxisAngle","angleTo","angleStep","rotateTowards","onWebXRFrame","time","over1","over2","getViewerPose","loaded","clear","isFirstView","views","preRender","renderShadow","render"],"sources":["../../src/three-components/ARRenderer.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {BoxGeometry, BufferGeometry, Event as ThreeEvent, EventDispatcher, Line, Matrix4, Mesh, PerspectiveCamera, Quaternion, Vector3, WebGLRenderer, XRControllerEventType, XRTargetRaySpace} from 'three';\nimport {XREstimatedLight} from 'three/examples/jsm/webxr/XREstimatedLight.js';\n\nimport {CameraChangeDetails, ControlsInterface} from '../features/controls.js';\nimport {$currentBackground, $currentEnvironmentMap} from '../features/environment.js';\nimport ModelViewerElementBase from '../model-viewer-base.js';\nimport {assertIsArCandidate} from '../utilities.js';\n\nimport {Damper} from './Damper.js';\nimport {ModelScene} from './ModelScene.js';\nimport {PlacementBox} from './PlacementBox.js';\nimport {Renderer} from './Renderer.js';\nimport {ChangeSource} from './SmoothControls.js';\n\n// number of initial null pose XRFrames allowed before we post not-tracking\nconst INIT_FRAMES = 30;\n// AR shadow is not user-configurable. This is to pave the way for AR lighting\n// estimation, which will be used once available in WebXR.\nconst AR_SHADOW_INTENSITY = 0.8;\nconst ROTATION_RATE = 1.5;\n// Angle down (towards bottom of screen) from camera center ray to use for hit\n// testing against the floor. This makes placement faster and more intuitive\n// assuming the phone is in portrait mode. This seems to be a reasonable\n// assumption for the start of the session and UI will lack landscape mode to\n// encourage upright use.\nconst HIT_ANGLE_DEG = 20;\nconst SCALE_SNAP = 0.2;\n// For automatic dynamic viewport scaling, don't let the scale drop below this\n// limit.\nconst MIN_VIEWPORT_SCALE = 0.25;\n// Furthest away you can move an object (meters).\nconst MAX_DISTANCE = 10;\n// Damper decay in milliseconds for the headset - screen uses default.\nconst DECAY = 150;\n// Longer controller/hand indicator line (meters).\nconst MAX_LINE_LENGTH = 5;\n// Maximum dimension of rotation indicator box on controller (meters).\nconst BOX_SIZE = 0.1;\n\nexport type ARStatus =\n    'not-presenting'|'session-started'|'object-placed'|'failed';\n\nexport const ARStatus: {[index: string]: ARStatus} = {\n  NOT_PRESENTING: 'not-presenting',\n  SESSION_STARTED: 'session-started',\n  OBJECT_PLACED: 'object-placed',\n  FAILED: 'failed'\n};\n\nexport interface ARStatusEvent extends ThreeEvent {\n  status: ARStatus,\n}\n\nexport type ARTracking = 'tracking'|'not-tracking';\n\nexport const ARTracking: {[index: string]: ARTracking} = {\n  TRACKING: 'tracking',\n  NOT_TRACKING: 'not-tracking'\n};\n\nexport interface ARTrackingEvent extends ThreeEvent {\n  status: ARTracking,\n}\n\ninterface UserData {\n  turning: boolean, box: Mesh, line: Line\n}\n\ninterface Controller extends XRTargetRaySpace {\n  userData: UserData\n}\n\ninterface XRControllerEvent {\n  type: XRControllerEventType, data: XRInputSource, target: Controller\n}\n\nconst vector3 = new Vector3();\nconst quaternion = new Quaternion();\nconst matrix4 = new Matrix4();\nconst hitPosition = new Vector3();\nconst camera = new PerspectiveCamera(45, 1, 0.1, 100);\nconst lineGeometry = new BufferGeometry().setFromPoints(\n    [new Vector3(0, 0, 0), new Vector3(0, 0, -1)]);\nconst boxGeometry = new BoxGeometry();\n\nexport class ARRenderer extends EventDispatcher<\n    {status: {status: ARStatus}, tracking: {status: ARTracking}}> {\n  public threeRenderer: WebGLRenderer;\n  public currentSession: XRSession|null = null;\n  public placeOnWall = false;\n\n  private placementBox: PlacementBox|null = null;\n  private lastTick: number|null = null;\n  private turntableRotation: number|null = null;\n  private oldShadowIntensity: number|null = null;\n  private frame: XRFrame|null = null;\n  private initialHitSource: XRHitTestSource|null = null;\n  private transientHitTestSource: XRTransientInputHitTestSource|null = null;\n  private inputSource: XRInputSource|null = null;\n  private _presentedScene: ModelScene|null = null;\n  private resolveCleanup: ((...args: any[]) => void)|null = null;\n  private exitWebXRButtonContainer: HTMLElement|null = null;\n  private overlay: HTMLElement|null = null;\n  private xrLight: XREstimatedLight|null = null;\n  private xrMode: 'screen-space'|'world-space'|null = null;\n  private controller1: Controller|null = null;\n  private controller2: Controller|null = null;\n  private selectedController: Controller|null = null;\n\n  private tracking = true;\n  private frames = 0;\n  private initialized = false;\n  private oldTarget = new Vector3();\n  private placementComplete = false;\n  private isTranslating = false;\n  private isRotating = false;\n  private isTwoFingering = false;\n  private lastDragPosition = new Vector3();\n  private relativeOrientation = new Quaternion();\n  private scaleLine = new Line(lineGeometry);\n  private firstRatio = 0;\n  private lastAngle = 0;\n  private goalPosition = new Vector3();\n  private goalYaw = 0;\n  private goalScale = 1;\n  private xDamper = new Damper();\n  private yDamper = new Damper();\n  private zDamper = new Damper();\n  private yawDamper = new Damper();\n  private pitchDamper = new Damper();\n  private rollDamper = new Damper();\n  private scaleDamper = new Damper();\n\n  private onExitWebXRButtonContainerClick = () => this.stopPresenting();\n\n  constructor(private renderer: Renderer) {\n    super();\n    this.threeRenderer = renderer.threeRenderer;\n    this.threeRenderer.xr.enabled = true;\n  }\n\n  async resolveARSession(): Promise<XRSession> {\n    assertIsArCandidate();\n\n    const session: XRSession =\n        await navigator.xr!.requestSession!('immersive-ar', {\n          requiredFeatures: [],\n          optionalFeatures: ['hit-test', 'dom-overlay', 'light-estimation'],\n          domOverlay: this.overlay ? {root: this.overlay} : undefined\n        });\n\n    this.threeRenderer.xr.setReferenceSpaceType('local');\n\n    await this.threeRenderer.xr.setSession(session);\n\n    this.threeRenderer.xr.cameraAutoUpdate = false;\n\n    return session;\n  }\n\n  /**\n   * The currently presented scene, if any\n   */\n  get presentedScene() {\n    return this._presentedScene;\n  }\n\n  /**\n   * Resolves to true if the renderer has detected all the necessary qualities\n   * to support presentation in AR.\n   */\n  async supportsPresentation(): Promise<boolean> {\n    try {\n      assertIsArCandidate();\n      return await navigator.xr!.isSessionSupported('immersive-ar');\n    } catch (error) {\n      console.warn('Request to present in WebXR denied:');\n      console.warn(error);\n      console.warn('Falling back to next ar-mode');\n      return false;\n    }\n  }\n\n  /**\n   * Present a scene in AR\n   */\n  async present(scene: ModelScene, environmentEstimation: boolean = false):\n      Promise<void> {\n    if (this.isPresenting) {\n      console.warn('Cannot present while a model is already presenting');\n    }\n\n    let waitForAnimationFrame = new Promise<void>((resolve, _reject) => {\n      requestAnimationFrame(() => resolve());\n    });\n\n    scene.setHotspotsVisibility(false);\n    scene.queueRender();\n    // Render a frame to turn off the hotspots\n    await waitForAnimationFrame;\n\n    // This sets isPresenting to true\n    this._presentedScene = scene;\n    this.overlay = scene.element.shadowRoot!.querySelector('div.default');\n\n    if (environmentEstimation === true) {\n      this.xrLight = new XREstimatedLight(this.threeRenderer);\n\n      this.xrLight.addEventListener('estimationstart', () => {\n        if (!this.isPresenting || this.xrLight == null) {\n          return;\n        }\n\n        const scene = this.presentedScene!;\n        scene.add(this.xrLight);\n\n        scene.environment = this.xrLight.environment;\n      });\n    }\n\n    const currentSession = await this.resolveARSession();\n\n    currentSession.addEventListener('end', () => {\n      this.postSessionCleanup();\n    }, {once: true});\n\n    const exitButton = scene.element.shadowRoot!.querySelector(\n                           '.slot.exit-webxr-ar-button') as HTMLElement;\n    exitButton.classList.add('enabled');\n    exitButton.addEventListener('click', this.onExitWebXRButtonContainerClick);\n    this.exitWebXRButtonContainer = exitButton;\n\n    const viewerRefSpace = await currentSession.requestReferenceSpace('viewer');\n\n    this.xrMode = (currentSession as any).interactionMode;\n\n    this.tracking = true;\n    this.frames = 0;\n    this.initialized = false;\n\n    this.turntableRotation = scene.yaw;\n    this.goalYaw = scene.yaw;\n    this.goalScale = 1;\n\n    scene.setBackground(null);\n\n    this.oldShadowIntensity = scene.shadowIntensity;\n    scene.setShadowIntensity(0.01);  // invisible, but not changing the shader\n\n    this.oldTarget.copy(scene.getTarget());\n\n    scene.element.addEventListener('load', this.onUpdateScene);\n\n    const radians = HIT_ANGLE_DEG * Math.PI / 180;\n    const ray = this.placeOnWall === true ?\n        undefined :\n        new XRRay(\n            new DOMPoint(0, 0, 0),\n            {x: 0, y: -Math.sin(radians), z: -Math.cos(radians)});\n    currentSession\n        .requestHitTestSource!\n        ({space: viewerRefSpace, offsetRay: ray})!.then(hitTestSource => {\n          this.initialHitSource = hitTestSource;\n        });\n\n    if (this.xrMode !== 'screen-space') {\n      this.setupControllers();\n      this.xDamper.setDecayTime(DECAY);\n      this.yDamper.setDecayTime(DECAY);\n      this.zDamper.setDecayTime(DECAY);\n      this.yawDamper.setDecayTime(DECAY);\n      this.pitchDamper.setDecayTime(DECAY);\n      this.rollDamper.setDecayTime(DECAY);\n    }\n\n    this.currentSession = currentSession;\n    this.placementBox =\n        new PlacementBox(scene, this.placeOnWall ? 'back' : 'bottom');\n    this.placementComplete = false;\n\n    this.lastTick = performance.now();\n    this.dispatchEvent({type: 'status', status: ARStatus.SESSION_STARTED});\n  }\n\n  private setupControllers() {\n    this.controller1 = this.threeRenderer.xr.getController(0) as Controller;\n    this.controller1.addEventListener(\n        'selectstart', this.onControllerSelectStart);\n    this.controller1.addEventListener('selectend', this.onControllerSelectEnd);\n\n    this.controller2 = this.threeRenderer.xr.getController(1) as Controller;\n    this.controller2.addEventListener(\n        'selectstart', this.onControllerSelectStart);\n    this.controller2.addEventListener('selectend', this.onControllerSelectEnd);\n\n    const scene = this.presentedScene!;\n    scene.add(this.controller1);\n    scene.add(this.controller2);\n\n    if (!this.controller1.userData.line) {\n      const line = new Line(lineGeometry);\n      line.name = 'line';\n      line.scale.z = MAX_LINE_LENGTH;\n\n      this.controller1.userData.turning = false;\n      this.controller1.userData.line = line;\n      this.controller1.add(line);\n\n      this.controller2.userData.turning = false;\n      const line2 = line.clone();\n      this.controller2.userData.line = line2;\n      this.controller2.add(line2);\n\n      this.scaleLine.name = 'scale line';\n      this.scaleLine.visible = false;\n      this.controller1.add(this.scaleLine);\n\n      const {size} = scene;\n      const scale = BOX_SIZE / Math.max(size.x, size.y, size.z);\n      const box = new Mesh(boxGeometry);\n      box.name = 'box';\n      box.scale.copy(size).multiplyScalar(scale);\n      box.visible = false;\n\n      this.controller1.userData.box = box;\n      scene.add(box);\n      const box2 = box.clone();\n      this.controller2.userData.box = box2;\n      scene.add(box2);\n    }\n  }\n\n  private hover(controller: XRTargetRaySpace): boolean {\n    // Do not highlight in mobile-ar\n    if (this.xrMode === 'screen-space' ||\n        this.selectedController == controller) {\n      return false;\n    }\n\n    const scene = this.presentedScene!;\n    const intersection =\n        this.placementBox!.controllerIntersection(scene, controller)\n    controller.userData.box.visible =\n        (intersection == null || controller.userData.turning) &&\n        !this.isTwoFingering;\n    controller.userData.line.scale.z =\n        intersection == null ? MAX_LINE_LENGTH : intersection.distance;\n    return intersection != null;\n  }\n\n  private controllerSeparation() {\n    return this.controller1!.position.distanceTo(this.controller2!.position);\n  }\n\n  private onControllerSelectStart = (event: XRControllerEvent) => {\n    const scene = this.presentedScene!;\n    const controller = event.target;\n\n    if (this.placementBox!.controllerIntersection(scene, controller) != null) {\n      if (this.selectedController != null) {\n        this.selectedController.userData.line.visible = false;\n        if (scene.canScale) {\n          this.isTwoFingering = true;\n          this.firstRatio = this.controllerSeparation() / scene.pivot.scale.x;\n          this.scaleLine.visible = true;\n        }\n      }\n\n      controller.attach(scene.pivot);\n      this.selectedController = controller;\n\n      scene.setShadowIntensity(0.01);\n    } else {\n      const otherController = controller === this.controller1 ?\n          this.controller2! :\n          this.controller1!;\n\n      this.relativeOrientation.copy(controller.quaternion)\n          .invert()\n          .multiply(scene.pivot.getWorldQuaternion(quaternion));\n\n      otherController.userData.turning = false;\n      controller.userData.turning = true;\n      controller.userData.line.visible = false;\n    }\n  };\n\n  private onControllerSelectEnd = (event: XRControllerEvent) => {\n    const controller = event.target;\n    controller.userData.turning = false;\n    controller.userData.line.visible = true;\n    this.isTwoFingering = false;\n    this.scaleLine.visible = false;\n    if (this.selectedController != null &&\n        this.selectedController != controller) {\n      return;\n    }\n    const scene = this.presentedScene!;\n    // drop on floor\n    scene.attach(scene.pivot);\n    this.selectedController = null;\n    this.goalYaw = Math.atan2(\n        scene.pivot.matrix.elements[8], scene.pivot.matrix.elements[10]);\n    this.goalPosition.x = scene.pivot.position.x;\n    this.goalPosition.z = scene.pivot.position.z;\n  };\n\n  /**\n   * If currently presenting a scene in AR, stops presentation and exits AR.\n   */\n  async stopPresenting() {\n    if (!this.isPresenting) {\n      return;\n    }\n\n    const cleanupPromise = new Promise((resolve) => {\n      this.resolveCleanup = resolve;\n    });\n\n    try {\n      await this.currentSession!.end();\n      await cleanupPromise;\n    } catch (error) {\n      console.warn('Error while trying to end WebXR AR session');\n      console.warn(error);\n\n      this.postSessionCleanup();\n    }\n  }\n\n  /**\n   * True if a scene is currently in the process of being presented in AR\n   */\n  get isPresenting(): boolean {\n    return this.presentedScene != null;\n  }\n\n  get target(): Vector3 {\n    return this.oldTarget;\n  }\n\n  updateTarget() {\n    const scene = this.presentedScene;\n    if (scene != null) {\n      const target = scene.getTarget();\n      this.oldTarget.copy(target);\n      if (this.placeOnWall) {\n        // Move the scene's target to the center of the back of the model's\n        // bounding box.\n        target.z = scene.boundingBox.min.z;\n      } else {\n        // Move the scene's target to the model's floor height.\n        target.y = scene.boundingBox.min.y;\n      }\n      scene.setTarget(target.x, target.y, target.z);\n    }\n  }\n\n  onUpdateScene = () => {\n    if (this.placementBox != null && this.isPresenting) {\n      this.placementBox!.dispose();\n      this.placementBox = new PlacementBox(\n          this.presentedScene!, this.placeOnWall ? 'back' : 'bottom');\n    }\n  };\n\n  private postSessionCleanup() {\n    const session = this.currentSession;\n    if (session != null) {\n      session.removeEventListener('selectstart', this.onSelectStart);\n      session.removeEventListener('selectend', this.onSelectEnd);\n      this.currentSession = null;\n    }\n\n    const scene = this.presentedScene;\n    this._presentedScene = null;\n    if (scene != null) {\n      const {element} = scene;\n\n      if (this.xrLight != null) {\n        scene.remove(this.xrLight);\n        (this.xrLight as any).dispose();\n        this.xrLight = null;\n      }\n\n      scene.add(scene.pivot);\n      scene.pivot.quaternion.set(0, 0, 0, 1);\n      scene.pivot.position.set(0, 0, 0);\n      scene.pivot.scale.set(1, 1, 1);\n      scene.setShadowOffset(0);\n      const yaw = this.turntableRotation;\n      if (yaw != null) {\n        scene.yaw = yaw;\n      }\n      const intensity = this.oldShadowIntensity;\n      if (intensity != null) {\n        scene.setShadowIntensity(intensity);\n      }\n      scene.setEnvironmentAndSkybox(\n          (element as any)[$currentEnvironmentMap],\n          (element as any)[$currentBackground]);\n      const point = this.oldTarget;\n      scene.setTarget(point.x, point.y, point.z);\n      scene.xrCamera = null;\n\n      scene.element.removeEventListener('load', this.onUpdateScene);\n      scene.orientHotspots(0);\n      const {width, height} = element.getBoundingClientRect();\n      scene.setSize(width, height);\n\n      requestAnimationFrame(() => {\n        scene.element.dispatchEvent(new CustomEvent<CameraChangeDetails>(\n            'camera-change', {detail: {source: ChangeSource.NONE}}));\n      });\n    }\n\n    // Force the Renderer to update its size\n    this.renderer.height = 0;\n\n    const exitButton = this.exitWebXRButtonContainer;\n    if (exitButton != null) {\n      exitButton.classList.remove('enabled');\n      exitButton.removeEventListener(\n          'click', this.onExitWebXRButtonContainerClick);\n      this.exitWebXRButtonContainer = null;\n    }\n\n    const hitSource = this.transientHitTestSource;\n    if (hitSource != null) {\n      hitSource.cancel();\n      this.transientHitTestSource = null;\n    }\n\n    const hitSourceInitial = this.initialHitSource;\n    if (hitSourceInitial != null) {\n      hitSourceInitial.cancel();\n      this.initialHitSource = null;\n    }\n\n    if (this.placementBox != null) {\n      this.placementBox!.dispose();\n      this.placementBox = null;\n    }\n\n    if (this.xrMode !== 'screen-space') {\n      if (this.controller1 != null) {\n        this.controller1.userData.turning = false;\n        this.controller1.userData.box.visible = false;\n        this.controller1.userData.line.visible = true;\n        this.controller1.removeEventListener(\n            'selectstart', this.onControllerSelectStart);\n        this.controller1.removeEventListener(\n            'selectend', this.onControllerSelectEnd);\n        this.controller1.removeFromParent();\n        this.controller1 = null;\n      }\n      if (this.controller2 != null) {\n        this.controller2.userData.turning = false;\n        this.controller2.userData.box.visible = false;\n        this.controller2.userData.line.visible = true;\n        this.controller2.removeEventListener(\n            'selectstart', this.onControllerSelectStart);\n        this.controller2.removeEventListener(\n            'selectend', this.onControllerSelectEnd);\n        this.controller2.removeFromParent();\n        this.controller2 = null;\n      }\n      this.selectedController = null;\n      this.scaleLine.visible = false;\n    }\n\n    this.isTranslating = false;\n    this.isRotating = false;\n    this.isTwoFingering = false;\n    this.lastTick = null;\n    this.turntableRotation = null;\n    this.oldShadowIntensity = null;\n    this.frame = null;\n    this.inputSource = null;\n    this.overlay = null;\n\n    if (this.resolveCleanup != null) {\n      this.resolveCleanup!();\n    }\n\n    this.dispatchEvent({type: 'status', status: ARStatus.NOT_PRESENTING});\n  }\n\n  private updateView(view: XRView) {\n    const scene = this.presentedScene!;\n    const xr = this.threeRenderer.xr;\n\n    xr.updateCamera(camera);\n    scene.xrCamera = xr.getCamera();\n    const {elements} = scene.getCamera().matrixWorld;\n    scene.orientHotspots(Math.atan2(elements[1], elements[5]));\n\n    if (!this.initialized) {\n      this.placeInitially();\n      this.initialized = true;\n    }\n\n    // Use automatic dynamic viewport scaling if supported.\n    if (view.requestViewportScale && view.recommendedViewportScale) {\n      const scale = view.recommendedViewportScale;\n      view.requestViewportScale(Math.max(scale, MIN_VIEWPORT_SCALE));\n    }\n    const layer = xr.getBaseLayer();\n    if (layer != null) {\n      const viewport = layer instanceof XRWebGLLayer ?\n          layer!.getViewport(view)! :\n          xr.getBinding().getViewSubImage(layer, view).viewport;\n      this.threeRenderer.setViewport(\n          viewport.x, viewport.y, viewport.width, viewport.height);\n    }\n  }\n\n  private placeInitially() {\n    const scene = this.presentedScene!;\n    const {pivot, element} = scene;\n    const {position} = pivot;\n    const xrCamera = scene.getCamera();\n\n    const {width, height} = this.overlay!.getBoundingClientRect();\n    scene.setSize(width, height);\n\n    xrCamera.projectionMatrixInverse.copy(xrCamera.projectionMatrix).invert();\n\n    const {theta} = (element as ModelViewerElementBase & ControlsInterface)\n                        .getCameraOrbit();\n\n    // Orient model to match the 3D camera view\n    const cameraDirection = xrCamera.getWorldDirection(vector3);\n    scene.yaw = Math.atan2(-cameraDirection.x, -cameraDirection.z) - theta;\n    this.goalYaw = scene.yaw;\n\n    const radius = Math.max(1, 2 * scene.boundingSphere.radius);\n    position.copy(xrCamera.position)\n        .add(cameraDirection.multiplyScalar(radius));\n\n    this.updateTarget();\n    const target = scene.getTarget();\n    position.add(target).sub(this.oldTarget);\n\n    this.goalPosition.copy(position);\n\n    scene.setHotspotsVisibility(true);\n\n    if (this.xrMode === 'screen-space') {\n      const {session} = this.frame!;\n      session.addEventListener('selectstart', this.onSelectStart);\n      session.addEventListener('selectend', this.onSelectEnd);\n      session\n          .requestHitTestSourceForTransientInput!\n          ({profile: 'generic-touchscreen'})!.then(hitTestSource => {\n            this.transientHitTestSource = hitTestSource;\n          });\n    }\n  }\n\n  private getTouchLocation(): Vector3|null {\n    const {axes} = this.inputSource!.gamepad!;\n    let location = this.placementBox!.getExpandedHit(\n        this.presentedScene!, axes[0], axes[1]);\n    if (location != null) {\n      vector3.copy(location).sub(this.presentedScene!.getCamera().position);\n      if (vector3.length() > MAX_DISTANCE)\n        return null;\n    }\n    return location;\n  }\n\n  private getHitPoint(hitResult: XRHitTestResult): Vector3|null {\n    const refSpace = this.threeRenderer.xr.getReferenceSpace()!;\n    const pose = hitResult.getPose(refSpace);\n    if (pose == null) {\n      return null;\n    }\n\n    const hitMatrix = matrix4.fromArray(pose.transform.matrix);\n\n    if (this.placeOnWall === true) {\n      // Orient the model to the wall's normal vector.\n      this.goalYaw = Math.atan2(hitMatrix.elements[4], hitMatrix.elements[6]);\n    }\n    // Check that the y-coordinate of the normal is large enough that the normal\n    // is pointing up for floor placement; opposite for wall placement.\n    return hitMatrix.elements[5] > 0.75 !== this.placeOnWall ?\n        hitPosition.setFromMatrixPosition(hitMatrix) :\n        null;\n  }\n\n  public moveToFloor(frame: XRFrame) {\n    const hitSource = this.initialHitSource;\n    if (hitSource == null) {\n      return;\n    }\n\n    const hitTestResults = frame.getHitTestResults(hitSource);\n    if (hitTestResults.length == 0) {\n      return;\n    }\n\n    const hit = hitTestResults[0];\n    const hitPoint = this.getHitPoint(hit);\n    if (hitPoint == null) {\n      return;\n    }\n\n    this.placementBox!.show = true;\n\n    // If the user is translating, let the finger hit-ray take precedence and\n    // ignore this hit result.\n    if (!this.isTranslating) {\n      if (this.placeOnWall) {\n        this.goalPosition.copy(hitPoint);\n      } else {\n        this.goalPosition.y = hitPoint.y;\n      }\n    }\n\n    hitSource.cancel();\n    this.initialHitSource = null;\n    this.dispatchEvent({type: 'status', status: ARStatus.OBJECT_PLACED});\n  }\n\n  private onSelectStart = (event: Event) => {\n    const hitSource = this.transientHitTestSource;\n    if (hitSource == null) {\n      return;\n    }\n    const fingers = this.frame!.getHitTestResultsForTransientInput(hitSource);\n    const scene = this.presentedScene!;\n    const box = this.placementBox!;\n\n    if (fingers.length === 1) {\n      this.inputSource = (event as XRInputSourceEvent).inputSource;\n      const {axes} = this.inputSource!.gamepad!;\n\n      const hitPosition = box.getHit(this.presentedScene!, axes[0], axes[1]);\n      box.show = true;\n\n      if (hitPosition != null) {\n        this.isTranslating = true;\n        this.lastDragPosition.copy(hitPosition);\n      } else if (this.placeOnWall === false) {\n        this.isRotating = true;\n        this.lastAngle = axes[0] * ROTATION_RATE;\n      }\n    } else if (fingers.length === 2) {\n      box.show = true;\n      this.isTwoFingering = true;\n      const {separation} = this.fingerPolar(fingers);\n      this.firstRatio = separation / scene.pivot.scale.x;\n    }\n  };\n\n  private onSelectEnd = () => {\n    this.isTranslating = false;\n    this.isRotating = false;\n    this.isTwoFingering = false;\n    this.inputSource = null;\n    this.goalPosition.y +=\n        this.placementBox!.offsetHeight * this.presentedScene!.scale.x;\n    this.placementBox!.show = false\n  };\n\n  private fingerPolar(fingers: XRTransientInputHitTestResult[]):\n      {separation: number, deltaYaw: number} {\n    const fingerOne = fingers[0].inputSource.gamepad!.axes;\n    const fingerTwo = fingers[1].inputSource.gamepad!.axes;\n    const deltaX = fingerTwo[0] - fingerOne[0];\n    const deltaY = fingerTwo[1] - fingerOne[1];\n    const angle = Math.atan2(deltaY, deltaX);\n    let deltaYaw = this.lastAngle - angle;\n    if (deltaYaw > Math.PI) {\n      deltaYaw -= 2 * Math.PI;\n    } else if (deltaYaw < -Math.PI) {\n      deltaYaw += 2 * Math.PI;\n    }\n    this.lastAngle = angle;\n    return {\n      separation: Math.sqrt(deltaX * deltaX + deltaY * deltaY),\n      deltaYaw: deltaYaw\n    };\n  }\n\n  private setScale(separation: number) {\n    const scale = separation / this.firstRatio;\n    this.goalScale = (Math.abs(scale - 1) < SCALE_SNAP) ? 1 : scale;\n  }\n\n  private processInput(frame: XRFrame) {\n    const hitSource = this.transientHitTestSource;\n    if (hitSource == null) {\n      return;\n    }\n    if (!this.isTranslating && !this.isTwoFingering && !this.isRotating) {\n      return;\n    }\n    const fingers = frame.getHitTestResultsForTransientInput(hitSource);\n    const scene = this.presentedScene!;\n    const scale = scene.pivot.scale.x;\n\n    // Rotating, translating and scaling are mutually exclusive operations; only\n    // one can happen at a time, but we can switch during a gesture.\n    if (this.isTwoFingering) {\n      if (fingers.length < 2) {\n        // If we lose the second finger, stop scaling (in fact, stop processing\n        // input altogether until a new gesture starts).\n        this.isTwoFingering = false;\n      } else {\n        const {separation, deltaYaw} = this.fingerPolar(fingers);\n        if (this.placeOnWall === false) {\n          this.goalYaw += deltaYaw;\n        }\n        if (scene.canScale) {\n          this.setScale(separation);\n        }\n      }\n      return;\n    } else if (fingers.length === 2) {\n      // If we were rotating or translating and we get a second finger, switch\n      // to scaling instead.\n      this.isTranslating = false;\n      this.isRotating = false;\n      this.isTwoFingering = true;\n      const {separation} = this.fingerPolar(fingers);\n      this.firstRatio = separation / scale;\n      return;\n    }\n\n    if (this.isRotating) {\n      const angle = this.inputSource!.gamepad!.axes[0] * ROTATION_RATE;\n      this.goalYaw += angle - this.lastAngle;\n      this.lastAngle = angle;\n    } else if (this.isTranslating) {\n      fingers.forEach(finger => {\n        if (finger.inputSource !== this.inputSource) {\n          return;\n        }\n\n        let hit = null;\n        if (finger.results.length > 0) {\n          hit = this.getHitPoint(finger.results[0]);\n        }\n        if (hit == null) {\n          hit = this.getTouchLocation();\n        }\n        if (hit == null) {\n          return;\n        }\n\n        this.goalPosition.sub(this.lastDragPosition);\n\n        if (this.placeOnWall === false) {\n          const offset = hit.y - this.lastDragPosition.y;\n          // When a lower floor is found, keep the model at the same height, but\n          // drop the placement box to the floor. The model falls on select end.\n          if (offset < 0) {\n            this.placementBox!.offsetHeight = offset / scale;\n            this.presentedScene!.setShadowOffset(offset);\n            // Interpolate hit ray up to drag plane\n            const cameraPosition = vector3.copy(scene.getCamera().position);\n            const alpha = -offset / (cameraPosition.y - hit.y);\n            cameraPosition.multiplyScalar(alpha);\n            hit.multiplyScalar(1 - alpha).add(cameraPosition);\n          }\n        }\n\n        this.goalPosition.add(hit);\n        this.lastDragPosition.copy(hit);\n      });\n    }\n  }\n\n  private moveScene(delta: number) {\n    const scene = this.presentedScene!;\n    const {pivot} = scene;\n    const box = this.placementBox!;\n    box.updateOpacity(delta);\n\n    if (this.controller1) {\n      if (this.controller1.userData.turning) {\n        pivot.quaternion.copy(this.controller1.quaternion)\n            .multiply(this.relativeOrientation);\n        if (this.selectedController &&\n            this.selectedController === this.controller2) {\n          pivot.quaternion.premultiply(\n              quaternion.copy(this.controller2.quaternion).invert());\n        }\n      }\n      this.controller1.userData.box.position.copy(this.controller1.position);\n      pivot.getWorldQuaternion(this.controller1.userData.box.quaternion);\n    }\n\n    if (this.controller2) {\n      if (this.controller2.userData.turning) {\n        pivot.quaternion.copy(this.controller2.quaternion)\n            .multiply(this.relativeOrientation);\n        if (this.selectedController &&\n            this.selectedController === this.controller1) {\n          pivot.quaternion.premultiply(\n              quaternion.copy(this.controller1.quaternion).invert());\n        }\n      }\n      this.controller2.userData.box.position.copy(this.controller2.position);\n      pivot.getWorldQuaternion(this.controller2.userData.box.quaternion);\n    }\n\n    if (this.controller1 && this.controller2 && this.isTwoFingering) {\n      const dist = this.controllerSeparation();\n      this.setScale(dist);\n      this.scaleLine.scale.z = -dist;\n      this.scaleLine.lookAt(this.controller2.position);\n    }\n\n    const oldScale = scene.pivot.scale.x;\n    if (this.goalScale !== oldScale) {\n      const newScale =\n          this.scaleDamper.update(oldScale, this.goalScale, delta, 1);\n      scene.pivot.scale.set(newScale, newScale, newScale);\n    }\n\n    if (pivot.parent !== scene) {\n      return;  // attached to controller instead\n    }\n    const {position} = pivot;\n    const boundingRadius = scene.boundingSphere.radius;\n    const goal = this.goalPosition;\n\n    let source = ChangeSource.NONE;\n    if (!goal.equals(position)) {\n      source = ChangeSource.USER_INTERACTION;\n      let {x, y, z} = position;\n      x = this.xDamper.update(x, goal.x, delta, boundingRadius);\n      y = this.yDamper.update(y, goal.y, delta, boundingRadius);\n      z = this.zDamper.update(z, goal.z, delta, boundingRadius);\n      position.set(x, y, z);\n\n      if (this.xrMode === 'screen-space' && !this.isTranslating) {\n        const offset = goal.y - y;\n        if (this.placementComplete && this.placeOnWall === false) {\n          box.offsetHeight = offset / scene.pivot.scale.x;\n          scene.setShadowOffset(offset);\n        } else if (offset === 0) {\n          this.placementComplete = true;\n          box.show = false;\n          scene.setShadowIntensity(AR_SHADOW_INTENSITY);\n        }\n      }\n      if (this.xrMode !== 'screen-space' && goal.equals(position)) {\n        scene.setShadowIntensity(AR_SHADOW_INTENSITY);\n      }\n    }\n    scene.updateTarget(delta);\n    // yaw must be updated last, since this also updates the shadow position.\n    quaternion.setFromAxisAngle(vector3.set(0, 1, 0), this.goalYaw);\n    const angle = scene.pivot.quaternion.angleTo(quaternion);\n    const angleStep = angle - this.yawDamper.update(angle, 0, delta, Math.PI);\n    scene.pivot.quaternion.rotateTowards(quaternion, angleStep);\n    // camera changes on every frame - user-interaction only if touching the\n    // screen, plus damping time.\n    scene.element.dispatchEvent(new CustomEvent<CameraChangeDetails>(\n        'camera-change', {detail: {source}}));\n  }\n\n  /**\n   * Only public to make it testable.\n   */\n  public onWebXRFrame(time: number, frame: XRFrame) {\n    if (this.xrMode !== 'screen-space') {\n      const over1 = this.hover(this.controller1!);\n      const over2 = this.hover(this.controller2!);\n      this.placementBox!.show = (over1 || over2) && !this.isTwoFingering;\n    }\n\n    this.frame = frame;\n    ++this.frames;\n    const refSpace = this.threeRenderer.xr.getReferenceSpace()!;\n    const pose = frame.getViewerPose(refSpace);\n\n    if (pose == null && this.tracking === true && this.frames > INIT_FRAMES) {\n      this.tracking = false;\n      this.dispatchEvent({type: 'tracking', status: ARTracking.NOT_TRACKING});\n    }\n\n    const scene = this.presentedScene;\n    if (pose == null || scene == null || !scene.element.loaded) {\n      this.threeRenderer.clear();\n      return;\n    }\n\n    if (this.tracking === false) {\n      this.tracking = true;\n      this.dispatchEvent({type: 'tracking', status: ARTracking.TRACKING});\n    }\n\n    // WebXR may return multiple views, i.e. for headset AR. This\n    // isn't really supported at this point, but make a best-effort\n    // attempt to render other views also, using the first view\n    // as the main viewpoint.\n    let isFirstView: boolean = true;\n    for (const view of pose.views) {\n      this.updateView(view);\n\n      if (isFirstView) {\n        this.moveToFloor(frame);\n\n        this.processInput(frame);\n\n        const delta = time - this.lastTick!;\n        this.moveScene(delta);\n        this.renderer.preRender(scene, time, delta);\n        this.lastTick = time;\n\n        scene.renderShadow(this.threeRenderer);\n      }\n\n      this.threeRenderer.render(scene, scene.getCamera());\n      isFirstView = false;\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}