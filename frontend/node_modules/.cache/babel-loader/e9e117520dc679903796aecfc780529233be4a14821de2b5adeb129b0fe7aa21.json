{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport * as THREE from \"three\";\nexport default {\n  name: \"ThreeDBox\",\n  props: {\n    image: {\n      type: String,\n      required: false\n    },\n    imageFront: {\n      type: String,\n      required: false\n    },\n    imageSide: {\n      type: String,\n      required: false\n    },\n    imageBack: {\n      type: String,\n      required: false\n    },\n    imageTop: {\n      type: String,\n      required: false\n    },\n    imageBottom: {\n      type: String,\n      required: false\n    }\n  },\n  data() {\n    return {\n      // We don't want Vue to make these reactive because Three.js objects are complex\n      // and Vue's proxying can interfere with internal properties like modelViewMatrix\n    };\n  },\n  mounted() {\n    // Store Three.js objects as non-reactive properties on the instance\n    this.scene = null;\n    this.camera = null;\n    this.renderer = null;\n    this.cube = null;\n    this.animationId = null;\n    this.initThree();\n    window.addEventListener(\"resize\", this.handleResize);\n  },\n  beforeUnmount() {\n    this.cleanup();\n    window.removeEventListener(\"resize\", this.handleResize);\n  },\n  methods: {\n    initThree() {\n      const container = this.$refs.container;\n      const width = container.clientWidth;\n      const height = container.clientHeight;\n\n      // Scene\n      this.scene = new THREE.Scene();\n      this.scene.background = new THREE.Color(0xf0f0f0);\n\n      // Camera\n      this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);\n      this.camera.position.z = 2;\n\n      // Renderer\n      this.renderer = new THREE.WebGLRenderer({\n        antialias: true\n      });\n      this.renderer.setSize(width, height);\n      container.appendChild(this.renderer.domElement);\n\n      // Lights\n      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);\n      this.scene.add(ambientLight);\n      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);\n      directionalLight.position.set(1, 1, 1);\n      this.scene.add(directionalLight);\n      const textureLoader = new THREE.TextureLoader();\n\n      // Check if we have front+back images (new format) or single image (legacy format)\n      const has2Images = this.imageFront && this.imageBack;\n      if (has2Images) {\n        this.loadAndCreateCubeWith3Images(textureLoader);\n      } else if (this.image) {\n        this.loadAndCreateCubeWithSingleImage(textureLoader);\n      } else {\n        console.error(\"No image provided\");\n      }\n      this.animate();\n    },\n    loadAndCreateCubeWithSingleImage(textureLoader) {\n      textureLoader.load(this.image, texture => {\n        const geometry = new THREE.BoxGeometry(1, 1, 1);\n        const material = new THREE.MeshStandardMaterial({\n          map: texture\n        });\n        this.cube = new THREE.Mesh(geometry, material);\n        this.scene.add(this.cube);\n      }, undefined, err => {\n        console.error(\"Error loading texture:\", err);\n      });\n    },\n    loadAndCreateCubeWith3Images(textureLoader) {\n      // Load front and back images (required), side, top, and bottom optional\n      const texturePromises = [this.loadTexture(textureLoader, this.imageFront), this.loadTexture(textureLoader, this.imageBack), this.imageSide ? this.loadTexture(textureLoader, this.imageSide) : Promise.resolve(null), this.imageTop ? this.loadTexture(textureLoader, this.imageTop) : Promise.resolve(null), this.imageBottom ? this.loadTexture(textureLoader, this.imageBottom) : Promise.resolve(null)];\n      Promise.all(texturePromises).then(([frontTexture, backTexture, sideTexture, topTexture, bottomTexture]) => {\n        // Realistic packet dimensions: width x height x depth\n        // Typically product packets are taller than wide\n        const geometry = new THREE.BoxGeometry(0.6, 1.2, 0.3);\n\n        // Gray material for edges (top, bottom, left, right if no side image)\n        const grayMaterial = new THREE.MeshStandardMaterial({\n          color: 0xd0d0d0,\n          roughness: 0.7\n        });\n\n        // Create material array for 6 faces:\n        // [right(0), left(1), top(2), bottom(3), front(4), back(5)]\n        const materials = [];\n\n        // Left and right faces (use side image if available, else gray)\n        if (sideTexture) {\n          materials.push(new THREE.MeshStandardMaterial({\n            map: sideTexture\n          })); // right (0)\n          materials.push(new THREE.MeshStandardMaterial({\n            map: sideTexture\n          })); // left (1)\n        } else {\n          materials.push(grayMaterial.clone()); // right (0)\n          materials.push(grayMaterial.clone()); // left (1)\n        }\n\n        // Top and bottom faces (use separate images if available, else gray)\n        if (topTexture) {\n          materials.push(new THREE.MeshStandardMaterial({\n            map: topTexture\n          })); // top (2)\n        } else {\n          materials.push(grayMaterial.clone()); // top (2)\n        }\n        if (bottomTexture) {\n          materials.push(new THREE.MeshStandardMaterial({\n            map: bottomTexture\n          })); // bottom (3)\n        } else {\n          materials.push(grayMaterial.clone()); // bottom (3)\n        }\n\n        // Front and back faces (required)\n        materials.push(new THREE.MeshStandardMaterial({\n          map: frontTexture\n        })); // front (4)\n        materials.push(new THREE.MeshStandardMaterial({\n          map: backTexture\n        })); // back (5)\n\n        this.cube = new THREE.Mesh(geometry, materials);\n        this.scene.add(this.cube);\n      }).catch(err => {\n        console.error(\"Error loading textures:\", err);\n      });\n    },\n    loadTexture(textureLoader, imagePath) {\n      return new Promise((resolve, reject) => {\n        textureLoader.load(imagePath, texture => resolve(texture), undefined, err => reject(err));\n      });\n    },\n    animate() {\n      this.animationId = requestAnimationFrame(this.animate);\n      if (this.cube) {\n        this.cube.rotation.x += 0.005;\n        this.cube.rotation.y += 0.01;\n      }\n      if (this.renderer && this.scene && this.camera) {\n        this.renderer.render(this.scene, this.camera);\n      }\n    },\n    handleResize() {\n      if (!this.$refs.container) return;\n      const width = this.$refs.container.clientWidth;\n      const height = this.$refs.container.clientHeight;\n      if (this.camera) {\n        this.camera.aspect = width / height;\n        this.camera.updateProjectionMatrix();\n      }\n      if (this.renderer) {\n        this.renderer.setSize(width, height);\n      }\n    },\n    cleanup() {\n      if (this.animationId) cancelAnimationFrame(this.animationId);\n      if (this.renderer) {\n        this.renderer.dispose();\n        if (this.$refs.container && this.renderer.domElement) {\n          this.$refs.container.removeChild(this.renderer.domElement);\n        }\n      }\n      if (this.cube) {\n        this.cube.geometry.dispose();\n        if (Array.isArray(this.cube.material)) {\n          this.cube.material.forEach(m => m.dispose());\n        } else {\n          this.cube.material.dispose();\n        }\n      }\n    }\n  }\n};","map":{"version":3,"names":["THREE","name","props","image","type","String","required","imageFront","imageSide","imageBack","imageTop","imageBottom","data","mounted","scene","camera","renderer","cube","animationId","initThree","window","addEventListener","handleResize","beforeUnmount","cleanup","removeEventListener","methods","container","$refs","width","clientWidth","height","clientHeight","Scene","background","Color","PerspectiveCamera","position","z","WebGLRenderer","antialias","setSize","appendChild","domElement","ambientLight","AmbientLight","add","directionalLight","DirectionalLight","set","textureLoader","TextureLoader","has2Images","loadAndCreateCubeWith3Images","loadAndCreateCubeWithSingleImage","console","error","animate","load","texture","geometry","BoxGeometry","material","MeshStandardMaterial","map","Mesh","undefined","err","texturePromises","loadTexture","Promise","resolve","all","then","frontTexture","backTexture","sideTexture","topTexture","bottomTexture","grayMaterial","color","roughness","materials","push","clone","catch","imagePath","reject","requestAnimationFrame","rotation","x","y","render","aspect","updateProjectionMatrix","cancelAnimationFrame","dispose","removeChild","Array","isArray","forEach","m"],"sources":["C:\\Users\\LENOVO\\Music\\OneDrive\\Pictures\\distribution-agency-project\\frontend\\src\\components\\ThreeDBox.vue"],"sourcesContent":["<template>\n  <div ref=\"container\" class=\"three-container\"></div>\n</template>\n\n<script>\nimport * as THREE from \"three\";\n\nexport default {\n  name: \"ThreeDBox\",\n  props: {\n    image: {\n      type: String,\n      required: false,\n    },\n    imageFront: {\n      type: String,\n      required: false,\n    },\n    imageSide: {\n      type: String,\n      required: false,\n    },\n    imageBack: {\n      type: String,\n      required: false,\n    },\n    imageTop: {\n      type: String,\n      required: false,\n    },\n    imageBottom: {\n      type: String,\n      required: false,\n    },\n  },\n  data() {\n    return {\n      // We don't want Vue to make these reactive because Three.js objects are complex\n      // and Vue's proxying can interfere with internal properties like modelViewMatrix\n    };\n  },\n  mounted() {\n    // Store Three.js objects as non-reactive properties on the instance\n    this.scene = null;\n    this.camera = null;\n    this.renderer = null;\n    this.cube = null;\n    this.animationId = null;\n\n    this.initThree();\n    window.addEventListener(\"resize\", this.handleResize);\n  },\n  beforeUnmount() {\n    this.cleanup();\n    window.removeEventListener(\"resize\", this.handleResize);\n  },\n  methods: {\n    initThree() {\n      const container = this.$refs.container;\n      const width = container.clientWidth;\n      const height = container.clientHeight;\n\n      // Scene\n      this.scene = new THREE.Scene();\n      this.scene.background = new THREE.Color(0xf0f0f0);\n\n      // Camera\n      this.camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);\n      this.camera.position.z = 2;\n\n      // Renderer\n      this.renderer = new THREE.WebGLRenderer({ antialias: true });\n      this.renderer.setSize(width, height);\n      container.appendChild(this.renderer.domElement);\n\n      // Lights\n      const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);\n      this.scene.add(ambientLight);\n\n      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);\n      directionalLight.position.set(1, 1, 1);\n      this.scene.add(directionalLight);\n\n      const textureLoader = new THREE.TextureLoader();\n\n      // Check if we have front+back images (new format) or single image (legacy format)\n      const has2Images = this.imageFront && this.imageBack;\n\n      if (has2Images) {\n        this.loadAndCreateCubeWith3Images(textureLoader);\n      } else if (this.image) {\n        this.loadAndCreateCubeWithSingleImage(textureLoader);\n      } else {\n        console.error(\"No image provided\");\n      }\n\n      this.animate();\n    },\n\n    loadAndCreateCubeWithSingleImage(textureLoader) {\n      textureLoader.load(\n        this.image,\n        (texture) => {\n          const geometry = new THREE.BoxGeometry(1, 1, 1);\n          const material = new THREE.MeshStandardMaterial({ map: texture });\n          this.cube = new THREE.Mesh(geometry, material);\n          this.scene.add(this.cube);\n        },\n        undefined,\n        (err) => {\n          console.error(\"Error loading texture:\", err);\n        }\n      );\n    },\n\n    loadAndCreateCubeWith3Images(textureLoader) {\n      // Load front and back images (required), side, top, and bottom optional\n      const texturePromises = [\n        this.loadTexture(textureLoader, this.imageFront),\n        this.loadTexture(textureLoader, this.imageBack),\n        this.imageSide\n          ? this.loadTexture(textureLoader, this.imageSide)\n          : Promise.resolve(null),\n        this.imageTop\n          ? this.loadTexture(textureLoader, this.imageTop)\n          : Promise.resolve(null),\n        this.imageBottom\n          ? this.loadTexture(textureLoader, this.imageBottom)\n          : Promise.resolve(null),\n      ];\n\n      Promise.all(texturePromises)\n        .then(\n          ([\n            frontTexture,\n            backTexture,\n            sideTexture,\n            topTexture,\n            bottomTexture,\n          ]) => {\n            // Realistic packet dimensions: width x height x depth\n            // Typically product packets are taller than wide\n            const geometry = new THREE.BoxGeometry(0.6, 1.2, 0.3);\n\n            // Gray material for edges (top, bottom, left, right if no side image)\n            const grayMaterial = new THREE.MeshStandardMaterial({\n              color: 0xd0d0d0,\n              roughness: 0.7,\n            });\n\n            // Create material array for 6 faces:\n            // [right(0), left(1), top(2), bottom(3), front(4), back(5)]\n            const materials = [];\n\n            // Left and right faces (use side image if available, else gray)\n            if (sideTexture) {\n              materials.push(\n                new THREE.MeshStandardMaterial({ map: sideTexture })\n              ); // right (0)\n              materials.push(\n                new THREE.MeshStandardMaterial({ map: sideTexture })\n              ); // left (1)\n            } else {\n              materials.push(grayMaterial.clone()); // right (0)\n              materials.push(grayMaterial.clone()); // left (1)\n            }\n\n            // Top and bottom faces (use separate images if available, else gray)\n            if (topTexture) {\n              materials.push(\n                new THREE.MeshStandardMaterial({ map: topTexture })\n              ); // top (2)\n            } else {\n              materials.push(grayMaterial.clone()); // top (2)\n            }\n\n            if (bottomTexture) {\n              materials.push(\n                new THREE.MeshStandardMaterial({ map: bottomTexture })\n              ); // bottom (3)\n            } else {\n              materials.push(grayMaterial.clone()); // bottom (3)\n            }\n\n            // Front and back faces (required)\n            materials.push(\n              new THREE.MeshStandardMaterial({ map: frontTexture })\n            ); // front (4)\n            materials.push(\n              new THREE.MeshStandardMaterial({ map: backTexture })\n            ); // back (5)\n\n            this.cube = new THREE.Mesh(geometry, materials);\n            this.scene.add(this.cube);\n          }\n        )\n        .catch((err) => {\n          console.error(\"Error loading textures:\", err);\n        });\n    },\n\n    loadTexture(textureLoader, imagePath) {\n      return new Promise((resolve, reject) => {\n        textureLoader.load(\n          imagePath,\n          (texture) => resolve(texture),\n          undefined,\n          (err) => reject(err)\n        );\n      });\n    },\n    animate() {\n      this.animationId = requestAnimationFrame(this.animate);\n\n      if (this.cube) {\n        this.cube.rotation.x += 0.005;\n        this.cube.rotation.y += 0.01;\n      }\n\n      if (this.renderer && this.scene && this.camera) {\n        this.renderer.render(this.scene, this.camera);\n      }\n    },\n    handleResize() {\n      if (!this.$refs.container) return;\n      const width = this.$refs.container.clientWidth;\n      const height = this.$refs.container.clientHeight;\n\n      if (this.camera) {\n        this.camera.aspect = width / height;\n        this.camera.updateProjectionMatrix();\n      }\n\n      if (this.renderer) {\n        this.renderer.setSize(width, height);\n      }\n    },\n    cleanup() {\n      if (this.animationId) cancelAnimationFrame(this.animationId);\n      if (this.renderer) {\n        this.renderer.dispose();\n        if (this.$refs.container && this.renderer.domElement) {\n          this.$refs.container.removeChild(this.renderer.domElement);\n        }\n      }\n      if (this.cube) {\n        this.cube.geometry.dispose();\n        if (Array.isArray(this.cube.material)) {\n          this.cube.material.forEach((m) => m.dispose());\n        } else {\n          this.cube.material.dispose();\n        }\n      }\n    },\n  },\n};\n</script>\n\n<style scoped>\n.three-container {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n</style>\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}