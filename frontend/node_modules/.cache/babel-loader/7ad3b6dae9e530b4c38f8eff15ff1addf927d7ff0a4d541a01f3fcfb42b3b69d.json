{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\n/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c, _d, _e, _f;\nimport { Mesh } from 'three';\nimport { $setActive, $variantIndices, Material } from './material.js';\nimport { Node, PrimitiveNode } from './nodes/primitive-node.js';\nimport { $correlatedObjects } from './three-dom-element.js';\nexport const $materials = Symbol('materials');\nconst $hierarchy = Symbol('hierarchy');\nconst $roots = Symbol('roots');\nexport const $primitivesList = Symbol('primitives');\nexport const $loadVariant = Symbol('loadVariant');\nexport const $prepareVariantsForExport = Symbol('prepareVariantsForExport');\nexport const $switchVariant = Symbol('switchVariant');\nexport const $materialFromPoint = Symbol('materialFromPoint');\nexport const $nodeFromPoint = Symbol('nodeFromPoint');\nexport const $nodeFromIndex = Symbol('nodeFromIndex');\nexport const $variantData = Symbol('variantData');\nexport const $availableVariants = Symbol('availableVariants');\nconst $modelOnUpdate = Symbol('modelOnUpdate');\nconst $cloneMaterial = Symbol('cloneMaterial');\n// Holds onto temporary scene context information needed to perform lazy loading\n// of a resource.\nexport class LazyLoader {\n  constructor(gltf, gltfElementMap, mapKey, doLazyLoad) {\n    this.gltf = gltf;\n    this.gltfElementMap = gltfElementMap;\n    this.mapKey = mapKey;\n    this.doLazyLoad = doLazyLoad;\n  }\n}\n/**\n * A Model facades the top-level GLTF object returned by Three.js' GLTFLoader.\n * Currently, the model only bothers itself with the materials in the Three.js\n * scene graph.\n */\nexport class Model {\n  constructor(correlatedSceneGraph, onUpdate = () => {}) {\n    this[_a] = new Array();\n    this[_b] = new Array();\n    this[_c] = new Array();\n    this[_d] = new Array();\n    this[_e] = () => {};\n    this[_f] = new Map();\n    this[$modelOnUpdate] = onUpdate;\n    const {\n      gltf,\n      threeGLTF,\n      gltfElementMap\n    } = correlatedSceneGraph;\n    for (const [i, material] of gltf.materials.entries()) {\n      const correlatedMaterial = gltfElementMap.get(material);\n      if (correlatedMaterial != null) {\n        this[$materials].push(new Material(onUpdate, i, true, this[$variantData], correlatedMaterial, material.name));\n      } else {\n        const elementArray = gltf['materials'] || [];\n        const gltfMaterialDef = elementArray[i];\n        const threeMaterialSet = new Set();\n        gltfElementMap.set(gltfMaterialDef, threeMaterialSet);\n        const materialLoadCallback = async () => {\n          const threeMaterial = await threeGLTF.parser.getDependency('material', i);\n          threeMaterialSet.add(threeMaterial);\n          return threeMaterial;\n        };\n        // Configures the material for lazy loading.\n        this[$materials].push(new Material(onUpdate, i, false, this[$variantData], threeMaterialSet, material.name, new LazyLoader(gltf, gltfElementMap, gltfMaterialDef, materialLoadCallback)));\n      }\n    }\n    // Creates a hierarchy of Nodes. Allows not just for switching which\n    // material is applied to a mesh but also exposes a way to provide API\n    // for switching materials and general assignment/modification.\n    // Prepares for scene iteration.\n    const parentMap = new Map();\n    const nodeStack = new Array();\n    for (const object of threeGLTF.scene.children) {\n      nodeStack.push(object);\n    }\n    // Walks the hierarchy and creates a node tree.\n    while (nodeStack.length > 0) {\n      const object = nodeStack.pop();\n      let node = null;\n      if (object instanceof Mesh) {\n        node = new PrimitiveNode(object, this.materials, this[$variantData], correlatedSceneGraph);\n        this[$primitivesList].push(node);\n      } else {\n        node = new Node(object.name);\n      }\n      const parent = parentMap.get(object);\n      if (parent != null) {\n        parent.children.push(node);\n      } else {\n        this[$roots].push(node);\n      }\n      this[$hierarchy].push(node);\n      for (const child of object.children) {\n        nodeStack.push(child);\n        parentMap.set(object, node);\n      }\n    }\n  }\n  /**\n   * Materials are listed in the order of the GLTF materials array, plus a\n   * default material at the end if one is used.\n   *\n   * TODO(#1003): How do we handle non-active scenes?\n   */\n  get materials() {\n    return this[$materials];\n  }\n  [(_a = $materials, _b = $hierarchy, _c = $roots, _d = $primitivesList, _e = $modelOnUpdate, _f = $variantData, $availableVariants)]() {\n    const variants = Array.from(this[$variantData].values());\n    variants.sort((a, b) => {\n      return a.index - b.index;\n    });\n    return variants.map(data => {\n      return data.name;\n    });\n  }\n  getMaterialByName(name) {\n    const matches = this[$materials].filter(material => {\n      return material.name === name;\n    });\n    if (matches.length > 0) {\n      return matches[0];\n    }\n    return null;\n  }\n  [$nodeFromIndex](mesh, primitive) {\n    const found = this[$hierarchy].find(node => {\n      if (node instanceof PrimitiveNode) {\n        const {\n          meshes,\n          primitives\n        } = node.mesh.userData.associations;\n        if (meshes == mesh && primitives == primitive) {\n          return true;\n        }\n      }\n      return false;\n    });\n    return found == null ? null : found;\n  }\n  [$nodeFromPoint](hit) {\n    return this[$hierarchy].find(node => {\n      if (node instanceof PrimitiveNode) {\n        const primitive = node;\n        if (primitive.mesh === hit.object) {\n          return true;\n        }\n      }\n      return false;\n    });\n  }\n  /**\n   * Intersects a ray with the Model and returns the first material whose\n   * object was intersected.\n   */\n  [$materialFromPoint](hit) {\n    return this[$nodeFromPoint](hit).getActiveMaterial();\n  }\n  /**\n   * Switches model variant to the variant name provided, or switches to\n   * default/initial materials if 'null' is provided.\n   */\n  async [$switchVariant](variantName) {\n    for (const primitive of this[$primitivesList]) {\n      await primitive.enableVariant(variantName);\n    }\n    for (const material of this.materials) {\n      material[$setActive](false);\n    }\n    // Marks the materials that are now in use after the variant switch.\n    for (const primitive of this[$primitivesList]) {\n      this.materials[primitive.getActiveMaterial().index][$setActive](true);\n    }\n  }\n  async [$prepareVariantsForExport]() {\n    const promises = new Array();\n    for (const primitive of this[$primitivesList]) {\n      promises.push(primitive.instantiateVariants());\n    }\n    await Promise.all(promises);\n  }\n  [$cloneMaterial](index, newMaterialName) {\n    const material = this.materials[index];\n    if (!material.isLoaded) {\n      console.error(`Cloning an unloaded material,\n           call 'material.ensureLoaded() before cloning the material.`);\n    }\n    const threeMaterialSet = material[$correlatedObjects];\n    const clonedSet = new Set();\n    for (const [i, threeMaterial] of threeMaterialSet.entries()) {\n      const clone = threeMaterial.clone();\n      clone.name = newMaterialName + (threeMaterialSet.size > 1 ? '_inst' + i : '');\n      clonedSet.add(clone);\n    }\n    const clonedMaterial = new Material(this[$modelOnUpdate], this[$materials].length, false,\n    // Cloned as inactive.\n    this[$variantData], clonedSet, newMaterialName);\n    this[$materials].push(clonedMaterial);\n    return clonedMaterial;\n  }\n  createMaterialInstanceForVariant(originalMaterialIndex, newMaterialName, variantName, activateVariant = true) {\n    let variantMaterialInstance = null;\n    for (const primitive of this[$primitivesList]) {\n      const variantData = this[$variantData].get(variantName);\n      // Skips the primitive if the variant already exists.\n      if (variantData != null && primitive.variantInfo.has(variantData.index)) {\n        continue;\n      }\n      // Skips the primitive if the source/original material does not exist.\n      if (primitive.getMaterial(originalMaterialIndex) == null) {\n        continue;\n      }\n      if (!this.hasVariant(variantName)) {\n        this.createVariant(variantName);\n      }\n      if (variantMaterialInstance == null) {\n        variantMaterialInstance = this[$cloneMaterial](originalMaterialIndex, newMaterialName);\n      }\n      primitive.addVariant(variantMaterialInstance, variantName);\n    }\n    if (activateVariant && variantMaterialInstance != null) {\n      variantMaterialInstance[$setActive](true);\n      this.materials[originalMaterialIndex][$setActive](false);\n      for (const primitive of this[$primitivesList]) {\n        primitive.enableVariant(variantName);\n      }\n    }\n    return variantMaterialInstance;\n  }\n  createVariant(variantName) {\n    if (!this[$variantData].has(variantName)) {\n      // Adds the name if it's not already in the list.\n      this[$variantData].set(variantName, {\n        name: variantName,\n        index: this[$variantData].size\n      });\n    } else {\n      console.warn(`Variant '${variantName}'' already exists`);\n    }\n  }\n  hasVariant(variantName) {\n    return this[$variantData].has(variantName);\n  }\n  setMaterialToVariant(materialIndex, targetVariantName) {\n    if (this[$availableVariants]().find(name => name === targetVariantName) == null) {\n      console.warn(`Can't add material to '${targetVariantName}', the variant does not exist.'`);\n      return;\n    }\n    if (materialIndex < 0 || materialIndex >= this.materials.length) {\n      console.error(`setMaterialToVariant(): materialIndex is out of bounds.`);\n      return;\n    }\n    for (const primitive of this[$primitivesList]) {\n      const material = primitive.getMaterial(materialIndex);\n      // Ensures the material exists on the primitive before setting it to a\n      // variant.\n      if (material != null) {\n        primitive.addVariant(material, targetVariantName);\n      }\n    }\n  }\n  updateVariantName(currentName, newName) {\n    const variantData = this[$variantData].get(currentName);\n    if (variantData == null) {\n      return;\n    }\n    variantData.name = newName;\n    this[$variantData].set(newName, variantData);\n    this[$variantData].delete(currentName);\n  }\n  deleteVariant(variantName) {\n    const variant = this[$variantData].get(variantName);\n    if (variant == null) {\n      return;\n    }\n    for (const material of this.materials) {\n      if (material.hasVariant(variantName)) {\n        material[$variantIndices].delete(variant.index);\n      }\n    }\n    for (const primitive of this[$primitivesList]) {\n      primitive.deleteVariant(variant.index);\n    }\n    this[$variantData].delete(variantName);\n  }\n}","map":{"version":3,"names":["Mesh","$setActive","$variantIndices","Material","Node","PrimitiveNode","$correlatedObjects","$materials","Symbol","$hierarchy","$roots","$primitivesList","$loadVariant","$prepareVariantsForExport","$switchVariant","$materialFromPoint","$nodeFromPoint","$nodeFromIndex","$variantData","$availableVariants","$modelOnUpdate","$cloneMaterial","LazyLoader","constructor","gltf","gltfElementMap","mapKey","doLazyLoad","Model","correlatedSceneGraph","onUpdate","_a","Array","_b","_c","_d","_e","_f","Map","threeGLTF","i","material","materials","entries","correlatedMaterial","get","push","name","elementArray","gltfMaterialDef","threeMaterialSet","Set","set","materialLoadCallback","threeMaterial","parser","getDependency","add","parentMap","nodeStack","object","scene","children","length","pop","node","parent","child","variants","from","values","sort","a","b","index","map","data","getMaterialByName","matches","filter","mesh","primitive","found","find","meshes","primitives","userData","associations","hit","getActiveMaterial","variantName","enableVariant","promises","instantiateVariants","Promise","all","newMaterialName","isLoaded","console","error","clonedSet","clone","size","clonedMaterial","createMaterialInstanceForVariant","originalMaterialIndex","activateVariant","variantMaterialInstance","variantData","variantInfo","has","getMaterial","hasVariant","createVariant","addVariant","warn","setMaterialToVariant","materialIndex","targetVariantName","updateVariantName","currentName","newName","delete","deleteVariant","variant"],"sources":["../../../src/features/scene-graph/model.ts"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Intersection, Material as ThreeMaterial, Mesh, MeshPhysicalMaterial, Object3D} from 'three';\n\nimport {CorrelatedSceneGraph, GLTFElementToThreeObjectMap} from '../../three-components/gltf-instance/correlated-scene-graph.js';\nimport {GLTF, GLTFElement} from '../../three-components/gltf-instance/gltf-2.0.js';\n\nimport {Model as ModelInterface} from './api.js';\nimport {$setActive, $variantIndices, Material} from './material.js';\nimport {Node, PrimitiveNode} from './nodes/primitive-node.js';\nimport {$correlatedObjects} from './three-dom-element.js';\n\n\n\nexport const $materials = Symbol('materials');\nconst $hierarchy = Symbol('hierarchy');\nconst $roots = Symbol('roots');\nexport const $primitivesList = Symbol('primitives');\nexport const $loadVariant = Symbol('loadVariant');\nexport const $prepareVariantsForExport = Symbol('prepareVariantsForExport');\nexport const $switchVariant = Symbol('switchVariant');\nexport const $materialFromPoint = Symbol('materialFromPoint');\nexport const $nodeFromPoint = Symbol('nodeFromPoint');\nexport const $nodeFromIndex = Symbol('nodeFromIndex');\nexport const $variantData = Symbol('variantData');\nexport const $availableVariants = Symbol('availableVariants');\nconst $modelOnUpdate = Symbol('modelOnUpdate');\nconst $cloneMaterial = Symbol('cloneMaterial');\n\n// Holds onto temporary scene context information needed to perform lazy loading\n// of a resource.\nexport class LazyLoader {\n  gltf: GLTF;\n  gltfElementMap: GLTFElementToThreeObjectMap;\n  mapKey: GLTFElement;\n  doLazyLoad: () => Promise<ThreeMaterial>;\n  constructor(\n      gltf: GLTF, gltfElementMap: GLTFElementToThreeObjectMap,\n      mapKey: GLTFElement, doLazyLoad: () => Promise<ThreeMaterial>) {\n    this.gltf = gltf;\n    this.gltfElementMap = gltfElementMap;\n    this.mapKey = mapKey;\n    this.doLazyLoad = doLazyLoad;\n  }\n}\n\n/**\n * Facades variant mapping data.\n */\nexport interface VariantData {\n  name: string;\n  index: number;\n}\n\n/**\n * A Model facades the top-level GLTF object returned by Three.js' GLTFLoader.\n * Currently, the model only bothers itself with the materials in the Three.js\n * scene graph.\n */\nexport class Model implements ModelInterface {\n  private[$materials] = new Array<Material>();\n  private[$hierarchy] = new Array<Node>();\n  private[$roots] = new Array<Node>();\n  private[$primitivesList] = new Array<PrimitiveNode>();\n  private[$modelOnUpdate]: () => void = () => {};\n  private[$variantData] = new Map<string, VariantData>();\n\n  constructor(\n      correlatedSceneGraph: CorrelatedSceneGraph,\n      onUpdate: () => void = () => {}) {\n    this[$modelOnUpdate] = onUpdate;\n    const {gltf, threeGLTF, gltfElementMap} = correlatedSceneGraph;\n\n    for (const [i, material] of gltf.materials!.entries()) {\n      const correlatedMaterial =\n          gltfElementMap.get(material) as Set<MeshPhysicalMaterial>| null;\n\n      if (correlatedMaterial != null) {\n        this[$materials].push(new Material(\n            onUpdate,\n            i,\n            true,\n            this[$variantData],\n            correlatedMaterial,\n            material.name));\n      } else {\n        const elementArray = gltf['materials'] || [];\n        const gltfMaterialDef = elementArray[i];\n\n        const threeMaterialSet = new Set<MeshPhysicalMaterial>();\n        gltfElementMap.set(gltfMaterialDef, threeMaterialSet);\n        const materialLoadCallback = async () => {\n          const threeMaterial = await threeGLTF.parser.getDependency(\n                                    'material', i) as MeshPhysicalMaterial;\n          threeMaterialSet.add(threeMaterial);\n\n          return threeMaterial;\n        };\n\n        // Configures the material for lazy loading.\n        this[$materials].push(new Material(\n            onUpdate,\n            i,\n            false,\n            this[$variantData],\n            threeMaterialSet,\n            material.name,\n            new LazyLoader(\n                gltf, gltfElementMap, gltfMaterialDef, materialLoadCallback)));\n      }\n    }\n\n    // Creates a hierarchy of Nodes. Allows not just for switching which\n    // material is applied to a mesh but also exposes a way to provide API\n    // for switching materials and general assignment/modification.\n\n    // Prepares for scene iteration.\n    const parentMap = new Map<object, Node>();\n    const nodeStack = new Array<Object3D>();\n    for (const object of threeGLTF.scene.children) {\n      nodeStack.push(object);\n    }\n\n    // Walks the hierarchy and creates a node tree.\n    while (nodeStack.length > 0) {\n      const object = nodeStack.pop()!;\n\n      let node: Node|null = null;\n\n      if (object instanceof Mesh) {\n        node = new PrimitiveNode(\n            object as Mesh,\n            this.materials,\n            this[$variantData],\n            correlatedSceneGraph);\n        this[$primitivesList].push(node as PrimitiveNode);\n      } else {\n        node = new Node(object.name);\n      }\n\n      const parent: Node|undefined = parentMap.get(object);\n      if (parent != null) {\n        parent.children.push(node);\n      } else {\n        this[$roots].push(node);\n      }\n      this[$hierarchy].push(node);\n\n      for (const child of object.children) {\n        nodeStack.push(child);\n        parentMap.set(object, node);\n      }\n    }\n  }\n\n  /**\n   * Materials are listed in the order of the GLTF materials array, plus a\n   * default material at the end if one is used.\n   *\n   * TODO(#1003): How do we handle non-active scenes?\n   */\n  get materials(): Material[] {\n    return this[$materials];\n  }\n\n  [$availableVariants]() {\n    const variants = Array.from(this[$variantData].values());\n    variants.sort((a, b) => {\n      return a.index - b.index;\n    });\n\n    return variants.map((data) => {\n      return data.name;\n    });\n  }\n\n  getMaterialByName(name: string): Material|null {\n    const matches = this[$materials].filter(material => {\n      return material.name === name;\n    });\n\n    if (matches.length > 0) {\n      return matches[0];\n    }\n    return null;\n  }\n\n  [$nodeFromIndex](mesh: number, primitive: number): PrimitiveNode|null {\n    const found = this[$hierarchy].find((node: Node) => {\n      if (node instanceof PrimitiveNode) {\n        const {meshes, primitives} = node.mesh.userData.associations;\n        if (meshes == mesh && primitives == primitive) {\n          return true;\n        }\n      }\n      return false;\n    });\n    return found == null ? null : found as PrimitiveNode;\n  }\n\n  [$nodeFromPoint](hit: Intersection<Object3D>): PrimitiveNode {\n    return this[$hierarchy].find((node: Node) => {\n      if (node instanceof PrimitiveNode) {\n        const primitive = node as PrimitiveNode;\n        if (primitive.mesh === hit.object) {\n          return true;\n        }\n      }\n      return false;\n    }) as PrimitiveNode;\n  }\n\n  /**\n   * Intersects a ray with the Model and returns the first material whose\n   * object was intersected.\n   */\n  [$materialFromPoint](hit: Intersection<Object3D>): Material {\n    return this[$nodeFromPoint](hit).getActiveMaterial();\n  }\n\n  /**\n   * Switches model variant to the variant name provided, or switches to\n   * default/initial materials if 'null' is provided.\n   */\n  async[$switchVariant](variantName: string|null) {\n    for (const primitive of this[$primitivesList]) {\n      await primitive.enableVariant(variantName);\n    }\n\n    for (const material of this.materials) {\n      material[$setActive](false);\n    }\n    // Marks the materials that are now in use after the variant switch.\n    for (const primitive of this[$primitivesList]) {\n      this.materials[primitive.getActiveMaterial().index][$setActive](true);\n    }\n  }\n\n  async[$prepareVariantsForExport]() {\n    const promises = new Array<Promise<void>>();\n    for (const primitive of this[$primitivesList]) {\n      promises.push(primitive.instantiateVariants());\n    }\n    await Promise.all(promises);\n  }\n\n  [$cloneMaterial](index: number, newMaterialName: string): Material {\n    const material = this.materials[index];\n\n    if (!material.isLoaded) {\n      console.error(`Cloning an unloaded material,\n           call 'material.ensureLoaded() before cloning the material.`);\n    }\n\n    const threeMaterialSet =\n        material[$correlatedObjects] as Set<MeshPhysicalMaterial>;\n\n    const clonedSet = new Set<MeshPhysicalMaterial>();\n    for (const [i, threeMaterial] of threeMaterialSet.entries()) {\n      const clone = threeMaterial.clone() as MeshPhysicalMaterial;\n      clone.name =\n          newMaterialName + (threeMaterialSet.size > 1 ? '_inst' + i : '');\n      clonedSet.add(clone);\n    }\n\n    const clonedMaterial = new Material(\n        this[$modelOnUpdate],\n        this[$materials].length,\n        false,  // Cloned as inactive.\n        this[$variantData],\n        clonedSet,\n        newMaterialName);\n\n    this[$materials].push(clonedMaterial);\n\n    return clonedMaterial;\n  }\n\n  createMaterialInstanceForVariant(\n      originalMaterialIndex: number, newMaterialName: string,\n      variantName: string, activateVariant: boolean = true): Material|null {\n    let variantMaterialInstance: Material|null = null;\n\n    for (const primitive of this[$primitivesList]) {\n      const variantData = this[$variantData].get(variantName);\n      // Skips the primitive if the variant already exists.\n      if (variantData != null && primitive.variantInfo.has(variantData.index)) {\n        continue;\n      }\n\n      // Skips the primitive if the source/original material does not exist.\n      if (primitive.getMaterial(originalMaterialIndex) == null) {\n        continue;\n      }\n\n      if (!this.hasVariant(variantName)) {\n        this.createVariant(variantName);\n      }\n\n      if (variantMaterialInstance == null) {\n        variantMaterialInstance =\n            this[$cloneMaterial](originalMaterialIndex, newMaterialName);\n      }\n      primitive.addVariant(variantMaterialInstance, variantName)\n    }\n\n    if (activateVariant && variantMaterialInstance != null) {\n      (variantMaterialInstance as Material)[$setActive](true);\n      this.materials[originalMaterialIndex][$setActive](false);\n      for (const primitive of this[$primitivesList]) {\n        primitive.enableVariant(variantName);\n      }\n    }\n\n    return variantMaterialInstance;\n  }\n\n  createVariant(variantName: string) {\n    if (!this[$variantData].has(variantName)) {\n      // Adds the name if it's not already in the list.\n      this[$variantData].set(\n          variantName,\n          {name: variantName, index: this[$variantData].size} as VariantData);\n    } else {\n      console.warn(`Variant '${variantName}'' already exists`);\n    }\n  }\n\n  hasVariant(variantName: string) {\n    return this[$variantData].has(variantName);\n  }\n\n  setMaterialToVariant(materialIndex: number, targetVariantName: string) {\n    if (this[$availableVariants]().find(name => name === targetVariantName) ==\n        null) {\n      console.warn(`Can't add material to '${\n          targetVariantName}', the variant does not exist.'`);\n      return;\n    }\n\n    if (materialIndex < 0 || materialIndex >= this.materials.length) {\n      console.error(`setMaterialToVariant(): materialIndex is out of bounds.`);\n      return;\n    }\n\n    for (const primitive of this[$primitivesList]) {\n      const material = primitive.getMaterial(materialIndex);\n      // Ensures the material exists on the primitive before setting it to a\n      // variant.\n      if (material != null) {\n        primitive.addVariant(material, targetVariantName);\n      }\n    }\n  }\n\n  updateVariantName(currentName: string, newName: string) {\n    const variantData = this[$variantData].get(currentName);\n    if (variantData == null) {\n      return;\n    }\n    variantData.name = newName;\n    this[$variantData].set(newName, variantData!);\n    this[$variantData].delete(currentName);\n  }\n\n  deleteVariant(variantName: string) {\n    const variant = this[$variantData].get(variantName);\n    if (variant == null) {\n      return;\n    }\n\n    for (const material of this.materials) {\n      if (material.hasVariant(variantName)) {\n        material[$variantIndices].delete(variant.index);\n      }\n    }\n\n    for (const primitive of this[$primitivesList]) {\n      primitive.deleteVariant(variant.index);\n    }\n\n    this[$variantData].delete(variantName);\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}