{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { property } from 'lit/decorators.js';\nimport { LoopOnce, LoopPingPong, LoopRepeat } from 'three';\nimport { $getModelIsVisible, $needsRender, $onModelLoad, $renderer, $scene, $tick } from '../model-viewer-base.js';\nconst MILLISECONDS_PER_SECOND = 1000.0;\nconst $changeAnimation = Symbol('changeAnimation');\nconst $appendAnimation = Symbol('appendAnimation');\nconst $detachAnimation = Symbol('detachAnimation');\nconst $paused = Symbol('paused');\nconst DEFAULT_PLAY_OPTIONS = {\n  repetitions: Infinity,\n  pingpong: false\n};\nconst DEFAULT_APPEND_OPTIONS = {\n  pingpong: false,\n  repetitions: null,\n  weight: 1,\n  timeScale: 1,\n  fade: false,\n  warp: false,\n  relativeWarp: true,\n  time: null\n};\nconst DEFAULT_DETACH_OPTIONS = {\n  fade: true\n};\nexport const AnimationMixin = ModelViewerElement => {\n  var _a;\n  class AnimationModelViewerElement extends ModelViewerElement {\n    constructor(...args) {\n      super(args);\n      this.autoplay = false;\n      this.animationName = undefined;\n      this.animationCrossfadeDuration = 300;\n      this[_a] = true;\n      this[$scene].subscribeMixerEvent('loop', e => {\n        const count = e.action._loopCount;\n        const name = e.action._clip.name;\n        const uuid = e.action._clip.uuid;\n        const targetAnimation = this[$scene].markedAnimations.find(e => e.name === name);\n        if (targetAnimation) {\n          this[$scene].updateAnimationLoop(targetAnimation.name, targetAnimation.loopMode, targetAnimation.repetitionCount);\n          const filtredArr = this[$scene].markedAnimations.filter(e => e.name !== name);\n          this[$scene].markedAnimations = filtredArr;\n        }\n        this.dispatchEvent(new CustomEvent('loop', {\n          detail: {\n            count,\n            name,\n            uuid\n          }\n        }));\n      });\n      this[$scene].subscribeMixerEvent('finished', e => {\n        if (!this[$scene].appendedAnimations.includes(e.action._clip.name)) {\n          this[$paused] = true;\n        } else {\n          const filterdList = this[$scene].appendedAnimations.filter(i => i !== e.action._clip.name);\n          this[$scene].appendedAnimations = filterdList;\n        }\n        this.dispatchEvent(new CustomEvent('finished'));\n      });\n    }\n    /**\n     * Returns an array\n     */\n    get availableAnimations() {\n      if (this.loaded) {\n        return this[$scene].animationNames;\n      }\n      return [];\n    }\n    get duration() {\n      return this[$scene].duration;\n    }\n    get paused() {\n      return this[$paused];\n    }\n    get currentTime() {\n      return this[$scene].animationTime;\n    }\n    get appendedAnimations() {\n      return this[$scene].appendedAnimations;\n    }\n    set currentTime(value) {\n      this[$scene].animationTime = value;\n      this[$needsRender]();\n    }\n    get timeScale() {\n      return this[$scene].animationTimeScale;\n    }\n    set timeScale(value) {\n      this[$scene].animationTimeScale = value;\n    }\n    pause() {\n      if (this[$paused]) {\n        return;\n      }\n      this[$paused] = true;\n      this.dispatchEvent(new CustomEvent('pause'));\n    }\n    play(options) {\n      if (this.availableAnimations.length > 0) {\n        this[$paused] = false;\n        this[$changeAnimation](options);\n        this.dispatchEvent(new CustomEvent('play'));\n      }\n    }\n    appendAnimation(animationName, options) {\n      if (this.availableAnimations.length > 0) {\n        this[$paused] = false;\n        this[$appendAnimation](animationName, options);\n        this.dispatchEvent(new CustomEvent('append-animation'));\n      }\n    }\n    detachAnimation(animationName, options) {\n      if (this.availableAnimations.length > 0) {\n        this[$paused] = false;\n        this[$detachAnimation](animationName, options);\n        this.dispatchEvent(new CustomEvent('detach-animation'));\n      }\n    }\n    [(_a = $paused, $onModelLoad)]() {\n      super[$onModelLoad]();\n      this[$paused] = true;\n      if (this.animationName != null) {\n        this[$changeAnimation]();\n      }\n      if (this.autoplay) {\n        this.play();\n      }\n    }\n    [$tick](_time, delta) {\n      super[$tick](_time, delta);\n      if (this[$paused] || !this[$getModelIsVisible]() && !this[$renderer].isPresenting) {\n        return;\n      }\n      this[$scene].updateAnimation(delta / MILLISECONDS_PER_SECOND);\n      this[$needsRender]();\n    }\n    updated(changedProperties) {\n      super.updated(changedProperties);\n      if (changedProperties.has('autoplay') && this.autoplay) {\n        this.play();\n      }\n      if (changedProperties.has('animationName')) {\n        this[$changeAnimation]();\n      }\n    }\n    [$changeAnimation](options = DEFAULT_PLAY_OPTIONS) {\n      var _b;\n      const repetitions = (_b = options.repetitions) !== null && _b !== void 0 ? _b : Infinity;\n      const mode = options.pingpong ? LoopPingPong : repetitions === 1 ? LoopOnce : LoopRepeat;\n      this[$scene].playAnimation(this.animationName, this.animationCrossfadeDuration / MILLISECONDS_PER_SECOND, mode, repetitions);\n      // If we are currently paused, we need to force a render so that\n      // the scene updates to the first frame of the new animation\n      if (this[$paused]) {\n        this[$scene].updateAnimation(0);\n        this[$needsRender]();\n      }\n    }\n    [$appendAnimation](animationName = '', options = DEFAULT_APPEND_OPTIONS) {\n      var _b;\n      const repetitions = (_b = options.repetitions) !== null && _b !== void 0 ? _b : Infinity;\n      const mode = options.pingpong ? LoopPingPong : repetitions === 1 ? LoopOnce : LoopRepeat;\n      const needsToStop = !!options.repetitions || 'pingpong' in options;\n      this[$scene].appendAnimation(animationName ? animationName : this.animationName, mode, repetitions, options.weight, options.timeScale, options.fade, options.warp, options.relativeWarp, options.time, needsToStop);\n      // If we are currently paused, we need to force a render so that\n      // the scene updates to the first frame of the new animation\n      if (this[$paused]) {\n        this[$scene].updateAnimation(0);\n        this[$needsRender]();\n      }\n    }\n    [$detachAnimation](animationName = '', options = DEFAULT_DETACH_OPTIONS) {\n      this[$scene].detachAnimation(animationName ? animationName : this.animationName, options.fade);\n      // If we are currently paused, we need to force a render so that\n      // the scene updates to the first frame of the new animation\n      if (this[$paused]) {\n        this[$scene].updateAnimation(0);\n        this[$needsRender]();\n      }\n    }\n  }\n  __decorate([property({\n    type: Boolean\n  })], AnimationModelViewerElement.prototype, \"autoplay\", void 0);\n  __decorate([property({\n    type: String,\n    attribute: 'animation-name'\n  })], AnimationModelViewerElement.prototype, \"animationName\", void 0);\n  __decorate([property({\n    type: Number,\n    attribute: 'animation-crossfade-duration'\n  })], AnimationModelViewerElement.prototype, \"animationCrossfadeDuration\", void 0);\n  return AnimationModelViewerElement;\n};","map":{"version":3,"names":["property","LoopOnce","LoopPingPong","LoopRepeat","$getModelIsVisible","$needsRender","$onModelLoad","$renderer","$scene","$tick","MILLISECONDS_PER_SECOND","$changeAnimation","Symbol","$appendAnimation","$detachAnimation","$paused","DEFAULT_PLAY_OPTIONS","repetitions","Infinity","pingpong","DEFAULT_APPEND_OPTIONS","weight","timeScale","fade","warp","relativeWarp","time","DEFAULT_DETACH_OPTIONS","AnimationMixin","ModelViewerElement","AnimationModelViewerElement","constructor","args","autoplay","animationName","undefined","animationCrossfadeDuration","_a","subscribeMixerEvent","e","count","action","_loopCount","name","_clip","uuid","targetAnimation","markedAnimations","find","updateAnimationLoop","loopMode","repetitionCount","filtredArr","filter","dispatchEvent","CustomEvent","detail","appendedAnimations","includes","filterdList","i","availableAnimations","loaded","animationNames","duration","paused","currentTime","animationTime","value","animationTimeScale","pause","play","options","length","appendAnimation","detachAnimation","_time","delta","isPresenting","updateAnimation","updated","changedProperties","has","_b","mode","playAnimation","needsToStop","__decorate","type","Boolean","String","attribute","Number"],"sources":["../../src/features/animation.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {property} from 'lit/decorators.js';\nimport {LoopOnce, LoopPingPong, LoopRepeat} from 'three';\n\nimport ModelViewerElementBase, {$getModelIsVisible, $needsRender, $onModelLoad, $renderer, $scene, $tick} from '../model-viewer-base.js';\nimport {Constructor} from '../utilities.js';\n\nconst MILLISECONDS_PER_SECOND = 1000.0\n\nconst $changeAnimation = Symbol('changeAnimation');\nconst $appendAnimation = Symbol('appendAnimation');\nconst $detachAnimation = Symbol('detachAnimation');\nconst $paused = Symbol('paused');\n\ninterface PlayAnimationOptions {\n  repetitions: number, pingpong: boolean,\n}\n\ninterface AppendAnimationOptions {\n  pingpong: boolean, repetitions: number|null, weight: number,\n      timeScale: number, fade: boolean|number, warp: boolean|number,\n      relativeWarp: boolean, time: number|null\n}\n\ninterface DetachAnimationOptions {\n  fade: boolean|number\n}\n\nconst DEFAULT_PLAY_OPTIONS: PlayAnimationOptions = {\n  repetitions: Infinity,\n  pingpong: false\n};\n\nconst DEFAULT_APPEND_OPTIONS: AppendAnimationOptions = {\n  pingpong: false,\n  repetitions: null,\n  weight: 1,\n  timeScale: 1,\n  fade: false,\n  warp: false,\n  relativeWarp: true,\n  time: null\n};\n\nconst DEFAULT_DETACH_OPTIONS: DetachAnimationOptions = {\n  fade: true\n};\n\nexport declare interface AnimationInterface {\n  autoplay: boolean;\n  animationName: string|void;\n  animationCrossfadeDuration: number;\n  readonly availableAnimations: Array<string>;\n  readonly paused: boolean;\n  readonly duration: number;\n  currentTime: number;\n  timeScale: number;\n  pause(): void;\n  play(options?: PlayAnimationOptions): void;\n  appendAnimation(animationName: string, options?: AppendAnimationOptions):\n      void;\n  detachAnimation(animationName: string, options?: DetachAnimationOptions):\n      void;\n}\n\nexport const AnimationMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<AnimationInterface>&T => {\n  class AnimationModelViewerElement extends ModelViewerElement {\n    @property({type: Boolean}) autoplay: boolean = false;\n    @property({type: String, attribute: 'animation-name'})\n    animationName: string|undefined = undefined;\n    @property({type: Number, attribute: 'animation-crossfade-duration'})\n    animationCrossfadeDuration: number = 300;\n\n    protected[$paused]: boolean = true;\n\n    constructor(...args: any[]) {\n      super(args);\n\n      this[$scene].subscribeMixerEvent('loop', (e) => {\n        const count = e.action._loopCount;\n        const name = e.action._clip.name;\n        const uuid = e.action._clip.uuid;\n        const targetAnimation =\n            this[$scene].markedAnimations.find(e => e.name === name);\n\n        if (targetAnimation) {\n          this[$scene].updateAnimationLoop(\n              targetAnimation.name,\n              targetAnimation.loopMode,\n              targetAnimation.repetitionCount);\n          const filtredArr =\n              this[$scene].markedAnimations.filter(e => e.name !== name);\n          this[$scene].markedAnimations = filtredArr;\n        }\n\n        this.dispatchEvent(\n            new CustomEvent('loop', {detail: {count, name, uuid}}));\n      });\n      this[$scene].subscribeMixerEvent('finished', (e) => {\n        if (!this[$scene].appendedAnimations.includes(e.action._clip.name)) {\n          this[$paused] = true;\n        } else {\n          const filterdList = this[$scene].appendedAnimations.filter(\n              i => i !== e.action._clip.name);\n          this[$scene].appendedAnimations = filterdList;\n        }\n        this.dispatchEvent(new CustomEvent('finished'));\n      });\n    }\n\n    /**\n     * Returns an array\n     */\n    get availableAnimations(): Array<string> {\n      if (this.loaded) {\n        return this[$scene].animationNames;\n      }\n\n      return [];\n    }\n\n    get duration(): number {\n      return this[$scene].duration;\n    }\n\n    get paused(): boolean {\n      return this[$paused];\n    }\n\n    get currentTime(): number {\n      return this[$scene].animationTime;\n    }\n\n    get appendedAnimations(): string[] {\n      return this[$scene].appendedAnimations;\n    }\n\n    set currentTime(value: number) {\n      this[$scene].animationTime = value;\n      this[$needsRender]();\n    }\n\n    get timeScale(): number {\n      return this[$scene].animationTimeScale;\n    }\n\n    set timeScale(value: number) {\n      this[$scene].animationTimeScale = value;\n    }\n\n    pause() {\n      if (this[$paused]) {\n        return;\n      }\n\n      this[$paused] = true;\n      this.dispatchEvent(new CustomEvent('pause'));\n    }\n\n    play(options?: PlayAnimationOptions) {\n      if (this.availableAnimations.length > 0) {\n        this[$paused] = false;\n\n        this[$changeAnimation](options);\n\n        this.dispatchEvent(new CustomEvent('play'));\n      }\n    }\n\n    appendAnimation(animationName: string, options?: AppendAnimationOptions) {\n      if (this.availableAnimations.length > 0) {\n        this[$paused] = false;\n\n        this[$appendAnimation](animationName, options);\n\n        this.dispatchEvent(new CustomEvent('append-animation'));\n      }\n    }\n\n    detachAnimation(animationName: string, options?: DetachAnimationOptions) {\n      if (this.availableAnimations.length > 0) {\n        this[$paused] = false;\n\n        this[$detachAnimation](animationName, options);\n\n        this.dispatchEvent(new CustomEvent('detach-animation'));\n      }\n    }\n\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n\n      this[$paused] = true;\n\n      if (this.animationName != null) {\n        this[$changeAnimation]();\n      }\n\n      if (this.autoplay) {\n        this.play();\n      }\n    }\n\n    [$tick](_time: number, delta: number) {\n      super[$tick](_time, delta);\n\n      if (this[$paused] ||\n          (!this[$getModelIsVisible]() && !this[$renderer].isPresenting)) {\n        return;\n      }\n\n      this[$scene].updateAnimation(delta / MILLISECONDS_PER_SECOND);\n\n      this[$needsRender]();\n    }\n\n    updated(changedProperties: Map<string, any>) {\n      super.updated(changedProperties);\n\n      if (changedProperties.has('autoplay') && this.autoplay) {\n        this.play();\n      }\n\n      if (changedProperties.has('animationName')) {\n        this[$changeAnimation]();\n      }\n    }\n\n    [$changeAnimation](options: PlayAnimationOptions = DEFAULT_PLAY_OPTIONS) {\n      const repetitions = options.repetitions ?? Infinity;\n      const mode = options.pingpong ?\n          LoopPingPong :\n          (repetitions === 1 ? LoopOnce : LoopRepeat);\n      this[$scene].playAnimation(\n          this.animationName,\n          this.animationCrossfadeDuration / MILLISECONDS_PER_SECOND,\n          mode,\n          repetitions);\n\n      // If we are currently paused, we need to force a render so that\n      // the scene updates to the first frame of the new animation\n      if (this[$paused]) {\n        this[$scene].updateAnimation(0);\n        this[$needsRender]();\n      }\n    }\n\n    [$appendAnimation](\n        animationName: string = '',\n        options: AppendAnimationOptions = DEFAULT_APPEND_OPTIONS) {\n      const repetitions = options.repetitions ?? Infinity;\n      const mode = options.pingpong ?\n          LoopPingPong :\n          (repetitions === 1 ? LoopOnce : LoopRepeat);\n\n      const needsToStop = !!options.repetitions || 'pingpong' in options;\n\n      this[$scene].appendAnimation(\n          animationName ? animationName : this.animationName,\n          mode,\n          repetitions,\n          options.weight,\n          options.timeScale,\n          options.fade,\n          options.warp,\n          options.relativeWarp,\n          options.time,\n          needsToStop);\n\n      // If we are currently paused, we need to force a render so that\n      // the scene updates to the first frame of the new animation\n      if (this[$paused]) {\n        this[$scene].updateAnimation(0);\n        this[$needsRender]();\n      }\n    }\n\n    [$detachAnimation](\n        animationName: string = '',\n        options: DetachAnimationOptions = DEFAULT_DETACH_OPTIONS) {\n      this[$scene].detachAnimation(\n          animationName ? animationName : this.animationName, options.fade);\n\n      // If we are currently paused, we need to force a render so that\n      // the scene updates to the first frame of the new animation\n      if (this[$paused]) {\n        this[$scene].updateAnimation(0);\n        this[$needsRender]();\n      }\n    }\n  }\n\n  return AnimationModelViewerElement;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}