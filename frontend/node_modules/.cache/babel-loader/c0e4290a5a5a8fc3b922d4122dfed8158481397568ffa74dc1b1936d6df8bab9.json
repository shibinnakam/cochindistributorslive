{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { Material } from 'three';\nconst $threeGLTF = Symbol('threeGLTF');\nconst $gltf = Symbol('gltf');\nconst $gltfElementMap = Symbol('gltfElementMap');\nconst $threeObjectMap = Symbol('threeObjectMap');\nconst $parallelTraverseThreeScene = Symbol('parallelTraverseThreeScene');\nconst $correlateOriginalThreeGLTF = Symbol('correlateOriginalThreeGLTF');\nconst $correlateCloneThreeGLTF = Symbol('correlateCloneThreeGLTF');\n/**\n * The Three.js GLTFLoader provides us with an in-memory representation\n * of a glTF in terms of Three.js constructs. It also provides us with a copy\n * of the deserialized glTF without any Three.js decoration, and a mapping of\n * glTF elements to their corresponding Three.js constructs.\n *\n * A CorrelatedSceneGraph exposes a synchronously available mapping of glTF\n * element references to their corresponding Three.js constructs.\n */\nexport class CorrelatedSceneGraph {\n  /**\n   * Produce a CorrelatedSceneGraph from a naturally generated Three.js GLTF.\n   * Such GLTFs are produced by Three.js' GLTFLoader, and contain cached\n   * details that expedite the correlation step.\n   *\n   * If a CorrelatedSceneGraph is provided as the second argument, re-correlates\n   * a cloned Three.js GLTF with a clone of the glTF hierarchy used to produce\n   * the upstream Three.js GLTF that the clone was created from. The result\n   * CorrelatedSceneGraph is representative of the cloned hierarchy.\n   */\n  static from(threeGLTF, upstreamCorrelatedSceneGraph) {\n    if (upstreamCorrelatedSceneGraph != null) {\n      return this[$correlateCloneThreeGLTF](threeGLTF, upstreamCorrelatedSceneGraph);\n    } else {\n      return this[$correlateOriginalThreeGLTF](threeGLTF);\n    }\n  }\n  static [$correlateOriginalThreeGLTF](threeGLTF) {\n    const gltf = threeGLTF.parser.json;\n    const associations = threeGLTF.parser.associations;\n    const gltfElementMap = new Map();\n    const defaultMaterial = {\n      name: 'Default'\n    };\n    const defaultReference = {\n      type: 'materials',\n      index: -1\n    };\n    for (const threeMaterial of associations.keys()) {\n      // Note: GLTFLoader creates a \"default\" material that has no\n      // corresponding glTF element in the case that no materials are\n      // specified in the source glTF. In this case we append a default\n      // material to allow this to be operated upon.\n      if (threeMaterial instanceof Material && associations.get(threeMaterial) == null) {\n        if (defaultReference.index < 0) {\n          if (gltf.materials == null) {\n            gltf.materials = [];\n          }\n          defaultReference.index = gltf.materials.length;\n          gltf.materials.push(defaultMaterial);\n        }\n        threeMaterial.name = defaultMaterial.name;\n        associations.set(threeMaterial, {\n          materials: defaultReference.index\n        });\n      }\n    }\n    // Creates a reverse look up map (gltf-object to Three-object)\n    for (const [threeObject, gltfMappings] of associations) {\n      if (gltfMappings) {\n        threeObject.userData = threeObject.userData || {};\n        threeObject.userData.associations = gltfMappings;\n      }\n      for (const mapping in gltfMappings) {\n        if (mapping != null && mapping !== 'primitives') {\n          const type = mapping;\n          const elementArray = gltf[type] || [];\n          const gltfElement = elementArray[gltfMappings[type]];\n          if (gltfElement == null) {\n            // TODO: Maybe throw here...\n            continue;\n          }\n          let threeObjects = gltfElementMap.get(gltfElement);\n          if (threeObjects == null) {\n            threeObjects = new Set();\n            gltfElementMap.set(gltfElement, threeObjects);\n          }\n          threeObjects.add(threeObject);\n        }\n      }\n    }\n    return new CorrelatedSceneGraph(threeGLTF, gltf, associations, gltfElementMap);\n  }\n  /**\n   * Transfers the association between a raw glTF and a Three.js scene graph\n   * to a clone of the Three.js scene graph, resolved as a new\n   * CorrelatedSceneGraph instance.\n   */\n  static [$correlateCloneThreeGLTF](cloneThreeGLTF, upstreamCorrelatedSceneGraph) {\n    const originalThreeGLTF = upstreamCorrelatedSceneGraph.threeGLTF;\n    const originalGLTF = upstreamCorrelatedSceneGraph.gltf;\n    const cloneGLTF = JSON.parse(JSON.stringify(originalGLTF));\n    const cloneThreeObjectMap = new Map();\n    const cloneGLTFElementMap = new Map();\n    for (let i = 0; i < originalThreeGLTF.scenes.length; i++) {\n      this[$parallelTraverseThreeScene](originalThreeGLTF.scenes[i], cloneThreeGLTF.scenes[i], (object, cloneObject) => {\n        const elementReference = upstreamCorrelatedSceneGraph.threeObjectMap.get(object);\n        if (elementReference == null) {\n          return;\n        }\n        for (const mapping in elementReference) {\n          if (mapping != null && mapping !== 'primitives') {\n            const type = mapping;\n            const index = elementReference[type];\n            const cloneElement = cloneGLTF[type][index];\n            const mappings = cloneThreeObjectMap.get(cloneObject) || {};\n            mappings[type] = index;\n            cloneThreeObjectMap.set(cloneObject, mappings);\n            const cloneObjects = cloneGLTFElementMap.get(cloneElement) || new Set();\n            cloneObjects.add(cloneObject);\n            cloneGLTFElementMap.set(cloneElement, cloneObjects);\n          }\n        }\n      });\n    }\n    return new CorrelatedSceneGraph(cloneThreeGLTF, cloneGLTF, cloneThreeObjectMap, cloneGLTFElementMap);\n  }\n  /**\n   * Traverses two presumably identical Three.js scenes, and invokes a\n   * callback for each Object3D or Material encountered, including the initial\n   * scene. Adapted from\n   * https://github.com/mrdoob/three.js/blob/7c1424c5819ab622a346dd630ee4e6431388021e/examples/jsm/utils/SkeletonUtils.js#L586-L596\n   */\n  static [$parallelTraverseThreeScene](sceneOne, sceneTwo, callback) {\n    const traverse = (a, b) => {\n      callback(a, b);\n      if (a.isObject3D) {\n        const meshA = a;\n        const meshB = b;\n        if (meshA.material) {\n          if (Array.isArray(meshA.material)) {\n            for (let i = 0; i < meshA.material.length; ++i) {\n              callback(meshA.material[i], meshB.material[i]);\n            }\n          } else {\n            callback(meshA.material, meshB.material);\n          }\n        }\n        for (let i = 0; i < a.children.length; ++i) {\n          traverse(a.children[i], b.children[i]);\n        }\n      }\n    };\n    traverse(sceneOne, sceneTwo);\n  }\n  /**\n   * The source Three.js GLTF result given to us by a Three.js GLTFLoader.\n   */\n  get threeGLTF() {\n    return this[$threeGLTF];\n  }\n  /**\n   * The in-memory deserialized source glTF.\n   */\n  get gltf() {\n    return this[$gltf];\n  }\n  /**\n   * A Map of glTF element references to arrays of corresponding Three.js\n   * object references. Three.js objects are kept in arrays to account for\n   * cases where more than one Three.js object corresponds to a single glTF\n   * element.\n   */\n  get gltfElementMap() {\n    return this[$gltfElementMap];\n  }\n  /**\n   * A map of individual Three.js objects to corresponding elements in the\n   * source glTF.\n   */\n  get threeObjectMap() {\n    return this[$threeObjectMap];\n  }\n  constructor(threeGLTF, gltf, threeObjectMap, gltfElementMap) {\n    this[$threeGLTF] = threeGLTF;\n    this[$gltf] = gltf;\n    this[$gltfElementMap] = gltfElementMap;\n    this[$threeObjectMap] = threeObjectMap;\n  }\n}","map":{"version":3,"names":["Material","$threeGLTF","Symbol","$gltf","$gltfElementMap","$threeObjectMap","$parallelTraverseThreeScene","$correlateOriginalThreeGLTF","$correlateCloneThreeGLTF","CorrelatedSceneGraph","from","threeGLTF","upstreamCorrelatedSceneGraph","gltf","parser","json","associations","gltfElementMap","Map","defaultMaterial","name","defaultReference","type","index","threeMaterial","keys","get","materials","length","push","set","threeObject","gltfMappings","userData","mapping","elementArray","gltfElement","threeObjects","Set","add","cloneThreeGLTF","originalThreeGLTF","originalGLTF","cloneGLTF","JSON","parse","stringify","cloneThreeObjectMap","cloneGLTFElementMap","i","scenes","object","cloneObject","elementReference","threeObjectMap","cloneElement","mappings","cloneObjects","sceneOne","sceneTwo","callback","traverse","a","b","isObject3D","meshA","meshB","material","Array","isArray","children","constructor"],"sources":["../../../src/three-components/gltf-instance/correlated-scene-graph.ts"],"sourcesContent":["import {Group, Material, Mesh, Object3D, Texture} from 'three';\nimport {GLTF as ThreeGLTF, GLTFReference, GLTFReferenceType} from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nimport {GLTF, GLTFElement} from '../../three-components/gltf-instance/gltf-2.0.js';\n\n\n\nexport type ThreeSceneObject = Object3D|Material|Texture;\ntype ThreeSceneObjectCallback = (a: ThreeSceneObject, b: ThreeSceneObject) =>\n    void;\n\nexport type ThreeObjectSet = Set<ThreeSceneObject>;\n\nexport type GLTFElementToThreeObjectMap = Map<GLTFElement, ThreeObjectSet>;\nexport type ThreeObjectToGLTFElementHandleMap =\n    Map<ThreeSceneObject, GLTFReference>;\n\nconst $threeGLTF = Symbol('threeGLTF');\nconst $gltf = Symbol('gltf');\nconst $gltfElementMap = Symbol('gltfElementMap');\nconst $threeObjectMap = Symbol('threeObjectMap');\nconst $parallelTraverseThreeScene = Symbol('parallelTraverseThreeScene');\n\nconst $correlateOriginalThreeGLTF = Symbol('correlateOriginalThreeGLTF');\nconst $correlateCloneThreeGLTF = Symbol('correlateCloneThreeGLTF');\n\n/**\n * The Three.js GLTFLoader provides us with an in-memory representation\n * of a glTF in terms of Three.js constructs. It also provides us with a copy\n * of the deserialized glTF without any Three.js decoration, and a mapping of\n * glTF elements to their corresponding Three.js constructs.\n *\n * A CorrelatedSceneGraph exposes a synchronously available mapping of glTF\n * element references to their corresponding Three.js constructs.\n */\nexport class CorrelatedSceneGraph {\n  /**\n   * Produce a CorrelatedSceneGraph from a naturally generated Three.js GLTF.\n   * Such GLTFs are produced by Three.js' GLTFLoader, and contain cached\n   * details that expedite the correlation step.\n   *\n   * If a CorrelatedSceneGraph is provided as the second argument, re-correlates\n   * a cloned Three.js GLTF with a clone of the glTF hierarchy used to produce\n   * the upstream Three.js GLTF that the clone was created from. The result\n   * CorrelatedSceneGraph is representative of the cloned hierarchy.\n   */\n  static from(\n      threeGLTF: ThreeGLTF,\n      upstreamCorrelatedSceneGraph?: CorrelatedSceneGraph):\n      CorrelatedSceneGraph {\n    if (upstreamCorrelatedSceneGraph != null) {\n      return this[$correlateCloneThreeGLTF](\n          threeGLTF, upstreamCorrelatedSceneGraph);\n    } else {\n      return this[$correlateOriginalThreeGLTF](threeGLTF);\n    }\n  }\n\n  private static[$correlateOriginalThreeGLTF](threeGLTF: ThreeGLTF):\n      CorrelatedSceneGraph {\n    const gltf = threeGLTF.parser.json as GLTF;\n\n    const associations =\n        threeGLTF.parser.associations as Map<ThreeSceneObject, GLTFReference>;\n    const gltfElementMap: GLTFElementToThreeObjectMap = new Map();\n\n    const defaultMaterial = {name: 'Default'} as Material;\n    const defaultReference = {type: 'materials', index: -1};\n\n    for (const threeMaterial of associations.keys()) {\n      // Note: GLTFLoader creates a \"default\" material that has no\n      // corresponding glTF element in the case that no materials are\n      // specified in the source glTF. In this case we append a default\n      // material to allow this to be operated upon.\n      if (threeMaterial instanceof Material &&\n          associations.get(threeMaterial) == null) {\n        if (defaultReference.index < 0) {\n          if (gltf.materials == null) {\n            gltf.materials = [];\n          }\n          defaultReference.index = gltf.materials.length;\n          gltf.materials.push(defaultMaterial);\n        }\n\n        threeMaterial.name = defaultMaterial.name;\n        associations.set(threeMaterial, {materials: defaultReference.index});\n      }\n    }\n\n    // Creates a reverse look up map (gltf-object to Three-object)\n    for (const [threeObject, gltfMappings] of associations) {\n      if (gltfMappings) {\n        threeObject.userData = threeObject.userData || {};\n        threeObject.userData.associations = gltfMappings;\n      }\n\n      for (const mapping in gltfMappings) {\n        if (mapping != null && mapping !== 'primitives') {\n          const type = mapping as GLTFReferenceType;\n          const elementArray = gltf[type] || [];\n          const gltfElement = elementArray[gltfMappings[type]!];\n          if (gltfElement == null) {\n            // TODO: Maybe throw here...\n            continue;\n          }\n\n          let threeObjects = gltfElementMap.get(gltfElement);\n\n          if (threeObjects == null) {\n            threeObjects = new Set();\n            gltfElementMap.set(gltfElement, threeObjects);\n          }\n\n          threeObjects.add(threeObject);\n        }\n      }\n    }\n\n    return new CorrelatedSceneGraph(\n        threeGLTF, gltf, associations, gltfElementMap);\n  }\n\n  /**\n   * Transfers the association between a raw glTF and a Three.js scene graph\n   * to a clone of the Three.js scene graph, resolved as a new\n   * CorrelatedSceneGraph instance.\n   */\n  private static[$correlateCloneThreeGLTF](\n      cloneThreeGLTF: ThreeGLTF,\n      upstreamCorrelatedSceneGraph: CorrelatedSceneGraph):\n      CorrelatedSceneGraph {\n    const originalThreeGLTF = upstreamCorrelatedSceneGraph.threeGLTF;\n    const originalGLTF = upstreamCorrelatedSceneGraph.gltf;\n    const cloneGLTF: GLTF = JSON.parse(JSON.stringify(originalGLTF));\n    const cloneThreeObjectMap: ThreeObjectToGLTFElementHandleMap = new Map();\n    const cloneGLTFElementMap: GLTFElementToThreeObjectMap = new Map();\n\n    for (let i = 0; i < originalThreeGLTF.scenes.length; i++) {\n      this[$parallelTraverseThreeScene](\n          originalThreeGLTF.scenes[i],\n          cloneThreeGLTF.scenes[i],\n          (object: ThreeSceneObject, cloneObject: ThreeSceneObject) => {\n            const elementReference =\n                upstreamCorrelatedSceneGraph.threeObjectMap.get(object);\n\n            if (elementReference == null) {\n              return;\n            }\n\n            for (const mapping in elementReference) {\n              if (mapping != null && mapping !== 'primitives') {\n                const type = mapping as GLTFReferenceType;\n                const index = elementReference[type]!;\n                const cloneElement = cloneGLTF[type]![index];\n\n                const mappings =\n                    cloneThreeObjectMap.get(cloneObject) || {} as GLTFReference;\n                mappings[type] = index;\n                cloneThreeObjectMap.set(cloneObject, mappings);\n\n                const cloneObjects: Set<typeof cloneObject> =\n                    cloneGLTFElementMap.get(cloneElement) || new Set();\n                cloneObjects.add(cloneObject);\n\n                cloneGLTFElementMap.set(cloneElement, cloneObjects);\n              }\n            }\n          });\n    }\n\n    return new CorrelatedSceneGraph(\n        cloneThreeGLTF, cloneGLTF, cloneThreeObjectMap, cloneGLTFElementMap);\n  }\n\n  /**\n   * Traverses two presumably identical Three.js scenes, and invokes a\n   * callback for each Object3D or Material encountered, including the initial\n   * scene. Adapted from\n   * https://github.com/mrdoob/three.js/blob/7c1424c5819ab622a346dd630ee4e6431388021e/examples/jsm/utils/SkeletonUtils.js#L586-L596\n   */\n  private static[$parallelTraverseThreeScene](\n      sceneOne: Group, sceneTwo: Group, callback: ThreeSceneObjectCallback) {\n    const traverse = (a: Object3D, b: Object3D) => {\n      callback(a, b);\n\n      if (a.isObject3D) {\n        const meshA = a as Mesh;\n        const meshB = b as Mesh;\n        if (meshA.material) {\n          if (Array.isArray(meshA.material)) {\n            for (let i = 0; i < meshA.material.length; ++i) {\n              callback(meshA.material[i], (meshB.material as Material[])[i]);\n            }\n          } else {\n            callback(meshA.material, meshB.material as Material);\n          }\n        }\n\n        for (let i = 0; i < a.children.length; ++i) {\n          traverse(a.children[i], b.children[i]);\n        }\n      }\n    };\n\n    traverse(sceneOne, sceneTwo);\n  }\n\n  private[$threeGLTF]: ThreeGLTF;\n  private[$gltf]: GLTF;\n  private[$gltfElementMap]: GLTFElementToThreeObjectMap;\n  private[$threeObjectMap]: ThreeObjectToGLTFElementHandleMap;\n\n  /**\n   * The source Three.js GLTF result given to us by a Three.js GLTFLoader.\n   */\n  get threeGLTF(): ThreeGLTF {\n    return this[$threeGLTF];\n  }\n\n  /**\n   * The in-memory deserialized source glTF.\n   */\n  get gltf(): GLTF {\n    return this[$gltf];\n  }\n\n  /**\n   * A Map of glTF element references to arrays of corresponding Three.js\n   * object references. Three.js objects are kept in arrays to account for\n   * cases where more than one Three.js object corresponds to a single glTF\n   * element.\n   */\n  get gltfElementMap(): GLTFElementToThreeObjectMap {\n    return this[$gltfElementMap];\n  }\n\n  /**\n   * A map of individual Three.js objects to corresponding elements in the\n   * source glTF.\n   */\n  get threeObjectMap(): ThreeObjectToGLTFElementHandleMap {\n    return this[$threeObjectMap];\n  }\n\n  constructor(\n      threeGLTF: ThreeGLTF, gltf: GLTF,\n      threeObjectMap: ThreeObjectToGLTFElementHandleMap,\n      gltfElementMap: GLTFElementToThreeObjectMap) {\n    this[$threeGLTF] = threeGLTF;\n    this[$gltf] = gltf;\n    this[$gltfElementMap] = gltfElementMap;\n    this[$threeObjectMap] = threeObjectMap;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}