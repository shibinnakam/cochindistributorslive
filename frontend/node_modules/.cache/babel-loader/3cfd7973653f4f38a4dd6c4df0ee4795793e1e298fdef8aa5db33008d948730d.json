{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.to-array.js\";\nimport { BufferAttribute, BufferGeometry, Color, Group, Matrix4, Mesh, Vector3 } from 'three';\nimport { mergeGroups, deepCloneAttribute } from './BufferGeometryUtils.js';\n\n/**\n * @module SceneUtils\n * @three_import import * as SceneUtils from 'three/addons/utils/SceneUtils.js';\n */\n\nconst _color = /*@__PURE__*/new Color();\nconst _matrix = /*@__PURE__*/new Matrix4();\n\n/**\n * This function creates a mesh for each instance of the given instanced mesh and\n * adds it to a group. Each mesh will honor the current 3D transformation of its\n * corresponding instance.\n *\n * @param {InstancedMesh} instancedMesh - The instanced mesh.\n * @return {Group} A group of meshes.\n */\nfunction createMeshesFromInstancedMesh(instancedMesh) {\n  const group = new Group();\n  const count = instancedMesh.count;\n  const geometry = instancedMesh.geometry;\n  const material = instancedMesh.material;\n  for (let i = 0; i < count; i++) {\n    const mesh = new Mesh(geometry, material);\n    instancedMesh.getMatrixAt(i, mesh.matrix);\n    mesh.matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);\n    group.add(mesh);\n  }\n  group.copy(instancedMesh);\n  group.updateMatrixWorld(); // ensure correct world matrices of meshes\n\n  return group;\n}\n\n/**\n * This function creates a mesh for each geometry-group of the given multi-material mesh and\n * adds it to a group.\n *\n * @param {Mesh} mesh - The multi-material mesh.\n * @return {Group} A group of meshes.\n */\nfunction createMeshesFromMultiMaterialMesh(mesh) {\n  if (Array.isArray(mesh.material) === false) {\n    console.warn('THREE.SceneUtils.createMeshesFromMultiMaterialMesh(): The given mesh has no multiple materials.');\n    return mesh;\n  }\n  const object = new Group();\n  object.copy(mesh);\n\n  // merge groups (which automatically sorts them)\n\n  const geometry = mergeGroups(mesh.geometry);\n  const index = geometry.index;\n  const groups = geometry.groups;\n  const attributeNames = Object.keys(geometry.attributes);\n\n  // create a mesh for each group by extracting the buffer data into a new geometry\n\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    const start = group.start;\n    const end = start + group.count;\n    const newGeometry = new BufferGeometry();\n    const newMaterial = mesh.material[group.materialIndex];\n\n    // process all buffer attributes\n\n    for (let j = 0; j < attributeNames.length; j++) {\n      const name = attributeNames[j];\n      const attribute = geometry.attributes[name];\n      const itemSize = attribute.itemSize;\n      const newLength = group.count * itemSize;\n      const type = attribute.array.constructor;\n      const newArray = new type(newLength);\n      const newAttribute = new BufferAttribute(newArray, itemSize);\n      for (let k = start, n = 0; k < end; k++, n++) {\n        const ind = index.getX(k);\n        if (itemSize >= 1) newAttribute.setX(n, attribute.getX(ind));\n        if (itemSize >= 2) newAttribute.setY(n, attribute.getY(ind));\n        if (itemSize >= 3) newAttribute.setZ(n, attribute.getZ(ind));\n        if (itemSize >= 4) newAttribute.setW(n, attribute.getW(ind));\n      }\n      newGeometry.setAttribute(name, newAttribute);\n    }\n    const newMesh = new Mesh(newGeometry, newMaterial);\n    object.add(newMesh);\n  }\n  return object;\n}\n\n/**\n * This function represents an alternative way to create 3D objects with multiple materials.\n * Normally, {@link BufferGeometry#groups} are used which might introduce issues e.g. when\n * exporting the object to a 3D format. This function accepts a geometry and an array of\n * materials and creates for each material a mesh that is added to a group.\n *\n * @param {BufferGeometry} geometry - The geometry.\n * @param {Array<Material>} materials - An array of materials.\n * @return {Group} A group representing a multi-material object.\n */\nfunction createMultiMaterialObject(geometry, materials) {\n  const group = new Group();\n  for (let i = 0, l = materials.length; i < l; i++) {\n    group.add(new Mesh(geometry, materials[i]));\n  }\n  return group;\n}\n\n/**\n * Executes a reducer function for each vertex of the given 3D object.\n * `reduceVertices()` returns a single value: the function's accumulated result.\n *\n * @param {Object3D} object - The 3D object that should be processed. It must have a\n * geometry with a `position` attribute.\n * @param {function(number,Vector3):number} func - The reducer function. First argument\n * is the current value, second argument the current vertex.\n * @param {any} initialValue - The initial value.\n * @return {any} The result.\n */\nfunction reduceVertices(object, func, initialValue) {\n  let value = initialValue;\n  const vertex = new Vector3();\n  object.updateWorldMatrix(true, true);\n  object.traverseVisible(child => {\n    const {\n      geometry\n    } = child;\n    if (geometry !== undefined) {\n      const {\n        position\n      } = geometry.attributes;\n      if (position !== undefined) {\n        for (let i = 0, l = position.count; i < l; i++) {\n          if (child.isMesh) {\n            child.getVertexPosition(i, vertex);\n          } else {\n            vertex.fromBufferAttribute(position, i);\n          }\n          if (!child.isSkinnedMesh) {\n            vertex.applyMatrix4(child.matrixWorld);\n          }\n          value = func(value, vertex);\n        }\n      }\n    }\n  });\n  return value;\n}\n\n/**\n * Sorts the instances of the given instanced mesh.\n *\n * @param {InstancedMesh} mesh - The instanced mesh to sort.\n * @param {function(number, number):number} compareFn - A custom compare function for the sort.\n */\nfunction sortInstancedMesh(mesh, compareFn) {\n  // store copy of instanced attributes for lookups\n\n  const instanceMatrixRef = deepCloneAttribute(mesh.instanceMatrix);\n  const instanceColorRef = mesh.instanceColor ? deepCloneAttribute(mesh.instanceColor) : null;\n  const attributeRefs = new Map();\n  for (const name in mesh.geometry.attributes) {\n    const attribute = mesh.geometry.attributes[name];\n    if (attribute.isInstancedBufferAttribute) {\n      attributeRefs.set(attribute, deepCloneAttribute(attribute));\n    }\n  }\n\n  // compute sort order\n\n  const tokens = [];\n  for (let i = 0; i < mesh.count; i++) tokens.push(i);\n  tokens.sort(compareFn);\n\n  // apply sort order\n\n  for (let i = 0; i < tokens.length; i++) {\n    const refIndex = tokens[i];\n    _matrix.fromArray(instanceMatrixRef.array, refIndex * mesh.instanceMatrix.itemSize);\n    _matrix.toArray(mesh.instanceMatrix.array, i * mesh.instanceMatrix.itemSize);\n    if (mesh.instanceColor) {\n      _color.fromArray(instanceColorRef.array, refIndex * mesh.instanceColor.itemSize);\n      _color.toArray(mesh.instanceColor.array, i * mesh.instanceColor.itemSize);\n    }\n    for (const name in mesh.geometry.attributes) {\n      const attribute = mesh.geometry.attributes[name];\n      if (attribute.isInstancedBufferAttribute) {\n        const attributeRef = attributeRefs.get(attribute);\n        attribute.setX(i, attributeRef.getX(refIndex));\n        if (attribute.itemSize > 1) attribute.setY(i, attributeRef.getY(refIndex));\n        if (attribute.itemSize > 2) attribute.setZ(i, attributeRef.getZ(refIndex));\n        if (attribute.itemSize > 3) attribute.setW(i, attributeRef.getW(refIndex));\n      }\n    }\n  }\n}\n\n/**\n * Generator based alternative to {@link Object3D#traverse}.\n *\n * @param {Object3D} object - Object to traverse.\n * @yields {Object3D} Objects that passed the filter condition.\n */\nfunction* traverseGenerator(object) {\n  yield object;\n  const children = object.children;\n  for (let i = 0, l = children.length; i < l; i++) {\n    yield* traverseGenerator(children[i]);\n  }\n}\n\n/**\n * Generator based alternative to {@link Object3D#traverseVisible}.\n *\n * @param {Object3D} object Object to traverse.\n * @yields {Object3D} Objects that passed the filter condition.\n */\nfunction* traverseVisibleGenerator(object) {\n  if (object.visible === false) return;\n  yield object;\n  const children = object.children;\n  for (let i = 0, l = children.length; i < l; i++) {\n    yield* traverseVisibleGenerator(children[i]);\n  }\n}\n\n/**\n * Generator based alternative to {@link Object3D#traverseAncestors}.\n *\n * @param {Object3D} object Object to traverse.\n * @yields {Object3D} Objects that passed the filter condition.\n */\nfunction* traverseAncestorsGenerator(object) {\n  const parent = object.parent;\n  if (parent !== null) {\n    yield parent;\n    yield* traverseAncestorsGenerator(parent);\n  }\n}\nexport { createMeshesFromInstancedMesh, createMeshesFromMultiMaterialMesh, createMultiMaterialObject, reduceVertices, sortInstancedMesh, traverseGenerator, traverseVisibleGenerator, traverseAncestorsGenerator };","map":{"version":3,"names":["BufferAttribute","BufferGeometry","Color","Group","Matrix4","Mesh","Vector3","mergeGroups","deepCloneAttribute","_color","_matrix","createMeshesFromInstancedMesh","instancedMesh","group","count","geometry","material","i","mesh","getMatrixAt","matrix","decompose","position","quaternion","scale","add","copy","updateMatrixWorld","createMeshesFromMultiMaterialMesh","Array","isArray","console","warn","object","index","groups","attributeNames","Object","keys","attributes","length","start","end","newGeometry","newMaterial","materialIndex","j","name","attribute","itemSize","newLength","type","array","constructor","newArray","newAttribute","k","n","ind","getX","setX","setY","getY","setZ","getZ","setW","getW","setAttribute","newMesh","createMultiMaterialObject","materials","l","reduceVertices","func","initialValue","value","vertex","updateWorldMatrix","traverseVisible","child","undefined","isMesh","getVertexPosition","fromBufferAttribute","isSkinnedMesh","applyMatrix4","matrixWorld","sortInstancedMesh","compareFn","instanceMatrixRef","instanceMatrix","instanceColorRef","instanceColor","attributeRefs","Map","isInstancedBufferAttribute","set","tokens","push","sort","refIndex","fromArray","toArray","attributeRef","get","traverseGenerator","children","traverseVisibleGenerator","visible","traverseAncestorsGenerator","parent"],"sources":["C:/Users/LENOVO/Music/OneDrive/Pictures/distribution-agency-project/frontend/node_modules/three/examples/jsm/utils/SceneUtils.js"],"sourcesContent":["import {\n\tBufferAttribute,\n\tBufferGeometry,\n\tColor,\n\tGroup,\n\tMatrix4,\n\tMesh,\n\tVector3\n} from 'three';\n\nimport { mergeGroups, deepCloneAttribute } from './BufferGeometryUtils.js';\n\n/**\n * @module SceneUtils\n * @three_import import * as SceneUtils from 'three/addons/utils/SceneUtils.js';\n */\n\nconst _color = /*@__PURE__*/new Color();\nconst _matrix = /*@__PURE__*/new Matrix4();\n\n/**\n * This function creates a mesh for each instance of the given instanced mesh and\n * adds it to a group. Each mesh will honor the current 3D transformation of its\n * corresponding instance.\n *\n * @param {InstancedMesh} instancedMesh - The instanced mesh.\n * @return {Group} A group of meshes.\n */\nfunction createMeshesFromInstancedMesh( instancedMesh ) {\n\n\tconst group = new Group();\n\n\tconst count = instancedMesh.count;\n\tconst geometry = instancedMesh.geometry;\n\tconst material = instancedMesh.material;\n\n\tfor ( let i = 0; i < count; i ++ ) {\n\n\t\tconst mesh = new Mesh( geometry, material );\n\n\t\tinstancedMesh.getMatrixAt( i, mesh.matrix );\n\t\tmesh.matrix.decompose( mesh.position, mesh.quaternion, mesh.scale );\n\n\t\tgroup.add( mesh );\n\n\t}\n\n\tgroup.copy( instancedMesh );\n\tgroup.updateMatrixWorld(); // ensure correct world matrices of meshes\n\n\treturn group;\n\n}\n\n/**\n * This function creates a mesh for each geometry-group of the given multi-material mesh and\n * adds it to a group.\n *\n * @param {Mesh} mesh - The multi-material mesh.\n * @return {Group} A group of meshes.\n */\nfunction createMeshesFromMultiMaterialMesh( mesh ) {\n\n\tif ( Array.isArray( mesh.material ) === false ) {\n\n\t\tconsole.warn( 'THREE.SceneUtils.createMeshesFromMultiMaterialMesh(): The given mesh has no multiple materials.' );\n\t\treturn mesh;\n\n\t}\n\n\tconst object = new Group();\n\tobject.copy( mesh );\n\n\t// merge groups (which automatically sorts them)\n\n\tconst geometry = mergeGroups( mesh.geometry );\n\n\tconst index = geometry.index;\n\tconst groups = geometry.groups;\n\tconst attributeNames = Object.keys( geometry.attributes );\n\n\t// create a mesh for each group by extracting the buffer data into a new geometry\n\n\tfor ( let i = 0; i < groups.length; i ++ ) {\n\n\t\tconst group = groups[ i ];\n\n\t\tconst start = group.start;\n\t\tconst end = start + group.count;\n\n\t\tconst newGeometry = new BufferGeometry();\n\t\tconst newMaterial = mesh.material[ group.materialIndex ];\n\n\t\t// process all buffer attributes\n\n\t\tfor ( let j = 0; j < attributeNames.length; j ++ ) {\n\n\t\t\tconst name = attributeNames[ j ];\n\t\t\tconst attribute = geometry.attributes[ name ];\n\t\t\tconst itemSize = attribute.itemSize;\n\n\t\t\tconst newLength = group.count * itemSize;\n\t\t\tconst type = attribute.array.constructor;\n\n\t\t\tconst newArray = new type( newLength );\n\t\t\tconst newAttribute = new BufferAttribute( newArray, itemSize );\n\n\t\t\tfor ( let k = start, n = 0; k < end; k ++, n ++ ) {\n\n\t\t\t\tconst ind = index.getX( k );\n\n\t\t\t\tif ( itemSize >= 1 ) newAttribute.setX( n, attribute.getX( ind ) );\n\t\t\t\tif ( itemSize >= 2 ) newAttribute.setY( n, attribute.getY( ind ) );\n\t\t\t\tif ( itemSize >= 3 ) newAttribute.setZ( n, attribute.getZ( ind ) );\n\t\t\t\tif ( itemSize >= 4 ) newAttribute.setW( n, attribute.getW( ind ) );\n\n\t\t\t}\n\n\n\t\t\tnewGeometry.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\tconst newMesh = new Mesh( newGeometry, newMaterial );\n\t\tobject.add( newMesh );\n\n\t}\n\n\treturn object;\n\n}\n\n/**\n * This function represents an alternative way to create 3D objects with multiple materials.\n * Normally, {@link BufferGeometry#groups} are used which might introduce issues e.g. when\n * exporting the object to a 3D format. This function accepts a geometry and an array of\n * materials and creates for each material a mesh that is added to a group.\n *\n * @param {BufferGeometry} geometry - The geometry.\n * @param {Array<Material>} materials - An array of materials.\n * @return {Group} A group representing a multi-material object.\n */\nfunction createMultiMaterialObject( geometry, materials ) {\n\n\tconst group = new Group();\n\n\tfor ( let i = 0, l = materials.length; i < l; i ++ ) {\n\n\t\tgroup.add( new Mesh( geometry, materials[ i ] ) );\n\n\t}\n\n\treturn group;\n\n}\n\n\n/**\n * Executes a reducer function for each vertex of the given 3D object.\n * `reduceVertices()` returns a single value: the function's accumulated result.\n *\n * @param {Object3D} object - The 3D object that should be processed. It must have a\n * geometry with a `position` attribute.\n * @param {function(number,Vector3):number} func - The reducer function. First argument\n * is the current value, second argument the current vertex.\n * @param {any} initialValue - The initial value.\n * @return {any} The result.\n */\nfunction reduceVertices( object, func, initialValue ) {\n\n\tlet value = initialValue;\n\tconst vertex = new Vector3();\n\n\tobject.updateWorldMatrix( true, true );\n\n\tobject.traverseVisible( ( child ) => {\n\n\t\tconst { geometry } = child;\n\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tconst { position } = geometry.attributes;\n\n\t\t\tif ( position !== undefined ) {\n\n\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t\t\tif ( child.isMesh ) {\n\n\t\t\t\t\t\tchild.getVertexPosition( i, vertex );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tvertex.fromBufferAttribute( position, i );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( ! child.isSkinnedMesh ) {\n\n\t\t\t\t\t\tvertex.applyMatrix4( child.matrixWorld );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvalue = func( value, vertex );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t} );\n\n\treturn value;\n\n}\n\n/**\n * Sorts the instances of the given instanced mesh.\n *\n * @param {InstancedMesh} mesh - The instanced mesh to sort.\n * @param {function(number, number):number} compareFn - A custom compare function for the sort.\n */\nfunction sortInstancedMesh( mesh, compareFn ) {\n\n\t// store copy of instanced attributes for lookups\n\n\tconst instanceMatrixRef = deepCloneAttribute( mesh.instanceMatrix );\n\tconst instanceColorRef = mesh.instanceColor ? deepCloneAttribute( mesh.instanceColor ) : null;\n\n\tconst attributeRefs = new Map();\n\n\tfor ( const name in mesh.geometry.attributes ) {\n\n\t\tconst attribute = mesh.geometry.attributes[ name ];\n\n\t\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\t\tattributeRefs.set( attribute, deepCloneAttribute( attribute ) );\n\n\t\t}\n\n\t}\n\n\n\t// compute sort order\n\n\tconst tokens = [];\n\n\tfor ( let i = 0; i < mesh.count; i ++ ) tokens.push( i );\n\n\ttokens.sort( compareFn );\n\n\n\t// apply sort order\n\n\tfor ( let i = 0; i < tokens.length; i ++ ) {\n\n\t\tconst refIndex = tokens[ i ];\n\n\t\t_matrix.fromArray( instanceMatrixRef.array, refIndex * mesh.instanceMatrix.itemSize );\n\t\t_matrix.toArray( mesh.instanceMatrix.array, i * mesh.instanceMatrix.itemSize );\n\n\t\tif ( mesh.instanceColor ) {\n\n\t\t\t_color.fromArray( instanceColorRef.array, refIndex * mesh.instanceColor.itemSize );\n\t\t\t_color.toArray( mesh.instanceColor.array, i * mesh.instanceColor.itemSize );\n\n\t\t}\n\n\t\tfor ( const name in mesh.geometry.attributes ) {\n\n\t\t\tconst attribute = mesh.geometry.attributes[ name ];\n\n\t\t\tif ( attribute.isInstancedBufferAttribute ) {\n\n\t\t\t\tconst attributeRef = attributeRefs.get( attribute );\n\n\t\t\t\tattribute.setX( i, attributeRef.getX( refIndex ) );\n\t\t\t\tif ( attribute.itemSize > 1 ) attribute.setY( i, attributeRef.getY( refIndex ) );\n\t\t\t\tif ( attribute.itemSize > 2 ) attribute.setZ( i, attributeRef.getZ( refIndex ) );\n\t\t\t\tif ( attribute.itemSize > 3 ) attribute.setW( i, attributeRef.getW( refIndex ) );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n\n/**\n * Generator based alternative to {@link Object3D#traverse}.\n *\n * @param {Object3D} object - Object to traverse.\n * @yields {Object3D} Objects that passed the filter condition.\n */\nfunction* traverseGenerator( object ) {\n\n\tyield object;\n\n\tconst children = object.children;\n\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tyield* traverseGenerator( children[ i ] );\n\n\t}\n\n}\n\n/**\n * Generator based alternative to {@link Object3D#traverseVisible}.\n *\n * @param {Object3D} object Object to traverse.\n * @yields {Object3D} Objects that passed the filter condition.\n */\nfunction* traverseVisibleGenerator( object ) {\n\n\tif ( object.visible === false ) return;\n\n\tyield object;\n\n\tconst children = object.children;\n\n\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\tyield* traverseVisibleGenerator( children[ i ] );\n\n\t}\n\n}\n\n/**\n * Generator based alternative to {@link Object3D#traverseAncestors}.\n *\n * @param {Object3D} object Object to traverse.\n * @yields {Object3D} Objects that passed the filter condition.\n */\nfunction* traverseAncestorsGenerator( object ) {\n\n\tconst parent = object.parent;\n\n\tif ( parent !== null ) {\n\n\t\tyield parent;\n\n\t\tyield* traverseAncestorsGenerator( parent );\n\n\t}\n\n}\n\nexport {\n\tcreateMeshesFromInstancedMesh,\n\tcreateMeshesFromMultiMaterialMesh,\n\tcreateMultiMaterialObject,\n\treduceVertices,\n\tsortInstancedMesh,\n\ttraverseGenerator,\n\ttraverseVisibleGenerator,\n\ttraverseAncestorsGenerator\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}