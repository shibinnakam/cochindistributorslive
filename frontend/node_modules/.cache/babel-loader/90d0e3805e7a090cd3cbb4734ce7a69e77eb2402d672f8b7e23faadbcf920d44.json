{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\n/* @license\n * Copyright 2021 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @param object {THREE.Object3D}\n * @return {boolean}\n */\nconst compatibleObject = object => {\n  // @TODO: Need properer variantMaterials format validation?\n  return object.material !== undefined &&\n  // easier than (!object.isMesh && !object.isLine &&\n  // !object.isPoints)\n  object.userData &&\n  // just in case\n  object.userData.variantMaterials &&\n  // Is this line costly?\n  !!Array.from(object.userData.variantMaterials.values()).filter(m => compatibleMaterial(m.material));\n};\n/**\n * @param material {THREE.Material}\n * @return {boolean}\n */\nconst compatibleMaterial = material => {\n  // @TODO: support multi materials?\n  return material && material.isMaterial && !Array.isArray(material);\n};\nexport default class GLTFExporterMaterialsVariantsExtension {\n  constructor(writer) {\n    this.writer = writer;\n    this.name = 'KHR_materials_variants';\n    this.variantNames = [];\n  }\n  beforeParse(objects) {\n    // Find all variant names and store them to the table\n    const variantNameSet = new Set();\n    const addVariantNames = o => {\n      if (!compatibleObject(o)) {\n        return;\n      }\n      const variantMaterials = o.userData.variantMaterials;\n      const variantDataMap = o.userData.variantData;\n      for (const [variantName, variantData] of variantDataMap) {\n        const variantMaterial = variantMaterials.get(variantData.index);\n        // Ignore unloaded variant materials\n        if (variantMaterial && compatibleMaterial(variantMaterial.material)) {\n          variantNameSet.add(variantName);\n        }\n      }\n    };\n    if (Array.isArray(objects)) {\n      for (const object of objects) {\n        object.traverse(addVariantNames);\n      }\n    } else {\n      objects.traverse(addVariantNames);\n    }\n    // We may want to sort?\n    variantNameSet.forEach(name => this.variantNames.push(name));\n  }\n  async writeMesh(mesh, meshDef) {\n    if (!compatibleObject(mesh)) {\n      return;\n    }\n    const userData = mesh.userData;\n    const variantMaterials = userData.variantMaterials;\n    const variantDataMap = userData.variantData;\n    const mappingTable = new Map();\n    // Removes gaps in the variant indices list (caused by deleting variants).\n    const reIndexedVariants = new Map();\n    const variants = Array.from(variantDataMap.values()).sort((a, b) => {\n      return a.index - b.index;\n    });\n    for (const [i, variantData] of variants.entries()) {\n      reIndexedVariants.set(variantData.index, i);\n    }\n    for (const variantData of variantDataMap.values()) {\n      const variantInstance = variantMaterials.get(variantData.index);\n      if (!variantInstance || !compatibleMaterial(variantInstance.material)) {\n        continue;\n      }\n      const materialIndex = await this.writer.processMaterialAsync(variantInstance.material);\n      if (!mappingTable.has(materialIndex)) {\n        mappingTable.set(materialIndex, {\n          material: materialIndex,\n          variants: []\n        });\n      }\n      mappingTable.get(materialIndex).variants.push(reIndexedVariants.get(variantData.index));\n    }\n    const mappingsDef = Array.from(mappingTable.values()).map(m => {\n      return m.variants.sort((a, b) => a - b) && m;\n    }).sort((a, b) => a.material - b.material);\n    if (mappingsDef.length === 0) {\n      return;\n    }\n    const originalMaterialIndex = compatibleMaterial(userData.originalMaterial) ? await this.writer.processMaterialAsync(userData.originalMaterial) : -1;\n    for (const primitiveDef of meshDef.primitives) {\n      // Override primitiveDef.material with original material.\n      if (originalMaterialIndex >= 0) {\n        primitiveDef.material = originalMaterialIndex;\n      }\n      primitiveDef.extensions = primitiveDef.extensions || {};\n      primitiveDef.extensions[this.name] = {\n        mappings: mappingsDef\n      };\n    }\n  }\n  afterParse() {\n    if (this.variantNames.length === 0) {\n      return;\n    }\n    const root = this.writer.json;\n    root.extensions = root.extensions || {};\n    const variantsDef = this.variantNames.map(n => {\n      return {\n        name: n\n      };\n    });\n    root.extensions[this.name] = {\n      variants: variantsDef\n    };\n    this.writer.extensionsUsed[this.name] = true;\n  }\n}","map":{"version":3,"names":["compatibleObject","object","material","undefined","userData","variantMaterials","Array","from","values","filter","m","compatibleMaterial","isMaterial","isArray","GLTFExporterMaterialsVariantsExtension","constructor","writer","name","variantNames","beforeParse","objects","variantNameSet","Set","addVariantNames","o","variantDataMap","variantData","variantName","variantMaterial","get","index","add","traverse","forEach","push","writeMesh","mesh","meshDef","mappingTable","Map","reIndexedVariants","variants","sort","a","b","i","entries","set","variantInstance","materialIndex","processMaterialAsync","has","mappingsDef","map","length","originalMaterialIndex","originalMaterial","primitiveDef","primitives","extensions","mappings","afterParse","root","json","variantsDef","n","extensionsUsed"],"sources":["../../../src/three-components/gltf-instance/VariantMaterialExporterPlugin.ts"],"sourcesContent":["/* @license\r\n * Copyright 2021 Google LLC. All Rights Reserved.\r\n * Licensed under the Apache License, Version 2.0 (the 'License');\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an 'AS IS' BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\n/**\r\n * Materials variants extension\r\n *\r\n * Specification:\r\n * https://github.com/takahirox/three-gltf-extensions/tree/main/loaders/KHR_materials_variants\r\n */\r\n\r\n/**\r\n * The code in this file is based on\r\n * https://github.com/takahirox/three-gltf-extensions/tree/main/exporters/KHR_materials_variants\r\n */\r\n\r\nimport {Material, Mesh, Object3D} from 'three';\r\nimport {GLTFExporterPlugin} from 'three/examples/jsm/Addons.js';\r\n\r\nimport {VariantData} from '../../features/scene-graph/model.js';\r\n\r\nimport {UserDataVariantMapping} from './VariantMaterialLoaderPlugin.js';\r\n\r\n\r\n\r\n/**\r\n * @param object {THREE.Object3D}\r\n * @return {boolean}\r\n */\r\nconst compatibleObject = (object: Object3D) => {\r\n  // @TODO: Need properer variantMaterials format validation?\r\n  return (object as Mesh).material !==\r\n      undefined &&        // easier than (!object.isMesh && !object.isLine &&\r\n                          // !object.isPoints)\r\n      object.userData &&  // just in case\r\n      object.userData.variantMaterials &&\r\n      // Is this line costly?\r\n      !!Array\r\n            .from((object.userData.variantMaterials as\r\n                   Map<number, UserDataVariantMapping>)\r\n                      .values())\r\n            .filter(m => compatibleMaterial(m.material));\r\n};\r\n\r\n/**\r\n * @param material {THREE.Material}\r\n * @return {boolean}\r\n */\r\nconst compatibleMaterial = (material: Material|null) => {\r\n  // @TODO: support multi materials?\r\n  return material && material.isMaterial && !Array.isArray(material);\r\n};\r\n\r\nexport default class GLTFExporterMaterialsVariantsExtension implements\r\n    GLTFExporterPlugin {\r\n  writer: any;  // @TODO: Replace with GLTFWriter when GLTFExporter plugin TS\r\n                // declaration is ready\r\n  name: string;\r\n  variantNames: string[];\r\n\r\n  constructor(writer: any) {\r\n    this.writer = writer;\r\n    this.name = 'KHR_materials_variants';\r\n    this.variantNames = [];\r\n  }\r\n\r\n  beforeParse(objects: Object3D|Object3D[]) {\r\n    // Find all variant names and store them to the table\r\n    const variantNameSet = new Set<string>();\r\n\r\n    const addVariantNames = (o: Object3D) => {\r\n      if (!compatibleObject(o)) {\r\n        return;\r\n      }\r\n      const variantMaterials =\r\n          o.userData.variantMaterials as Map<number, UserDataVariantMapping>;\r\n      const variantDataMap = o.userData.variantData as Map<string, VariantData>;\r\n      for (const [variantName, variantData] of variantDataMap) {\r\n        const variantMaterial = variantMaterials.get(variantData.index);\r\n        // Ignore unloaded variant materials\r\n        if (variantMaterial && compatibleMaterial(variantMaterial.material)) {\r\n          variantNameSet.add(variantName);\r\n        }\r\n      }\r\n    };\r\n\r\n    if (Array.isArray(objects)) {\r\n      for (const object of objects) {\r\n        object.traverse(addVariantNames);\r\n      }\r\n    } else {\r\n      objects.traverse(addVariantNames);\r\n    }\r\n    // We may want to sort?\r\n    variantNameSet.forEach(name => this.variantNames.push(name));\r\n  }\r\n\r\n  async writeMesh(mesh: Mesh, meshDef: any) {\r\n    if (!compatibleObject(mesh)) {\r\n      return;\r\n    }\r\n\r\n    const userData = mesh.userData;\r\n    const variantMaterials =\r\n        userData.variantMaterials as Map<number, UserDataVariantMapping>;\r\n    const variantDataMap = userData.variantData as Map<string, VariantData>;\r\n    const mappingTableã€€=\r\n        new Map<number, {material: number, variants: number[]}>();\r\n\r\n    // Removes gaps in the variant indices list (caused by deleting variants).\r\n    const reIndexedVariants = new Map<number, number>();\r\n    const variants = Array.from(variantDataMap.values()).sort((a, b) => {\r\n      return a.index - b.index;\r\n    });\r\n    for (const [i, variantData] of variants.entries()) {\r\n      reIndexedVariants.set(variantData.index, i);\r\n    }\r\n\r\n    for (const variantData of variantDataMap.values()) {\r\n      const variantInstance = variantMaterials.get(variantData.index);\r\n      if (!variantInstance || !compatibleMaterial(variantInstance.material)) {\r\n        continue;\r\n      }\r\n\r\n      const materialIndex =\r\n          await this.writer.processMaterialAsync(variantInstance.material);\r\n      if (!mappingTable.has(materialIndex)) {\r\n        mappingTable.set(\r\n            materialIndex, {material: materialIndex, variants: []});\r\n      }\r\n      mappingTable.get(materialIndex)!.variants.push(\r\n          reIndexedVariants.get(variantData.index)!);\r\n    }\r\n\r\n    const mappingsDef =\r\n        Array.from(mappingTable.values())\r\n            .map((m => {return m.variants.sort((a, b) => a - b) && m}))\r\n            .sort((a, b) => a.material - b.material);\r\n\r\n    if (mappingsDef.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const originalMaterialIndex =\r\n        compatibleMaterial(userData.originalMaterial) ?\r\n        await this.writer.processMaterialAsync(userData.originalMaterial) :\r\n        -1;\r\n\r\n    for (const primitiveDef of meshDef.primitives) {\r\n      // Override primitiveDef.material with original material.\r\n      if (originalMaterialIndex >= 0) {\r\n        primitiveDef.material = originalMaterialIndex;\r\n      }\r\n      primitiveDef.extensions = primitiveDef.extensions || {};\r\n      primitiveDef.extensions[this.name] = {mappings: mappingsDef};\r\n    }\r\n  }\r\n\r\n  afterParse() {\r\n    if (this.variantNames.length === 0) {\r\n      return;\r\n    }\r\n\r\n    const root = this.writer.json;\r\n    root.extensions = root.extensions || {};\r\n\r\n    const variantsDef = this.variantNames.map(n => {\r\n      return {name: n};\r\n    });\r\n    root.extensions[this.name] = {variants: variantsDef};\r\n    this.writer.extensionsUsed[this.name] = true;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}