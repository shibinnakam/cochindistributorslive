{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { StyleEvaluator } from './styles/evaluators.js';\nimport { parseExpressions } from './styles/parsers.js';\nimport { StyleEffector } from './styles/style-effector.js';\n/**\n * The @style decorator is responsible for coordinating the conversion of a\n * CSS-like string property value into numbers that can be applied to\n * lower-level constructs. It also can optionally manage the lifecycle of a\n * StyleEffector which allows automatic updates for styles that use env() or\n * var() functions.\n *\n * The decorator is configured with Intrinsics and the property key for a\n * method that handles updates. The named update handler is invoked with the\n * result of parsing and evaluating the raw property string value. The format of\n * the evaluated result is derived from the basis of the configured Intrinsics,\n * and is always an array of numbers of fixed length.\n *\n * NOTE: This decorator depends on the property updating mechanism defined by\n * UpdatingElement as exported by the lit-element module. That means it *must*\n * be used in conjunction with the @property decorator, or equivalent\n * JavaScript.\n *\n * Supported configurations are:\n *\n *  - `intrinsics`: An Intrinsics struct that describes how to interpret a\n * serialized style attribute. For more detail on intrinsics see\n * ./styles/evaluators.ts\n *  - `updateHandler`: A string or Symbol that is the key of a method to be\n * invoked with the result of parsing and evaluating a serialized style string.\n *  - `observeEffects`: Optional, if set to true then styles that use env() will\n * cause their update handlers to be invoked every time the corresponding\n * environment variable changes (even if the style attribute itself remains\n * static).\n */\nexport const style = config => {\n  const observeEffects = config.observeEffects || false;\n  const getIntrinsics = config.intrinsics instanceof Function ? config.intrinsics : () => config.intrinsics;\n  return (proto, propertyName) => {\n    const originalUpdated = proto.updated;\n    const originalConnectedCallback = proto.connectedCallback;\n    const originalDisconnectedCallback = proto.disconnectedCallback;\n    const $styleEffector = Symbol(`${propertyName}StyleEffector`);\n    const $styleEvaluator = Symbol(`${propertyName}StyleEvaluator`);\n    const $updateEvaluator = Symbol(`${propertyName}UpdateEvaluator`);\n    const $evaluateAndSync = Symbol(`${propertyName}EvaluateAndSync`);\n    Object.defineProperties(proto, {\n      [$styleEffector]: {\n        value: null,\n        writable: true\n      },\n      [$styleEvaluator]: {\n        value: null,\n        writable: true\n      },\n      [$updateEvaluator]: {\n        value: function () {\n          const ast = parseExpressions(this[propertyName]);\n          this[$styleEvaluator] = new StyleEvaluator(ast, getIntrinsics(this));\n          if (this[$styleEffector] == null && observeEffects) {\n            this[$styleEffector] = new StyleEffector(() => this[$evaluateAndSync]());\n          }\n          if (this[$styleEffector] != null) {\n            this[$styleEffector].observeEffectsFor(ast);\n          }\n        }\n      },\n      [$evaluateAndSync]: {\n        value: function () {\n          if (this[$styleEvaluator] == null) {\n            return;\n          }\n          const result = this[$styleEvaluator].evaluate();\n          // @see https://github.com/microsoft/TypeScript/pull/30769\n          // @see https://github.com/Microsoft/TypeScript/issues/1863\n          this[config.updateHandler](result);\n        }\n      },\n      updated: {\n        value: function (changedProperties) {\n          // Always invoke updates to styles first. This gives a class that\n          // uses this decorator the opportunity to override the effect, or\n          // respond to it, in its own implementation of `updated`.\n          if (changedProperties.has(propertyName)) {\n            this[$updateEvaluator]();\n            this[$evaluateAndSync]();\n          }\n          originalUpdated.call(this, changedProperties);\n        }\n      },\n      connectedCallback: {\n        value: function () {\n          originalConnectedCallback.call(this);\n          this.requestUpdate(propertyName, this[propertyName]);\n        }\n      },\n      disconnectedCallback: {\n        value: function () {\n          originalDisconnectedCallback.call(this);\n          if (this[$styleEffector] != null) {\n            this[$styleEffector].dispose();\n            this[$styleEffector] = null;\n          }\n        }\n      }\n    });\n  };\n};","map":{"version":3,"names":["StyleEvaluator","parseExpressions","StyleEffector","style","config","observeEffects","getIntrinsics","intrinsics","Function","proto","propertyName","originalUpdated","updated","originalConnectedCallback","connectedCallback","originalDisconnectedCallback","disconnectedCallback","$styleEffector","Symbol","$styleEvaluator","$updateEvaluator","$evaluateAndSync","Object","defineProperties","value","writable","ast","observeEffectsFor","result","evaluate","updateHandler","changedProperties","has","call","requestUpdate","dispose"],"sources":["../src/decorators.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {ReactiveElement} from 'lit';\n\nimport {EvaluatedStyle, Intrinsics, StyleEvaluator} from './styles/evaluators.js';\nimport {parseExpressions, Unit} from './styles/parsers.js';\nimport {StyleEffector} from './styles/style-effector.js';\n\n// An IntrinsicsFactory generates up-to-date intrinsics for a given ModelViewer\n// element instance when it is invoked.\nexport type IntrinsicsFactory<T extends Intrinsics<Array<Unit>>,\n                                        U extends ReactiveElement> =\n    (element: U) => T;\n\n// When applying the @style decorator, it needs to be configured with\n// corresponding Intrinsics and the property key of a method to receive updated\n// values. Optionally, it can also be configured to observe environment effects,\n// which causes a StyleEffector to be created for the property.\nexport interface StyleDecoratorConfig<T extends Intrinsics<Array<Unit>>,\n                                                U extends ReactiveElement> {\n  intrinsics: T|IntrinsicsFactory<T, U>;\n  updateHandler: symbol;\n  observeEffects?: boolean;\n}\n\n/**\n * The @style decorator is responsible for coordinating the conversion of a\n * CSS-like string property value into numbers that can be applied to\n * lower-level constructs. It also can optionally manage the lifecycle of a\n * StyleEffector which allows automatic updates for styles that use env() or\n * var() functions.\n *\n * The decorator is configured with Intrinsics and the property key for a\n * method that handles updates. The named update handler is invoked with the\n * result of parsing and evaluating the raw property string value. The format of\n * the evaluated result is derived from the basis of the configured Intrinsics,\n * and is always an array of numbers of fixed length.\n *\n * NOTE: This decorator depends on the property updating mechanism defined by\n * UpdatingElement as exported by the lit-element module. That means it *must*\n * be used in conjunction with the @property decorator, or equivalent\n * JavaScript.\n *\n * Supported configurations are:\n *\n *  - `intrinsics`: An Intrinsics struct that describes how to interpret a\n * serialized style attribute. For more detail on intrinsics see\n * ./styles/evaluators.ts\n *  - `updateHandler`: A string or Symbol that is the key of a method to be\n * invoked with the result of parsing and evaluating a serialized style string.\n *  - `observeEffects`: Optional, if set to true then styles that use env() will\n * cause their update handlers to be invoked every time the corresponding\n * environment variable changes (even if the style attribute itself remains\n * static).\n */\nexport const style =\n    <T extends Intrinsics<Array<Unit>>, U extends ReactiveElement>(\n        config: StyleDecoratorConfig<T, U>) => {\n      const observeEffects: boolean = config.observeEffects || false;\n      const getIntrinsics = config.intrinsics instanceof Function ?\n          config.intrinsics :\n          (() => config.intrinsics) as IntrinsicsFactory<T, U>;\n\n      return <U extends typeof ReactiveElement['prototype']>(\n                 proto: U, propertyName: string) => {\n        const originalUpdated = (proto as any).updated;\n        const originalConnectedCallback = proto.connectedCallback;\n        const originalDisconnectedCallback = proto.disconnectedCallback;\n\n        const $styleEffector = Symbol(`${propertyName}StyleEffector`);\n        const $styleEvaluator = Symbol(`${propertyName}StyleEvaluator`);\n        const $updateEvaluator = Symbol(`${propertyName}UpdateEvaluator`);\n        const $evaluateAndSync = Symbol(`${propertyName}EvaluateAndSync`);\n\n        Object.defineProperties(proto, {\n          [$styleEffector]:\n              {value: null as StyleEffector | null, writable: true},\n          [$styleEvaluator]:\n              {value: null as StyleEvaluator<T>| null, writable: true},\n\n          [$updateEvaluator]: {\n            value: function() {\n              const ast = parseExpressions(\n                  this[propertyName as keyof ReactiveElement] as string);\n              this[$styleEvaluator] =\n                  new StyleEvaluator(ast, getIntrinsics(this));\n\n              if (this[$styleEffector] == null && observeEffects) {\n                this[$styleEffector] =\n                    new StyleEffector(() => this[$evaluateAndSync]());\n              }\n\n              if (this[$styleEffector] != null) {\n                this[$styleEffector].observeEffectsFor(ast);\n              }\n            }\n          },\n\n          [$evaluateAndSync]: {\n            value: function() {\n              if (this[$styleEvaluator] == null) {\n                return;\n              }\n\n              const result = this[$styleEvaluator].evaluate();\n\n              // @see https://github.com/microsoft/TypeScript/pull/30769\n              // @see https://github.com/Microsoft/TypeScript/issues/1863\n              (this as unknown as Record<\n                   string,\n                   (style: EvaluatedStyle<T>) =>\n                       void>)[config.updateHandler as unknown as string](\n                  result);\n            }\n          },\n\n          updated: {\n            value: function(changedProperties: Map<string, any>) {\n              // Always invoke updates to styles first. This gives a class that\n              // uses this decorator the opportunity to override the effect, or\n              // respond to it, in its own implementation of `updated`.\n              if (changedProperties.has(propertyName)) {\n                this[$updateEvaluator]();\n                this[$evaluateAndSync]();\n              }\n\n              originalUpdated.call(this, changedProperties);\n            }\n          },\n\n          connectedCallback: {\n            value: function() {\n              originalConnectedCallback.call(this);\n              this.requestUpdate(propertyName, this[propertyName]);\n            }\n          },\n\n          disconnectedCallback: {\n            value: function() {\n              originalDisconnectedCallback.call(this);\n              if (this[$styleEffector] != null) {\n                this[$styleEffector].dispose();\n                this[$styleEffector] = null;\n              }\n            }\n          }\n        });\n      };\n    };"],"mappings":"AAAA;;;;;;;;;;;;;;AAiBA,SAAoCA,cAAc,QAAO,wBAAwB;AACjF,SAAQC,gBAAgB,QAAa,qBAAqB;AAC1D,SAAQC,aAAa,QAAO,4BAA4B;AAmBxD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8BA,OAAO,MAAMC,KAAK,GAEVC,MAAkC,IAAI;EACxC,MAAMC,cAAc,GAAYD,MAAM,CAACC,cAAc,IAAI,KAAK;EAC9D,MAAMC,aAAa,GAAGF,MAAM,CAACG,UAAU,YAAYC,QAAQ,GACvDJ,MAAM,CAACG,UAAU,GAChB,MAAMH,MAAM,CAACG,UAAsC;EAExD,OAAO,CACIE,KAAQ,EAAEC,YAAoB,KAAI;IAC3C,MAAMC,eAAe,GAAIF,KAAa,CAACG,OAAO;IAC9C,MAAMC,yBAAyB,GAAGJ,KAAK,CAACK,iBAAiB;IACzD,MAAMC,4BAA4B,GAAGN,KAAK,CAACO,oBAAoB;IAE/D,MAAMC,cAAc,GAAGC,MAAM,CAAC,GAAGR,YAAY,eAAe,CAAC;IAC7D,MAAMS,eAAe,GAAGD,MAAM,CAAC,GAAGR,YAAY,gBAAgB,CAAC;IAC/D,MAAMU,gBAAgB,GAAGF,MAAM,CAAC,GAAGR,YAAY,iBAAiB,CAAC;IACjE,MAAMW,gBAAgB,GAAGH,MAAM,CAAC,GAAGR,YAAY,iBAAiB,CAAC;IAEjEY,MAAM,CAACC,gBAAgB,CAACd,KAAK,EAAE;MAC7B,CAACQ,cAAc,GACX;QAACO,KAAK,EAAE,IAA4B;QAAEC,QAAQ,EAAE;MAAI,CAAC;MACzD,CAACN,eAAe,GACZ;QAACK,KAAK,EAAE,IAA+B;QAAEC,QAAQ,EAAE;MAAI,CAAC;MAE5D,CAACL,gBAAgB,GAAG;QAClBI,KAAK,EAAE,SAAAA,CAAA;UACL,MAAME,GAAG,GAAGzB,gBAAgB,CACxB,IAAI,CAACS,YAAqC,CAAW,CAAC;UAC1D,IAAI,CAACS,eAAe,CAAC,GACjB,IAAInB,cAAc,CAAC0B,GAAG,EAAEpB,aAAa,CAAC,IAAI,CAAC,CAAC;UAEhD,IAAI,IAAI,CAACW,cAAc,CAAC,IAAI,IAAI,IAAIZ,cAAc,EAAE;YAClD,IAAI,CAACY,cAAc,CAAC,GAChB,IAAIf,aAAa,CAAC,MAAM,IAAI,CAACmB,gBAAgB,CAAC,EAAE,CAAC;UACvD;UAEA,IAAI,IAAI,CAACJ,cAAc,CAAC,IAAI,IAAI,EAAE;YAChC,IAAI,CAACA,cAAc,CAAC,CAACU,iBAAiB,CAACD,GAAG,CAAC;UAC7C;QACF;OACD;MAED,CAACL,gBAAgB,GAAG;QAClBG,KAAK,EAAE,SAAAA,CAAA;UACL,IAAI,IAAI,CAACL,eAAe,CAAC,IAAI,IAAI,EAAE;YACjC;UACF;UAEA,MAAMS,MAAM,GAAG,IAAI,CAACT,eAAe,CAAC,CAACU,QAAQ,EAAE;UAE/C;UACA;UACC,IAGc,CAACzB,MAAM,CAAC0B,aAAkC,CAAC,CACtDF,MAAM,CAAC;QACb;OACD;MAEDhB,OAAO,EAAE;QACPY,KAAK,EAAE,SAAAA,CAASO,iBAAmC;UACjD;UACA;UACA;UACA,IAAIA,iBAAiB,CAACC,GAAG,CAACtB,YAAY,CAAC,EAAE;YACvC,IAAI,CAACU,gBAAgB,CAAC,EAAE;YACxB,IAAI,CAACC,gBAAgB,CAAC,EAAE;UAC1B;UAEAV,eAAe,CAACsB,IAAI,CAAC,IAAI,EAAEF,iBAAiB,CAAC;QAC/C;OACD;MAEDjB,iBAAiB,EAAE;QACjBU,KAAK,EAAE,SAAAA,CAAA;UACLX,yBAAyB,CAACoB,IAAI,CAAC,IAAI,CAAC;UACpC,IAAI,CAACC,aAAa,CAACxB,YAAY,EAAE,IAAI,CAACA,YAAY,CAAC,CAAC;QACtD;OACD;MAEDM,oBAAoB,EAAE;QACpBQ,KAAK,EAAE,SAAAA,CAAA;UACLT,4BAA4B,CAACkB,IAAI,CAAC,IAAI,CAAC;UACvC,IAAI,IAAI,CAAChB,cAAc,CAAC,IAAI,IAAI,EAAE;YAChC,IAAI,CAACA,cAAc,CAAC,CAACkB,OAAO,EAAE;YAC9B,IAAI,CAAClB,cAAc,CAAC,GAAG,IAAI;UAC7B;QACF;;KAEH,CAAC;EACJ,CAAC;AACH,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}