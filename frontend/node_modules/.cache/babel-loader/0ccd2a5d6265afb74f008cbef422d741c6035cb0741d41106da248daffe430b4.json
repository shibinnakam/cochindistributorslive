{"ast":null,"code":"/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b;\nconst $retainerCount = Symbol('retainerCount');\nconst $recentlyUsed = Symbol('recentlyUsed');\nconst $evict = Symbol('evict');\nconst $evictionThreshold = Symbol('evictionThreshold');\nconst $cache = Symbol('cache');\n/**\n * The CacheEvictionPolicy manages the lifecycle for items in a cache,\n * evicting any items outside some threshold bounds in \"recently used\" order,\n * if they are evictable.\n *\n * Items are considered cached as they are retained. When all retainers\n * of an item release it, that item is considered evictable.\n */\nexport class CacheEvictionPolicy {\n  constructor(cache, evictionThreshold = 5) {\n    this[_a] = new Map();\n    this[_b] = [];\n    this[$cache] = cache;\n    this[$evictionThreshold] = evictionThreshold;\n  }\n  /**\n   * The eviction threshold is the maximum number of items to hold\n   * in cache indefinitely. Items within the threshold (in recently\n   * used order) will continue to be cached even if they have zero\n   * retainers.\n   */\n  set evictionThreshold(value) {\n    this[$evictionThreshold] = value;\n    this[$evict]();\n  }\n  get evictionThreshold() {\n    return this[$evictionThreshold];\n  }\n  /**\n   * A reference to the cache that operates under this policy\n   */\n  get cache() {\n    return this[$cache];\n  }\n  /**\n   * Given an item key, returns the number of retainers of that item\n   */\n  retainerCount(key) {\n    return this[$retainerCount].get(key) || 0;\n  }\n  /**\n   * Resets the internal tracking of cache item retainers. Use only in cases\n   * where it is certain that all retained cache items have been accounted for!\n   */\n  reset() {\n    this[$retainerCount].clear();\n    this[$recentlyUsed] = [];\n  }\n  /**\n   * Mark a given cache item as retained, where the item is represented\n   * by its key. An item can have any number of retainers.\n   */\n  retain(key) {\n    if (!this[$retainerCount].has(key)) {\n      this[$retainerCount].set(key, 0);\n    }\n    this[$retainerCount].set(key, this[$retainerCount].get(key) + 1);\n    const recentlyUsedIndex = this[$recentlyUsed].indexOf(key);\n    if (recentlyUsedIndex !== -1) {\n      this[$recentlyUsed].splice(recentlyUsedIndex, 1);\n    }\n    this[$recentlyUsed].unshift(key);\n    // Evict, in case retaining a new item pushed an evictable item beyond the\n    // eviction threshold\n    this[$evict]();\n  }\n  /**\n   * Mark a given cache item as released by one of its retainers, where the item\n   * is represented by its key. When all retainers of an item have released it,\n   * the item is considered evictable.\n   */\n  release(key) {\n    if (this[$retainerCount].has(key)) {\n      this[$retainerCount].set(key, Math.max(this[$retainerCount].get(key) - 1, 0));\n    }\n    this[$evict]();\n  }\n  [(_a = $retainerCount, _b = $recentlyUsed, $evict)]() {\n    if (this[$recentlyUsed].length < this[$evictionThreshold]) {\n      return;\n    }\n    for (let i = this[$recentlyUsed].length - 1; i >= this[$evictionThreshold]; --i) {\n      const key = this[$recentlyUsed][i];\n      const retainerCount = this[$retainerCount].get(key);\n      if (retainerCount === 0) {\n        this[$cache].delete(key);\n        this[$recentlyUsed].splice(i, 1);\n      }\n    }\n  }\n}","map":{"version":3,"names":["$retainerCount","Symbol","$recentlyUsed","$evict","$evictionThreshold","$cache","CacheEvictionPolicy","constructor","cache","evictionThreshold","_a","Map","_b","value","retainerCount","key","get","reset","clear","retain","has","set","recentlyUsedIndex","indexOf","splice","unshift","release","Math","max","length","i","delete"],"sources":["../../src/utilities/cache-eviction-policy.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * A mutable cache is any object that has that allows cache\n * items to be deleted imperatively given their key\n */\nexport interface MutableCache<T> {\n  delete(key: T): void;\n}\n\nconst $retainerCount = Symbol('retainerCount');\nconst $recentlyUsed = Symbol('recentlyUsed');\nconst $evict = Symbol('evict');\nconst $evictionThreshold = Symbol('evictionThreshold');\nconst $cache = Symbol('cache');\n\n/**\n * The CacheEvictionPolicy manages the lifecycle for items in a cache,\n * evicting any items outside some threshold bounds in \"recently used\" order,\n * if they are evictable.\n *\n * Items are considered cached as they are retained. When all retainers\n * of an item release it, that item is considered evictable.\n */\nexport class CacheEvictionPolicy<T = string> {\n  private[$retainerCount] = new Map<T, number>();\n  private[$recentlyUsed]: Array<T> = [];\n  private[$evictionThreshold]: number;\n  private[$cache]: MutableCache<T>;\n\n  constructor(cache: MutableCache<T>, evictionThreshold: number = 5) {\n    this[$cache] = cache;\n    this[$evictionThreshold] = evictionThreshold;\n  }\n\n  /**\n   * The eviction threshold is the maximum number of items to hold\n   * in cache indefinitely. Items within the threshold (in recently\n   * used order) will continue to be cached even if they have zero\n   * retainers.\n   */\n  set evictionThreshold(value: number) {\n    this[$evictionThreshold] = value;\n    this[$evict]();\n  }\n\n  get evictionThreshold(): number {\n    return this[$evictionThreshold];\n  }\n\n  /**\n   * A reference to the cache that operates under this policy\n   */\n  get cache(): MutableCache<T> {\n    return this[$cache];\n  }\n\n  /**\n   * Given an item key, returns the number of retainers of that item\n   */\n  retainerCount(key: T): number {\n    return this[$retainerCount].get(key) || 0;\n  }\n\n  /**\n   * Resets the internal tracking of cache item retainers. Use only in cases\n   * where it is certain that all retained cache items have been accounted for!\n   */\n  reset() {\n    this[$retainerCount].clear();\n    this[$recentlyUsed] = [];\n  }\n\n  /**\n   * Mark a given cache item as retained, where the item is represented\n   * by its key. An item can have any number of retainers.\n   */\n  retain(key: T) {\n    if (!this[$retainerCount].has(key)) {\n      this[$retainerCount].set(key, 0);\n    }\n    this[$retainerCount].set(key, this[$retainerCount].get(key)! + 1);\n\n    const recentlyUsedIndex = this[$recentlyUsed].indexOf(key);\n\n    if (recentlyUsedIndex !== -1) {\n      this[$recentlyUsed].splice(recentlyUsedIndex, 1);\n    }\n\n    this[$recentlyUsed].unshift(key);\n    // Evict, in case retaining a new item pushed an evictable item beyond the\n    // eviction threshold\n    this[$evict]();\n  }\n\n  /**\n   * Mark a given cache item as released by one of its retainers, where the item\n   * is represented by its key. When all retainers of an item have released it,\n   * the item is considered evictable.\n   */\n  release(key: T) {\n    if (this[$retainerCount].has(key)) {\n      this[$retainerCount].set(\n          key, Math.max(this[$retainerCount].get(key)! - 1, 0));\n    }\n\n    this[$evict]();\n  }\n\n  [$evict]() {\n    if (this[$recentlyUsed].length < this[$evictionThreshold]) {\n      return;\n    }\n\n    for (let i = this[$recentlyUsed].length - 1; i >= this[$evictionThreshold];\n         --i) {\n      const key = this[$recentlyUsed][i];\n      const retainerCount = this[$retainerCount].get(key);\n\n      if (retainerCount === 0) {\n        this[$cache].delete(key);\n        this[$recentlyUsed].splice(i, 1);\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}