{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { NoColorSpace, DoubleSide, Color } from 'three';\nimport { strToU8, zipSync } from '../libs/fflate.module.js';\nclass USDNode {\n  constructor(name, type = '', metadata = [], properties = []) {\n    this.name = name;\n    this.type = type;\n    this.metadata = metadata;\n    this.properties = properties;\n    this.children = [];\n  }\n  addMetadata(key, value) {\n    this.metadata.push({\n      key,\n      value\n    });\n  }\n  addProperty(property, metadata = []) {\n    this.properties.push({\n      property,\n      metadata\n    });\n  }\n  addChild(child) {\n    this.children.push(child);\n  }\n  toString(indent = 0) {\n    const pad = '\\t'.repeat(indent);\n    const formattedMetadata = this.metadata.map(item => {\n      const key = item.key;\n      const value = item.value;\n      if (Array.isArray(value)) {\n        const lines = [];\n        lines.push(`${key} = {`);\n        value.forEach(line => {\n          lines.push(`${pad}\\t\\t${line}`);\n        });\n        lines.push(`${pad}\\t}`);\n        return lines.join('\\n');\n      } else {\n        return `${key} = ${value}`;\n      }\n    });\n    const meta = formattedMetadata.length ? ` (\\n${formattedMetadata.map(l => `${pad}\\t${l}`).join('\\n')}\\n${pad})` : '';\n    const properties = this.properties.map(l => {\n      const property = l.property;\n      const metadata = l.metadata.length ? ` (\\n${l.metadata.map(m => `${pad}\\t\\t${m}`).join('\\n')}\\n${pad}\\t)` : '';\n      return `${pad}\\t${property}${metadata}`;\n    });\n    const children = this.children.map(c => c.toString(indent + 1));\n    const bodyLines = [];\n    if (properties.length > 0) {\n      bodyLines.push(...properties);\n    }\n    if (children.length > 0) {\n      if (properties.length > 0) {\n        bodyLines.push('');\n      }\n      for (let i = 0; i < children.length; i++) {\n        bodyLines.push(children[i]);\n        if (i < children.length - 1) {\n          bodyLines.push('');\n        }\n      }\n    }\n    const bodyContent = bodyLines.join('\\n');\n    const type = this.type ? this.type + ' ' : '';\n    return `${pad}def ${type}\"${this.name}\"${meta}\\n${pad}{\\n${bodyContent}\\n${pad}}`;\n  }\n}\n\n/**\n * An exporter for USDZ.\n *\n * ```js\n * const exporter = new USDZExporter();\n * const arraybuffer = await exporter.parseAsync( scene );\n * ```\n *\n * @three_import import { USDZExporter } from 'three/addons/exporters/USDZExporter.js';\n */\nclass USDZExporter {\n  /**\n   * Constructs a new USDZ exporter.\n   */\n  constructor() {\n    /**\n     * A reference to a texture utils module.\n     *\n     * @type {?(WebGLTextureUtils|WebGPUTextureUtils)}\n     * @default null\n     */\n    this.textureUtils = null;\n  }\n\n  /**\n   * Sets the texture utils for this exporter. Only relevant when compressed textures have to be exported.\n   *\n   * Depending on whether you use {@link WebGLRenderer} or {@link WebGPURenderer}, you must inject the\n   * corresponding texture utils {@link WebGLTextureUtils} or {@link WebGPUTextureUtils}.\n   *\n   * @param {WebGLTextureUtils|WebGPUTextureUtils} utils - The texture utils.\n   */\n  setTextureUtils(utils) {\n    this.textureUtils = utils;\n  }\n\n  /**\n   * Parse the given 3D object and generates the USDZ output.\n   *\n   * @param {Object3D} scene - The 3D object to export.\n   * @param {USDZExporter~OnDone} onDone - A callback function that is executed when the export has finished.\n   * @param {USDZExporter~OnError} onError - A callback function that is executed when an error happens.\n   * @param {USDZExporter~Options} options - The export options.\n   */\n  parse(scene, onDone, onError, options) {\n    this.parseAsync(scene, options).then(onDone).catch(onError);\n  }\n\n  /**\n   * Async version of {@link USDZExporter#parse}.\n   *\n   * @async\n   * @param {Object3D} scene - The 3D object to export.\n   * @param {USDZExporter~Options} options - The export options.\n   * @return {Promise<ArrayBuffer>} A Promise that resolved with the exported USDZ data.\n   */\n  async parseAsync(scene, options = {}) {\n    options = Object.assign({\n      ar: {\n        anchoring: {\n          type: 'plane'\n        },\n        planeAnchoring: {\n          alignment: 'horizontal'\n        }\n      },\n      includeAnchoringProperties: true,\n      onlyVisible: true,\n      quickLookCompatible: false,\n      maxTextureSize: 1024\n    }, options);\n    const usedNames = new Set();\n    const files = {};\n    const modelFileName = 'model.usda';\n\n    // model file should be first in USDZ archive so we init it here\n    files[modelFileName] = null;\n    const root = new USDNode('Root', 'Xform');\n    const scenesNode = new USDNode('Scenes', 'Scope');\n    scenesNode.addMetadata('kind', '\"sceneLibrary\"');\n    root.addChild(scenesNode);\n    const sceneName = 'Scene';\n    const sceneNode = new USDNode(sceneName, 'Xform');\n    sceneNode.addMetadata('customData', ['bool preliminary_collidesWithEnvironment = 0', `string sceneName = \"${sceneName}\"`]);\n    sceneNode.addMetadata('sceneName', `\"${sceneName}\"`);\n    if (options.includeAnchoringProperties) {\n      sceneNode.addProperty(`token preliminary:anchoring:type = \"${options.ar.anchoring.type}\"`);\n      sceneNode.addProperty(`token preliminary:planeAnchoring:alignment = \"${options.ar.planeAnchoring.alignment}\"`);\n    }\n    scenesNode.addChild(sceneNode);\n    let output;\n    const materials = {};\n    const textures = {};\n    buildHierarchy(scene, sceneNode, materials, usedNames, files, options);\n    const materialsNode = buildMaterials(materials, textures, options.quickLookCompatible);\n    output = buildHeader() + '\\n' + root.toString() + '\\n\\n' + materialsNode.toString();\n    files[modelFileName] = strToU8(output);\n    output = null;\n    for (const id in textures) {\n      let texture = textures[id];\n      if (texture.isCompressedTexture === true) {\n        if (this.textureUtils === null) {\n          throw new Error('THREE.USDZExporter: setTextureUtils() must be called to process compressed textures.');\n        } else {\n          texture = await this.textureUtils.decompress(texture);\n        }\n      }\n      const canvas = imageToCanvas(texture.image, texture.flipY, options.maxTextureSize);\n      const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png', 1));\n      files[`textures/Texture_${id}.png`] = new Uint8Array(await blob.arrayBuffer());\n    }\n\n    // 64 byte alignment\n    // https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n    let offset = 0;\n    for (const filename in files) {\n      const file = files[filename];\n      const headerSize = 34 + filename.length;\n      offset += headerSize;\n      const offsetMod64 = offset & 63;\n      if (offsetMod64 !== 4) {\n        const padLength = 64 - offsetMod64;\n        const padding = new Uint8Array(padLength);\n        files[filename] = [file, {\n          extra: {\n            12345: padding\n          }\n        }];\n      }\n      offset = file.length;\n    }\n    return zipSync(files, {\n      level: 0\n    });\n  }\n}\nfunction getName(object, namesSet) {\n  let name = object.name;\n  name = name.replace(/[^A-Za-z0-9_]/g, '');\n  if (/^[0-9]/.test(name)) {\n    name = '_' + name;\n  }\n  if (name === '') {\n    if (object.isCamera) {\n      name = 'Camera';\n    } else {\n      name = 'Object';\n    }\n  }\n  if (namesSet.has(name)) {\n    name = name + '_' + object.id;\n  }\n  namesSet.add(name);\n  return name;\n}\nfunction imageToCanvas(image, flipY, maxTextureSize) {\n  if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {\n    const scale = maxTextureSize / Math.max(image.width, image.height);\n    const canvas = document.createElement('canvas');\n    canvas.width = image.width * Math.min(1, scale);\n    canvas.height = image.height * Math.min(1, scale);\n    const context = canvas.getContext('2d');\n\n    // TODO: We should be able to do this in the UsdTransform2d?\n\n    if (flipY === true) {\n      context.translate(0, canvas.height);\n      context.scale(1, -1);\n    }\n    context.drawImage(image, 0, 0, canvas.width, canvas.height);\n    return canvas;\n  } else {\n    throw new Error('THREE.USDZExporter: No valid image data found. Unable to process texture.');\n  }\n}\n\n//\n\nconst PRECISION = 7;\nfunction buildHeader() {\n  return `#usda 1.0\n(\n\tcustomLayerData = {\n\t\tstring creator = \"Three.js USDZExporter\"\n\t}\n\tdefaultPrim = \"Root\"\n\tmetersPerUnit = 1\n\tupAxis = \"Y\"\n)\n`;\n}\n\n// Xform\n\nfunction buildHierarchy(object, parentNode, materials, usedNames, files, options) {\n  for (let i = 0, l = object.children.length; i < l; i++) {\n    const child = object.children[i];\n    if (child.visible === false && options.onlyVisible === true) continue;\n    let childNode;\n    if (child.isMesh) {\n      const geometry = child.geometry;\n      const material = child.material;\n      if (material.isMeshStandardMaterial) {\n        const geometryFileName = 'geometries/Geometry_' + geometry.id + '.usda';\n        if (!(geometryFileName in files)) {\n          const meshObject = buildMeshObject(geometry);\n          files[geometryFileName] = strToU8(buildHeader() + '\\n' + meshObject.toString());\n        }\n        if (!(material.uuid in materials)) {\n          materials[material.uuid] = material;\n        }\n        childNode = buildMesh(child, geometry, materials[material.uuid], usedNames);\n      } else {\n        console.warn('THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)', child);\n      }\n    } else if (child.isCamera) {\n      childNode = buildCamera(child, usedNames);\n    } else {\n      childNode = buildXform(child, usedNames);\n    }\n    if (childNode) {\n      parentNode.addChild(childNode);\n      buildHierarchy(child, childNode, materials, usedNames, files, options);\n    }\n  }\n}\nfunction buildXform(object, usedNames) {\n  const name = getName(object, usedNames);\n  const transform = buildMatrix(object.matrix);\n  if (object.matrix.determinant() < 0) {\n    console.warn('THREE.USDZExporter: USDZ does not support negative scales', object);\n  }\n  const node = new USDNode(name, 'Xform');\n  node.addProperty(`matrix4d xformOp:transform = ${transform}`);\n  node.addProperty('uniform token[] xformOpOrder = [\"xformOp:transform\"]');\n  return node;\n}\nfunction buildMesh(object, geometry, material, usedNames) {\n  const node = buildXform(object, usedNames);\n  node.addMetadata('prepend references', `@./geometries/Geometry_${geometry.id}.usda@</Geometry>`);\n  node.addMetadata('prepend apiSchemas', '[\"MaterialBindingAPI\"]');\n  node.addProperty(`rel material:binding = </Materials/Material_${material.id}>`);\n  return node;\n}\nfunction buildMatrix(matrix) {\n  const array = matrix.elements;\n  return `( ${buildMatrixRow(array, 0)}, ${buildMatrixRow(array, 4)}, ${buildMatrixRow(array, 8)}, ${buildMatrixRow(array, 12)} )`;\n}\nfunction buildMatrixRow(array, offset) {\n  return `(${array[offset + 0]}, ${array[offset + 1]}, ${array[offset + 2]}, ${array[offset + 3]})`;\n}\n\n// Mesh\n\nfunction buildMeshObject(geometry) {\n  const node = new USDNode('Geometry');\n  const meshNode = buildMeshNode(geometry);\n  node.addChild(meshNode);\n  return node;\n}\nfunction buildMeshNode(geometry) {\n  const name = 'Geometry';\n  const attributes = geometry.attributes;\n  const count = attributes.position.count;\n  const node = new USDNode(name, 'Mesh');\n  node.addProperty(`int[] faceVertexCounts = [${buildMeshVertexCount(geometry)}]`);\n  node.addProperty(`int[] faceVertexIndices = [${buildMeshVertexIndices(geometry)}]`);\n  node.addProperty(`normal3f[] normals = [${buildVector3Array(attributes.normal, count)}]`, ['interpolation = \"vertex\"']);\n  node.addProperty(`point3f[] points = [${buildVector3Array(attributes.position, count)}]`);\n  for (let i = 0; i < 4; i++) {\n    const id = i > 0 ? i : '';\n    const attribute = attributes['uv' + id];\n    if (attribute !== undefined) {\n      node.addProperty(`texCoord2f[] primvars:st${id} = [${buildVector2Array(attribute)}]`, ['interpolation = \"vertex\"']);\n    }\n  }\n  const colorAttribute = attributes.color;\n  if (colorAttribute !== undefined) {\n    node.addProperty(`color3f[] primvars:displayColor = [${buildVector3Array(colorAttribute, count)}]`, ['interpolation = \"vertex\"']);\n  }\n  node.addProperty('uniform token subdivisionScheme = \"none\"');\n  return node;\n}\nfunction buildMeshVertexCount(geometry) {\n  const count = geometry.index !== null ? geometry.index.count : geometry.attributes.position.count;\n  return Array(count / 3).fill(3).join(', ');\n}\nfunction buildMeshVertexIndices(geometry) {\n  const index = geometry.index;\n  const array = [];\n  if (index !== null) {\n    for (let i = 0; i < index.count; i++) {\n      array.push(index.getX(i));\n    }\n  } else {\n    const length = geometry.attributes.position.count;\n    for (let i = 0; i < length; i++) {\n      array.push(i);\n    }\n  }\n  return array.join(', ');\n}\nfunction buildVector3Array(attribute, count) {\n  if (attribute === undefined) {\n    console.warn('USDZExporter: Normals missing.');\n    return Array(count).fill('(0, 0, 0)').join(', ');\n  }\n  const array = [];\n  for (let i = 0; i < attribute.count; i++) {\n    const x = attribute.getX(i);\n    const y = attribute.getY(i);\n    const z = attribute.getZ(i);\n    array.push(`(${x.toPrecision(PRECISION)}, ${y.toPrecision(PRECISION)}, ${z.toPrecision(PRECISION)})`);\n  }\n  return array.join(', ');\n}\nfunction buildVector2Array(attribute) {\n  const array = [];\n  for (let i = 0; i < attribute.count; i++) {\n    const x = attribute.getX(i);\n    const y = attribute.getY(i);\n    array.push(`(${x.toPrecision(PRECISION)}, ${1 - y.toPrecision(PRECISION)})`);\n  }\n  return array.join(', ');\n}\n\n// Materials\n\nfunction buildMaterials(materials, textures, quickLookCompatible = false) {\n  const materialsNode = new USDNode('Materials');\n  for (const uuid in materials) {\n    const material = materials[uuid];\n    materialsNode.addChild(buildMaterial(material, textures, quickLookCompatible));\n  }\n  return materialsNode;\n}\nfunction buildMaterial(material, textures, quickLookCompatible = false) {\n  // https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n\n  const materialNode = new USDNode(`Material_${material.id}`, 'Material');\n  function buildTextureNodes(texture, mapType, color) {\n    const id = texture.source.id + '_' + texture.flipY;\n    textures[id] = texture;\n    const uv = texture.channel > 0 ? 'st' + texture.channel : 'st';\n    const WRAPPINGS = {\n      1000: 'repeat',\n      // RepeatWrapping\n      1001: 'clamp',\n      // ClampToEdgeWrapping\n      1002: 'mirror' // MirroredRepeatWrapping\n    };\n    const repeat = texture.repeat.clone();\n    const offset = texture.offset.clone();\n    const rotation = texture.rotation;\n\n    // rotation is around the wrong point. after rotation we need to shift offset again so that we're rotating around the right spot\n    const xRotationOffset = Math.sin(rotation);\n    const yRotationOffset = Math.cos(rotation);\n\n    // texture coordinates start in the opposite corner, need to correct\n    offset.y = 1 - offset.y - repeat.y;\n\n    // turns out QuickLook is buggy and interprets texture repeat inverted/applies operations in a different order.\n    // Apple Feedback: \tFB10036297 and FB11442287\n    if (quickLookCompatible) {\n      // This is NOT correct yet in QuickLook, but comes close for a range of models.\n      // It becomes more incorrect the bigger the offset is\n\n      offset.x = offset.x / repeat.x;\n      offset.y = offset.y / repeat.y;\n      offset.x += xRotationOffset / repeat.x;\n      offset.y += yRotationOffset - 1;\n    } else {\n      // results match glTF results exactly. verified correct in usdview.\n      offset.x += xRotationOffset * repeat.x;\n      offset.y += (1 - yRotationOffset) * repeat.y;\n    }\n    const primvarReaderNode = new USDNode(`PrimvarReader_${mapType}`, 'Shader');\n    primvarReaderNode.addProperty('uniform token info:id = \"UsdPrimvarReader_float2\"');\n    primvarReaderNode.addProperty('float2 inputs:fallback = (0.0, 0.0)');\n    primvarReaderNode.addProperty(`string inputs:varname = \"${uv}\"`);\n    primvarReaderNode.addProperty('float2 outputs:result');\n    const transform2dNode = new USDNode(`Transform2d_${mapType}`, 'Shader');\n    transform2dNode.addProperty('uniform token info:id = \"UsdTransform2d\"');\n    transform2dNode.addProperty(`float2 inputs:in.connect = </Materials/Material_${material.id}/PrimvarReader_${mapType}.outputs:result>`);\n    transform2dNode.addProperty(`float inputs:rotation = ${(rotation * (180 / Math.PI)).toFixed(PRECISION)}`);\n    transform2dNode.addProperty(`float2 inputs:scale = ${buildVector2(repeat)}`);\n    transform2dNode.addProperty(`float2 inputs:translation = ${buildVector2(offset)}`);\n    transform2dNode.addProperty('float2 outputs:result');\n    const textureNode = new USDNode(`Texture_${texture.id}_${mapType}`, 'Shader');\n    textureNode.addProperty('uniform token info:id = \"UsdUVTexture\"');\n    textureNode.addProperty(`asset inputs:file = @textures/Texture_${id}.png@`);\n    textureNode.addProperty(`float2 inputs:st.connect = </Materials/Material_${material.id}/Transform2d_${mapType}.outputs:result>`);\n    if (color !== undefined) {\n      textureNode.addProperty(`float4 inputs:scale = ${buildColor4(color)}`);\n    }\n    if (mapType === 'normal') {\n      textureNode.addProperty('float4 inputs:scale = (2, 2, 2, 1)');\n      textureNode.addProperty('float4 inputs:bias = (-1, -1, -1, 0)');\n    }\n    textureNode.addProperty(`token inputs:sourceColorSpace = \"${texture.colorSpace === NoColorSpace ? 'raw' : 'sRGB'}\"`);\n    textureNode.addProperty(`token inputs:wrapS = \"${WRAPPINGS[texture.wrapS]}\"`);\n    textureNode.addProperty(`token inputs:wrapT = \"${WRAPPINGS[texture.wrapT]}\"`);\n    textureNode.addProperty('float outputs:r');\n    textureNode.addProperty('float outputs:g');\n    textureNode.addProperty('float outputs:b');\n    textureNode.addProperty('float3 outputs:rgb');\n    if (material.transparent || material.alphaTest > 0.0) {\n      textureNode.addProperty('float outputs:a');\n    }\n    return [primvarReaderNode, transform2dNode, textureNode];\n  }\n  if (material.side === DoubleSide) {\n    console.warn('THREE.USDZExporter: USDZ does not support double sided materials', material);\n  }\n  const previewSurfaceNode = new USDNode('PreviewSurface', 'Shader');\n  previewSurfaceNode.addProperty('uniform token info:id = \"UsdPreviewSurface\"');\n  if (material.map !== null) {\n    previewSurfaceNode.addProperty(`color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`);\n    if (material.transparent) {\n      previewSurfaceNode.addProperty(`float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:a>`);\n    } else if (material.alphaTest > 0.0) {\n      previewSurfaceNode.addProperty(`float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:a>`);\n      previewSurfaceNode.addProperty(`float inputs:opacityThreshold = ${material.alphaTest}`);\n    }\n    const textureNodes = buildTextureNodes(material.map, 'diffuse', material.color);\n    textureNodes.forEach(node => materialNode.addChild(node));\n  } else {\n    previewSurfaceNode.addProperty(`color3f inputs:diffuseColor = ${buildColor(material.color)}`);\n  }\n  if (material.emissiveMap !== null) {\n    previewSurfaceNode.addProperty(`color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`);\n    const emissiveColor = new Color(material.emissive.r * material.emissiveIntensity, material.emissive.g * material.emissiveIntensity, material.emissive.b * material.emissiveIntensity);\n    const textureNodes = buildTextureNodes(material.emissiveMap, 'emissive', emissiveColor);\n    textureNodes.forEach(node => materialNode.addChild(node));\n  } else if (material.emissive.getHex() > 0) {\n    previewSurfaceNode.addProperty(`color3f inputs:emissiveColor = ${buildColor(material.emissive)}`);\n  }\n  if (material.normalMap !== null) {\n    previewSurfaceNode.addProperty(`normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`);\n    const textureNodes = buildTextureNodes(material.normalMap, 'normal');\n    textureNodes.forEach(node => materialNode.addChild(node));\n  }\n  if (material.aoMap !== null) {\n    previewSurfaceNode.addProperty(`float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`);\n    const aoColor = new Color(material.aoMapIntensity, material.aoMapIntensity, material.aoMapIntensity);\n    const textureNodes = buildTextureNodes(material.aoMap, 'occlusion', aoColor);\n    textureNodes.forEach(node => materialNode.addChild(node));\n  }\n  if (material.roughnessMap !== null) {\n    previewSurfaceNode.addProperty(`float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`);\n    const roughnessColor = new Color(material.roughness, material.roughness, material.roughness);\n    const textureNodes = buildTextureNodes(material.roughnessMap, 'roughness', roughnessColor);\n    textureNodes.forEach(node => materialNode.addChild(node));\n  } else {\n    previewSurfaceNode.addProperty(`float inputs:roughness = ${material.roughness}`);\n  }\n  if (material.metalnessMap !== null) {\n    previewSurfaceNode.addProperty(`float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`);\n    const metalnessColor = new Color(material.metalness, material.metalness, material.metalness);\n    const textureNodes = buildTextureNodes(material.metalnessMap, 'metallic', metalnessColor);\n    textureNodes.forEach(node => materialNode.addChild(node));\n  } else {\n    previewSurfaceNode.addProperty(`float inputs:metallic = ${material.metalness}`);\n  }\n  if (material.alphaMap !== null) {\n    previewSurfaceNode.addProperty(`float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.alphaMap.id}_opacity.outputs:r>`);\n    previewSurfaceNode.addProperty('float inputs:opacityThreshold = 0.0001');\n    const textureNodes = buildTextureNodes(material.alphaMap, 'opacity');\n    textureNodes.forEach(node => materialNode.addChild(node));\n  } else {\n    previewSurfaceNode.addProperty(`float inputs:opacity = ${material.opacity}`);\n  }\n  if (material.isMeshPhysicalMaterial) {\n    if (material.clearcoatMap !== null) {\n      previewSurfaceNode.addProperty(`float inputs:clearcoat.connect = </Materials/Material_${material.id}/Texture_${material.clearcoatMap.id}_clearcoat.outputs:r>`);\n      const clearcoatColor = new Color(material.clearcoat, material.clearcoat, material.clearcoat);\n      const textureNodes = buildTextureNodes(material.clearcoatMap, 'clearcoat', clearcoatColor);\n      textureNodes.forEach(node => materialNode.addChild(node));\n    } else {\n      previewSurfaceNode.addProperty(`float inputs:clearcoat = ${material.clearcoat}`);\n    }\n    if (material.clearcoatRoughnessMap !== null) {\n      previewSurfaceNode.addProperty(`float inputs:clearcoatRoughness.connect = </Materials/Material_${material.id}/Texture_${material.clearcoatRoughnessMap.id}_clearcoatRoughness.outputs:g>`);\n      const clearcoatRoughnessColor = new Color(material.clearcoatRoughness, material.clearcoatRoughness, material.clearcoatRoughness);\n      const textureNodes = buildTextureNodes(material.clearcoatRoughnessMap, 'clearcoatRoughness', clearcoatRoughnessColor);\n      textureNodes.forEach(node => materialNode.addChild(node));\n    } else {\n      previewSurfaceNode.addProperty(`float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`);\n    }\n    previewSurfaceNode.addProperty(`float inputs:ior = ${material.ior}`);\n  }\n  previewSurfaceNode.addProperty('int inputs:useSpecularWorkflow = 0');\n  previewSurfaceNode.addProperty('token outputs:surface');\n  materialNode.addChild(previewSurfaceNode);\n  materialNode.addProperty(`token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>`);\n  return materialNode;\n}\nfunction buildColor(color) {\n  return `(${color.r}, ${color.g}, ${color.b})`;\n}\nfunction buildColor4(color) {\n  return `(${color.r}, ${color.g}, ${color.b}, 1.0)`;\n}\nfunction buildVector2(vector) {\n  return `(${vector.x}, ${vector.y})`;\n}\nfunction buildCamera(camera, usedNames) {\n  const name = getName(camera, usedNames);\n  const transform = buildMatrix(camera.matrix);\n  if (camera.matrix.determinant() < 0) {\n    console.warn('THREE.USDZExporter: USDZ does not support negative scales', camera);\n  }\n  const node = new USDNode(name, 'Camera');\n  node.addProperty(`matrix4d xformOp:transform = ${transform}`);\n  node.addProperty('uniform token[] xformOpOrder = [\"xformOp:transform\"]');\n  const projection = camera.isOrthographicCamera ? 'orthographic' : 'perspective';\n  node.addProperty(`token projection = \"${projection}\"`);\n  const clippingRange = `(${camera.near.toPrecision(PRECISION)}, ${camera.far.toPrecision(PRECISION)})`;\n  node.addProperty(`float2 clippingRange = ${clippingRange}`);\n  let horizontalAperture;\n  if (camera.isOrthographicCamera) {\n    horizontalAperture = ((Math.abs(camera.left) + Math.abs(camera.right)) * 10).toPrecision(PRECISION);\n  } else {\n    horizontalAperture = camera.getFilmWidth().toPrecision(PRECISION);\n  }\n  node.addProperty(`float horizontalAperture = ${horizontalAperture}`);\n  let verticalAperture;\n  if (camera.isOrthographicCamera) {\n    verticalAperture = ((Math.abs(camera.top) + Math.abs(camera.bottom)) * 10).toPrecision(PRECISION);\n  } else {\n    verticalAperture = camera.getFilmHeight().toPrecision(PRECISION);\n  }\n  node.addProperty(`float verticalAperture = ${verticalAperture}`);\n  if (camera.isPerspectiveCamera) {\n    const focalLength = camera.getFocalLength().toPrecision(PRECISION);\n    node.addProperty(`float focalLength = ${focalLength}`);\n    const focusDistance = camera.focus.toPrecision(PRECISION);\n    node.addProperty(`float focusDistance = ${focusDistance}`);\n  }\n  return node;\n}\n\n/**\n * Export options of `USDZExporter`.\n *\n * @typedef {Object} USDZExporter~Options\n * @property {number} [maxTextureSize=1024] - The maximum texture size that is going to be exported.\n * @property {boolean} [includeAnchoringProperties=true] - Whether to include anchoring properties or not.\n * @property {boolean} [onlyVisible=true] - Export only visible 3D objects.\n * @property {Object} [ar] - If `includeAnchoringProperties` is set to `true`, the anchoring type and alignment\n * can be configured via `ar.anchoring.type` and `ar.planeAnchoring.alignment`.\n * @property {boolean} [quickLookCompatible=false] - Whether to make the exported USDZ compatible to QuickLook\n * which means the asset is modified to accommodate the bugs FB10036297 and FB11442287 (Apple Feedback).\n **/\n\n/**\n * onDone callback of `USDZExporter`.\n *\n * @callback USDZExporter~OnDone\n * @param {ArrayBuffer} result - The generated USDZ.\n */\n\n/**\n * onError callback of `USDZExporter`.\n *\n * @callback USDZExporter~OnError\n * @param {Error} error - The error object.\n */\n\nexport { USDZExporter };","map":{"version":3,"names":["NoColorSpace","DoubleSide","Color","strToU8","zipSync","USDNode","constructor","name","type","metadata","properties","children","addMetadata","key","value","push","addProperty","property","addChild","child","toString","indent","pad","repeat","formattedMetadata","map","item","Array","isArray","lines","forEach","line","join","meta","length","l","m","c","bodyLines","i","bodyContent","USDZExporter","textureUtils","setTextureUtils","utils","parse","scene","onDone","onError","options","parseAsync","then","catch","Object","assign","ar","anchoring","planeAnchoring","alignment","includeAnchoringProperties","onlyVisible","quickLookCompatible","maxTextureSize","usedNames","Set","files","modelFileName","root","scenesNode","sceneName","sceneNode","output","materials","textures","buildHierarchy","materialsNode","buildMaterials","buildHeader","id","texture","isCompressedTexture","Error","decompress","canvas","imageToCanvas","image","flipY","blob","Promise","resolve","toBlob","Uint8Array","arrayBuffer","offset","filename","file","headerSize","offsetMod64","padLength","padding","extra","level","getName","object","namesSet","replace","test","isCamera","has","add","HTMLImageElement","HTMLCanvasElement","OffscreenCanvas","ImageBitmap","scale","Math","max","width","height","document","createElement","min","context","getContext","translate","drawImage","PRECISION","parentNode","visible","childNode","isMesh","geometry","material","isMeshStandardMaterial","geometryFileName","meshObject","buildMeshObject","uuid","buildMesh","console","warn","buildCamera","buildXform","transform","buildMatrix","matrix","determinant","node","array","elements","buildMatrixRow","meshNode","buildMeshNode","attributes","count","position","buildMeshVertexCount","buildMeshVertexIndices","buildVector3Array","normal","attribute","undefined","buildVector2Array","colorAttribute","color","index","fill","getX","x","y","getY","z","getZ","toPrecision","buildMaterial","materialNode","buildTextureNodes","mapType","source","uv","channel","WRAPPINGS","clone","rotation","xRotationOffset","sin","yRotationOffset","cos","primvarReaderNode","transform2dNode","PI","toFixed","buildVector2","textureNode","buildColor4","colorSpace","wrapS","wrapT","transparent","alphaTest","side","previewSurfaceNode","textureNodes","buildColor","emissiveMap","emissiveColor","emissive","r","emissiveIntensity","g","b","getHex","normalMap","aoMap","aoColor","aoMapIntensity","roughnessMap","roughnessColor","roughness","metalnessMap","metalnessColor","metalness","alphaMap","opacity","isMeshPhysicalMaterial","clearcoatMap","clearcoatColor","clearcoat","clearcoatRoughnessMap","clearcoatRoughnessColor","clearcoatRoughness","ior","vector","camera","projection","isOrthographicCamera","clippingRange","near","far","horizontalAperture","abs","left","right","getFilmWidth","verticalAperture","top","bottom","getFilmHeight","isPerspectiveCamera","focalLength","getFocalLength","focusDistance","focus"],"sources":["C:/Users/LENOVO/Music/OneDrive/Pictures/distribution-agency-project/frontend/node_modules/three/examples/jsm/exporters/USDZExporter.js"],"sourcesContent":["import {\n\tNoColorSpace,\n\tDoubleSide,\n\tColor,\n} from 'three';\n\nimport {\n\tstrToU8,\n\tzipSync,\n} from '../libs/fflate.module.js';\n\nclass USDNode {\n\n\tconstructor( name, type = '', metadata = [], properties = [] ) {\n\n\t\tthis.name = name;\n\t\tthis.type = type;\n\t\tthis.metadata = metadata;\n\t\tthis.properties = properties;\n\t\tthis.children = [];\n\n\t}\n\n\taddMetadata( key, value ) {\n\n\t\tthis.metadata.push( { key, value } );\n\n\t}\n\n\taddProperty( property, metadata = [] ) {\n\n\t\tthis.properties.push( { property, metadata } );\n\n\t}\n\n\taddChild( child ) {\n\n\t\tthis.children.push( child );\n\n\t}\n\n\ttoString( indent = 0 ) {\n\n\t\tconst pad = '\\t'.repeat( indent );\n\n\t\tconst formattedMetadata = this.metadata.map( ( item ) => {\n\n\t\t\tconst key = item.key;\n\t\t\tconst value = item.value;\n\n\t\t\tif ( Array.isArray( value ) ) {\n\n\t\t\t\tconst lines = [];\n\t\t\t\tlines.push( `${key} = {` );\n\t\t\t\tvalue.forEach( ( line ) => {\n\n\t\t\t\t\tlines.push( `${pad}\\t\\t${line}` );\n\n\t\t\t\t} );\n\t\t\t\tlines.push( `${pad}\\t}` );\n\t\t\t\treturn lines.join( '\\n' );\n\n\t\t\t} else {\n\n\t\t\t\treturn `${key} = ${value}`;\n\n\t\t\t}\n\n\t\t} );\n\n\t\tconst meta = formattedMetadata.length\n\t\t\t? ` (\\n${formattedMetadata\n\t\t\t\t.map( ( l ) => `${pad}\\t${l}` )\n\t\t\t\t.join( '\\n' )}\\n${pad})`\n\t\t\t: '';\n\n\t\tconst properties = this.properties.map( ( l ) => {\n\n\t\t\tconst property = l.property;\n\t\t\tconst metadata = l.metadata.length\n\t\t\t\t? ` (\\n${l.metadata.map( ( m ) => `${pad}\\t\\t${m}` ).join( '\\n' )}\\n${pad}\\t)`\n\t\t\t\t: '';\n\t\t\treturn `${pad}\\t${property}${metadata}`;\n\n\t\t} );\n\t\tconst children = this.children.map( ( c ) => c.toString( indent + 1 ) );\n\n\t\tconst bodyLines = [];\n\n\t\tif ( properties.length > 0 ) {\n\n\t\t\tbodyLines.push( ...properties );\n\n\t\t}\n\n\t\tif ( children.length > 0 ) {\n\n\t\t\tif ( properties.length > 0 ) {\n\n\t\t\t\tbodyLines.push( '' );\n\n\t\t\t}\n\n\t\t\tfor ( let i = 0; i < children.length; i ++ ) {\n\n\t\t\t\tbodyLines.push( children[ i ] );\n\t\t\t\tif ( i < children.length - 1 ) {\n\n\t\t\t\t\tbodyLines.push( '' );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst bodyContent = bodyLines.join( '\\n' );\n\n\t\tconst type = this.type ? this.type + ' ' : '';\n\n\t\treturn `${pad}def ${type}\"${this.name}\"${meta}\\n${pad}{\\n${bodyContent}\\n${pad}}`;\n\n\t}\n\n}\n\n/**\n * An exporter for USDZ.\n *\n * ```js\n * const exporter = new USDZExporter();\n * const arraybuffer = await exporter.parseAsync( scene );\n * ```\n *\n * @three_import import { USDZExporter } from 'three/addons/exporters/USDZExporter.js';\n */\nclass USDZExporter {\n\n\t/**\n\t * Constructs a new USDZ exporter.\n\t */\n\tconstructor() {\n\n\t\t/**\n\t\t * A reference to a texture utils module.\n\t\t *\n\t\t * @type {?(WebGLTextureUtils|WebGPUTextureUtils)}\n\t\t * @default null\n\t\t */\n\t\tthis.textureUtils = null;\n\n\t}\n\n\t/**\n\t * Sets the texture utils for this exporter. Only relevant when compressed textures have to be exported.\n\t *\n\t * Depending on whether you use {@link WebGLRenderer} or {@link WebGPURenderer}, you must inject the\n\t * corresponding texture utils {@link WebGLTextureUtils} or {@link WebGPUTextureUtils}.\n\t *\n\t * @param {WebGLTextureUtils|WebGPUTextureUtils} utils - The texture utils.\n\t */\n\tsetTextureUtils( utils ) {\n\n\t\tthis.textureUtils = utils;\n\n\t}\n\n\t/**\n\t * Parse the given 3D object and generates the USDZ output.\n\t *\n\t * @param {Object3D} scene - The 3D object to export.\n\t * @param {USDZExporter~OnDone} onDone - A callback function that is executed when the export has finished.\n\t * @param {USDZExporter~OnError} onError - A callback function that is executed when an error happens.\n\t * @param {USDZExporter~Options} options - The export options.\n\t */\n\tparse( scene, onDone, onError, options ) {\n\n\t\tthis.parseAsync( scene, options ).then( onDone ).catch( onError );\n\n\t}\n\n\t/**\n\t * Async version of {@link USDZExporter#parse}.\n\t *\n\t * @async\n\t * @param {Object3D} scene - The 3D object to export.\n\t * @param {USDZExporter~Options} options - The export options.\n\t * @return {Promise<ArrayBuffer>} A Promise that resolved with the exported USDZ data.\n\t */\n\tasync parseAsync( scene, options = {} ) {\n\n\t\toptions = Object.assign(\n\t\t\t{\n\t\t\t\tar: {\n\t\t\t\t\tanchoring: { type: 'plane' },\n\t\t\t\t\tplaneAnchoring: { alignment: 'horizontal' },\n\t\t\t\t},\n\t\t\t\tincludeAnchoringProperties: true,\n\t\t\t\tonlyVisible: true,\n\t\t\t\tquickLookCompatible: false,\n\t\t\t\tmaxTextureSize: 1024,\n\t\t\t},\n\t\t\toptions\n\t\t);\n\n\t\tconst usedNames = new Set();\n\n\t\tconst files = {};\n\t\tconst modelFileName = 'model.usda';\n\n\t\t// model file should be first in USDZ archive so we init it here\n\t\tfiles[ modelFileName ] = null;\n\n\t\tconst root = new USDNode( 'Root', 'Xform' );\n\t\tconst scenesNode = new USDNode( 'Scenes', 'Scope' );\n\t\tscenesNode.addMetadata( 'kind', '\"sceneLibrary\"' );\n\t\troot.addChild( scenesNode );\n\n\t\tconst sceneName = 'Scene';\n\t\tconst sceneNode = new USDNode( sceneName, 'Xform' );\n\t\tsceneNode.addMetadata( 'customData', [\n\t\t\t'bool preliminary_collidesWithEnvironment = 0',\n\t\t\t`string sceneName = \"${sceneName}\"`,\n\t\t] );\n\t\tsceneNode.addMetadata( 'sceneName', `\"${sceneName}\"` );\n\t\tif ( options.includeAnchoringProperties ) {\n\n\t\t\tsceneNode.addProperty(\n\t\t\t\t`token preliminary:anchoring:type = \"${options.ar.anchoring.type}\"`\n\t\t\t);\n\t\t\tsceneNode.addProperty(\n\t\t\t\t`token preliminary:planeAnchoring:alignment = \"${options.ar.planeAnchoring.alignment}\"`\n\t\t\t);\n\n\t\t}\n\n\t\tscenesNode.addChild( sceneNode );\n\n\t\tlet output;\n\n\t\tconst materials = {};\n\t\tconst textures = {};\n\n\t\tbuildHierarchy( scene, sceneNode, materials, usedNames, files, options );\n\n\t\tconst materialsNode = buildMaterials(\n\t\t\tmaterials,\n\t\t\ttextures,\n\t\t\toptions.quickLookCompatible\n\t\t);\n\n\t\toutput =\n\t\t\tbuildHeader() +\n\t\t\t'\\n' +\n\t\t\troot.toString() +\n\t\t\t'\\n\\n' +\n\t\t\tmaterialsNode.toString();\n\n\t\tfiles[ modelFileName ] = strToU8( output );\n\t\toutput = null;\n\n\t\tfor ( const id in textures ) {\n\n\t\t\tlet texture = textures[ id ];\n\n\t\t\tif ( texture.isCompressedTexture === true ) {\n\n\t\t\t\tif ( this.textureUtils === null ) {\n\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t'THREE.USDZExporter: setTextureUtils() must be called to process compressed textures.'\n\t\t\t\t\t);\n\n\t\t\t\t} else {\n\n\t\t\t\t\ttexture = await this.textureUtils.decompress( texture );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst canvas = imageToCanvas(\n\t\t\t\ttexture.image,\n\t\t\t\ttexture.flipY,\n\t\t\t\toptions.maxTextureSize\n\t\t\t);\n\t\t\tconst blob = await new Promise( ( resolve ) =>\n\t\t\t\tcanvas.toBlob( resolve, 'image/png', 1 )\n\t\t\t);\n\n\t\t\tfiles[ `textures/Texture_${id}.png` ] = new Uint8Array(\n\t\t\t\tawait blob.arrayBuffer()\n\t\t\t);\n\n\t\t}\n\n\t\t// 64 byte alignment\n\t\t// https://github.com/101arrowz/fflate/issues/39#issuecomment-777263109\n\n\t\tlet offset = 0;\n\n\t\tfor ( const filename in files ) {\n\n\t\t\tconst file = files[ filename ];\n\t\t\tconst headerSize = 34 + filename.length;\n\n\t\t\toffset += headerSize;\n\n\t\t\tconst offsetMod64 = offset & 63;\n\n\t\t\tif ( offsetMod64 !== 4 ) {\n\n\t\t\t\tconst padLength = 64 - offsetMod64;\n\t\t\t\tconst padding = new Uint8Array( padLength );\n\n\t\t\t\tfiles[ filename ] = [ file, { extra: { 12345: padding } } ];\n\n\t\t\t}\n\n\t\t\toffset = file.length;\n\n\t\t}\n\n\t\treturn zipSync( files, { level: 0 } );\n\n\t}\n\n}\n\nfunction getName( object, namesSet ) {\n\n\tlet name = object.name;\n\tname = name.replace( /[^A-Za-z0-9_]/g, '' );\n\tif ( /^[0-9]/.test( name ) ) {\n\n\t\tname = '_' + name;\n\n\t}\n\n\tif ( name === '' ) {\n\n\t\tif ( object.isCamera ) {\n\n\t\t\tname = 'Camera';\n\n\t\t} else {\n\n\t\t\tname = 'Object';\n\n\t\t}\n\n\t}\n\n\tif ( namesSet.has( name ) ) {\n\n\t\tname = name + '_' + object.id;\n\n\t}\n\n\tnamesSet.add( name );\n\n\treturn name;\n\n}\n\nfunction imageToCanvas( image, flipY, maxTextureSize ) {\n\n\tif (\n\t\t( typeof HTMLImageElement !== 'undefined' &&\n\t\t\timage instanceof HTMLImageElement ) ||\n\t\t( typeof HTMLCanvasElement !== 'undefined' &&\n\t\t\timage instanceof HTMLCanvasElement ) ||\n\t\t( typeof OffscreenCanvas !== 'undefined' &&\n\t\t\timage instanceof OffscreenCanvas ) ||\n\t\t( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap )\n\t) {\n\n\t\tconst scale = maxTextureSize / Math.max( image.width, image.height );\n\n\t\tconst canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = image.width * Math.min( 1, scale );\n\t\tcanvas.height = image.height * Math.min( 1, scale );\n\n\t\tconst context = canvas.getContext( '2d' );\n\n\t\t// TODO: We should be able to do this in the UsdTransform2d?\n\n\t\tif ( flipY === true ) {\n\n\t\t\tcontext.translate( 0, canvas.height );\n\t\t\tcontext.scale( 1, - 1 );\n\n\t\t}\n\n\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\n\n\t\treturn canvas;\n\n\t} else {\n\n\t\tthrow new Error(\n\t\t\t'THREE.USDZExporter: No valid image data found. Unable to process texture.'\n\t\t);\n\n\t}\n\n}\n\n//\n\nconst PRECISION = 7;\n\nfunction buildHeader() {\n\n\treturn `#usda 1.0\n(\n\tcustomLayerData = {\n\t\tstring creator = \"Three.js USDZExporter\"\n\t}\n\tdefaultPrim = \"Root\"\n\tmetersPerUnit = 1\n\tupAxis = \"Y\"\n)\n`;\n\n}\n\n// Xform\n\nfunction buildHierarchy( object, parentNode, materials, usedNames, files, options ) {\n\n\tfor ( let i = 0, l = object.children.length; i < l; i ++ ) {\n\n\t\tconst child = object.children[ i ];\n\n\t\tif ( child.visible === false && options.onlyVisible === true ) continue;\n\n\t\tlet childNode;\n\n\t\tif ( child.isMesh ) {\n\n\t\t\tconst geometry = child.geometry;\n\t\t\tconst material = child.material;\n\n\t\t\tif ( material.isMeshStandardMaterial ) {\n\n\t\t\t\tconst geometryFileName = 'geometries/Geometry_' + geometry.id + '.usda';\n\n\t\t\t\tif ( ! ( geometryFileName in files ) ) {\n\n\t\t\t\t\tconst meshObject = buildMeshObject( geometry );\n\t\t\t\t\tfiles[ geometryFileName ] = strToU8(\n\t\t\t\t\t\tbuildHeader() + '\\n' + meshObject.toString()\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t\tif ( ! ( material.uuid in materials ) ) {\n\n\t\t\t\t\tmaterials[ material.uuid ] = material;\n\n\t\t\t\t}\n\n\t\t\t\tchildNode = buildMesh(\n\t\t\t\t\tchild,\n\t\t\t\t\tgeometry,\n\t\t\t\t\tmaterials[ material.uuid ],\n\t\t\t\t\tusedNames\n\t\t\t\t);\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'THREE.USDZExporter: Unsupported material type (USDZ only supports MeshStandardMaterial)',\n\t\t\t\t\tchild\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t} else if ( child.isCamera ) {\n\n\t\t\tchildNode = buildCamera( child, usedNames );\n\n\t\t} else {\n\n\t\t\tchildNode = buildXform( child, usedNames );\n\n\t\t}\n\n\t\tif ( childNode ) {\n\n\t\t\tparentNode.addChild( childNode );\n\t\t\tbuildHierarchy( child, childNode, materials, usedNames, files, options );\n\n\t\t}\n\n\t}\n\n}\n\nfunction buildXform( object, usedNames ) {\n\n\tconst name = getName( object, usedNames );\n\tconst transform = buildMatrix( object.matrix );\n\n\tif ( object.matrix.determinant() < 0 ) {\n\n\t\tconsole.warn(\n\t\t\t'THREE.USDZExporter: USDZ does not support negative scales',\n\t\t\tobject\n\t\t);\n\n\t}\n\n\tconst node = new USDNode( name, 'Xform' );\n\n\tnode.addProperty( `matrix4d xformOp:transform = ${transform}` );\n\tnode.addProperty( 'uniform token[] xformOpOrder = [\"xformOp:transform\"]' );\n\n\treturn node;\n\n}\n\nfunction buildMesh( object, geometry, material, usedNames ) {\n\n\tconst node = buildXform( object, usedNames );\n\n\tnode.addMetadata(\n\t\t'prepend references',\n\t\t`@./geometries/Geometry_${geometry.id}.usda@</Geometry>`\n\t);\n\tnode.addMetadata( 'prepend apiSchemas', '[\"MaterialBindingAPI\"]' );\n\n\tnode.addProperty(\n\t\t`rel material:binding = </Materials/Material_${material.id}>`\n\t);\n\n\treturn node;\n\n}\n\nfunction buildMatrix( matrix ) {\n\n\tconst array = matrix.elements;\n\n\treturn `( ${buildMatrixRow( array, 0 )}, ${buildMatrixRow(\n\t\tarray,\n\t\t4\n\t)}, ${buildMatrixRow( array, 8 )}, ${buildMatrixRow( array, 12 )} )`;\n\n}\n\nfunction buildMatrixRow( array, offset ) {\n\n\treturn `(${array[ offset + 0 ]}, ${array[ offset + 1 ]}, ${array[ offset + 2 ]}, ${\n\t\tarray[ offset + 3 ]\n\t})`;\n\n}\n\n// Mesh\n\nfunction buildMeshObject( geometry ) {\n\n\tconst node = new USDNode( 'Geometry' );\n\n\tconst meshNode = buildMeshNode( geometry );\n\tnode.addChild( meshNode );\n\n\treturn node;\n\n}\n\nfunction buildMeshNode( geometry ) {\n\n\tconst name = 'Geometry';\n\tconst attributes = geometry.attributes;\n\tconst count = attributes.position.count;\n\n\tconst node = new USDNode( name, 'Mesh' );\n\n\tnode.addProperty(\n\t\t`int[] faceVertexCounts = [${buildMeshVertexCount( geometry )}]`\n\t);\n\tnode.addProperty(\n\t\t`int[] faceVertexIndices = [${buildMeshVertexIndices( geometry )}]`\n\t);\n\tnode.addProperty(\n\t\t`normal3f[] normals = [${buildVector3Array( attributes.normal, count )}]`,\n\t\t[ 'interpolation = \"vertex\"' ]\n\t);\n\tnode.addProperty(\n\t\t`point3f[] points = [${buildVector3Array( attributes.position, count )}]`\n\t);\n\n\tfor ( let i = 0; i < 4; i ++ ) {\n\n\t\tconst id = i > 0 ? i : '';\n\t\tconst attribute = attributes[ 'uv' + id ];\n\t\tif ( attribute !== undefined ) {\n\n\t\t\tnode.addProperty(\n\t\t\t\t`texCoord2f[] primvars:st${id} = [${buildVector2Array( attribute )}]`,\n\t\t\t\t[ 'interpolation = \"vertex\"' ]\n\t\t\t);\n\n\t\t}\n\n\t}\n\n\tconst colorAttribute = attributes.color;\n\tif ( colorAttribute !== undefined ) {\n\n\t\tnode.addProperty(\n\t\t\t`color3f[] primvars:displayColor = [${buildVector3Array(\n\t\t\t\tcolorAttribute,\n\t\t\t\tcount\n\t\t\t)}]`,\n\t\t\t[ 'interpolation = \"vertex\"' ]\n\t\t);\n\n\t}\n\n\tnode.addProperty( 'uniform token subdivisionScheme = \"none\"' );\n\n\treturn node;\n\n}\n\nfunction buildMeshVertexCount( geometry ) {\n\n\tconst count =\n\t\tgeometry.index !== null\n\t\t\t? geometry.index.count\n\t\t\t: geometry.attributes.position.count;\n\n\treturn Array( count / 3 )\n\t\t.fill( 3 )\n\t\t.join( ', ' );\n\n}\n\nfunction buildMeshVertexIndices( geometry ) {\n\n\tconst index = geometry.index;\n\tconst array = [];\n\n\tif ( index !== null ) {\n\n\t\tfor ( let i = 0; i < index.count; i ++ ) {\n\n\t\t\tarray.push( index.getX( i ) );\n\n\t\t}\n\n\t} else {\n\n\t\tconst length = geometry.attributes.position.count;\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tarray.push( i );\n\n\t\t}\n\n\t}\n\n\treturn array.join( ', ' );\n\n}\n\nfunction buildVector3Array( attribute, count ) {\n\n\tif ( attribute === undefined ) {\n\n\t\tconsole.warn( 'USDZExporter: Normals missing.' );\n\t\treturn Array( count ).fill( '(0, 0, 0)' ).join( ', ' );\n\n\t}\n\n\tconst array = [];\n\n\tfor ( let i = 0; i < attribute.count; i ++ ) {\n\n\t\tconst x = attribute.getX( i );\n\t\tconst y = attribute.getY( i );\n\t\tconst z = attribute.getZ( i );\n\n\t\tarray.push(\n\t\t\t`(${x.toPrecision( PRECISION )}, ${y.toPrecision(\n\t\t\t\tPRECISION\n\t\t\t)}, ${z.toPrecision( PRECISION )})`\n\t\t);\n\n\t}\n\n\treturn array.join( ', ' );\n\n}\n\nfunction buildVector2Array( attribute ) {\n\n\tconst array = [];\n\n\tfor ( let i = 0; i < attribute.count; i ++ ) {\n\n\t\tconst x = attribute.getX( i );\n\t\tconst y = attribute.getY( i );\n\n\t\tarray.push(\n\t\t\t`(${x.toPrecision( PRECISION )}, ${1 - y.toPrecision( PRECISION )})`\n\t\t);\n\n\t}\n\n\treturn array.join( ', ' );\n\n}\n\n// Materials\n\nfunction buildMaterials( materials, textures, quickLookCompatible = false ) {\n\n\tconst materialsNode = new USDNode( 'Materials' );\n\n\tfor ( const uuid in materials ) {\n\n\t\tconst material = materials[ uuid ];\n\n\t\tmaterialsNode.addChild(\n\t\t\tbuildMaterial( material, textures, quickLookCompatible )\n\t\t);\n\n\t}\n\n\treturn materialsNode;\n\n}\n\nfunction buildMaterial( material, textures, quickLookCompatible = false ) {\n\n\t// https://graphics.pixar.com/usd/docs/UsdPreviewSurface-Proposal.html\n\n\tconst materialNode = new USDNode( `Material_${material.id}`, 'Material' );\n\n\tfunction buildTextureNodes( texture, mapType, color ) {\n\n\t\tconst id = texture.source.id + '_' + texture.flipY;\n\n\t\ttextures[ id ] = texture;\n\n\t\tconst uv = texture.channel > 0 ? 'st' + texture.channel : 'st';\n\n\t\tconst WRAPPINGS = {\n\t\t\t1000: 'repeat', // RepeatWrapping\n\t\t\t1001: 'clamp', // ClampToEdgeWrapping\n\t\t\t1002: 'mirror', // MirroredRepeatWrapping\n\t\t};\n\n\t\tconst repeat = texture.repeat.clone();\n\t\tconst offset = texture.offset.clone();\n\t\tconst rotation = texture.rotation;\n\n\t\t// rotation is around the wrong point. after rotation we need to shift offset again so that we're rotating around the right spot\n\t\tconst xRotationOffset = Math.sin( rotation );\n\t\tconst yRotationOffset = Math.cos( rotation );\n\n\t\t// texture coordinates start in the opposite corner, need to correct\n\t\toffset.y = 1 - offset.y - repeat.y;\n\n\t\t// turns out QuickLook is buggy and interprets texture repeat inverted/applies operations in a different order.\n\t\t// Apple Feedback: \tFB10036297 and FB11442287\n\t\tif ( quickLookCompatible ) {\n\n\t\t\t// This is NOT correct yet in QuickLook, but comes close for a range of models.\n\t\t\t// It becomes more incorrect the bigger the offset is\n\n\t\t\toffset.x = offset.x / repeat.x;\n\t\t\toffset.y = offset.y / repeat.y;\n\n\t\t\toffset.x += xRotationOffset / repeat.x;\n\t\t\toffset.y += yRotationOffset - 1;\n\n\t\t} else {\n\n\t\t\t// results match glTF results exactly. verified correct in usdview.\n\t\t\toffset.x += xRotationOffset * repeat.x;\n\t\t\toffset.y += ( 1 - yRotationOffset ) * repeat.y;\n\n\t\t}\n\n\t\tconst primvarReaderNode = new USDNode( `PrimvarReader_${mapType}`, 'Shader' );\n\t\tprimvarReaderNode.addProperty(\n\t\t\t'uniform token info:id = \"UsdPrimvarReader_float2\"'\n\t\t);\n\t\tprimvarReaderNode.addProperty( 'float2 inputs:fallback = (0.0, 0.0)' );\n\t\tprimvarReaderNode.addProperty( `string inputs:varname = \"${uv}\"` );\n\t\tprimvarReaderNode.addProperty( 'float2 outputs:result' );\n\n\t\tconst transform2dNode = new USDNode( `Transform2d_${mapType}`, 'Shader' );\n\t\ttransform2dNode.addProperty( 'uniform token info:id = \"UsdTransform2d\"' );\n\t\ttransform2dNode.addProperty(\n\t\t\t`float2 inputs:in.connect = </Materials/Material_${material.id}/PrimvarReader_${mapType}.outputs:result>`\n\t\t);\n\t\ttransform2dNode.addProperty(\n\t\t\t`float inputs:rotation = ${( rotation * ( 180 / Math.PI ) ).toFixed(\n\t\t\t\tPRECISION\n\t\t\t)}`\n\t\t);\n\t\ttransform2dNode.addProperty(\n\t\t\t`float2 inputs:scale = ${buildVector2( repeat )}`\n\t\t);\n\t\ttransform2dNode.addProperty(\n\t\t\t`float2 inputs:translation = ${buildVector2( offset )}`\n\t\t);\n\t\ttransform2dNode.addProperty( 'float2 outputs:result' );\n\n\t\tconst textureNode = new USDNode(\n\t\t\t`Texture_${texture.id}_${mapType}`,\n\t\t\t'Shader'\n\t\t);\n\t\ttextureNode.addProperty( 'uniform token info:id = \"UsdUVTexture\"' );\n\t\ttextureNode.addProperty( `asset inputs:file = @textures/Texture_${id}.png@` );\n\t\ttextureNode.addProperty(\n\t\t\t`float2 inputs:st.connect = </Materials/Material_${material.id}/Transform2d_${mapType}.outputs:result>`\n\t\t);\n\n\t\tif ( color !== undefined ) {\n\n\t\t\ttextureNode.addProperty( `float4 inputs:scale = ${buildColor4( color )}` );\n\n\t\t}\n\n\t\tif ( mapType === 'normal' ) {\n\n\t\t\ttextureNode.addProperty( 'float4 inputs:scale = (2, 2, 2, 1)' );\n\t\t\ttextureNode.addProperty( 'float4 inputs:bias = (-1, -1, -1, 0)' );\n\n\t\t}\n\n\t\ttextureNode.addProperty(\n\t\t\t`token inputs:sourceColorSpace = \"${\n\t\t\t\ttexture.colorSpace === NoColorSpace ? 'raw' : 'sRGB'\n\t\t\t}\"`\n\t\t);\n\t\ttextureNode.addProperty(\n\t\t\t`token inputs:wrapS = \"${WRAPPINGS[ texture.wrapS ]}\"`\n\t\t);\n\t\ttextureNode.addProperty(\n\t\t\t`token inputs:wrapT = \"${WRAPPINGS[ texture.wrapT ]}\"`\n\t\t);\n\t\ttextureNode.addProperty( 'float outputs:r' );\n\t\ttextureNode.addProperty( 'float outputs:g' );\n\t\ttextureNode.addProperty( 'float outputs:b' );\n\t\ttextureNode.addProperty( 'float3 outputs:rgb' );\n\n\t\tif ( material.transparent || material.alphaTest > 0.0 ) {\n\n\t\t\ttextureNode.addProperty( 'float outputs:a' );\n\n\t\t}\n\n\t\treturn [ primvarReaderNode, transform2dNode, textureNode ];\n\n\t}\n\n\tif ( material.side === DoubleSide ) {\n\n\t\tconsole.warn(\n\t\t\t'THREE.USDZExporter: USDZ does not support double sided materials',\n\t\t\tmaterial\n\t\t);\n\n\t}\n\n\tconst previewSurfaceNode = new USDNode( 'PreviewSurface', 'Shader' );\n\tpreviewSurfaceNode.addProperty( 'uniform token info:id = \"UsdPreviewSurface\"' );\n\n\tif ( material.map !== null ) {\n\n\t\tpreviewSurfaceNode.addProperty(\n\t\t\t`color3f inputs:diffuseColor.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:rgb>`\n\t\t);\n\n\t\tif ( material.transparent ) {\n\n\t\t\tpreviewSurfaceNode.addProperty(\n\t\t\t\t`float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:a>`\n\t\t\t);\n\n\t\t} else if ( material.alphaTest > 0.0 ) {\n\n\t\t\tpreviewSurfaceNode.addProperty(\n\t\t\t\t`float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.map.id}_diffuse.outputs:a>`\n\t\t\t);\n\t\t\tpreviewSurfaceNode.addProperty(\n\t\t\t\t`float inputs:opacityThreshold = ${material.alphaTest}`\n\t\t\t);\n\n\t\t}\n\n\t\tconst textureNodes = buildTextureNodes(\n\t\t\tmaterial.map,\n\t\t\t'diffuse',\n\t\t\tmaterial.color\n\t\t);\n\t\ttextureNodes.forEach( ( node ) => materialNode.addChild( node ) );\n\n\t} else {\n\n\t\tpreviewSurfaceNode.addProperty(\n\t\t\t`color3f inputs:diffuseColor = ${buildColor( material.color )}`\n\t\t);\n\n\t}\n\n\tif ( material.emissiveMap !== null ) {\n\n\t\tpreviewSurfaceNode.addProperty(\n\t\t\t`color3f inputs:emissiveColor.connect = </Materials/Material_${material.id}/Texture_${material.emissiveMap.id}_emissive.outputs:rgb>`\n\t\t);\n\n\t\tconst emissiveColor = new Color(\n\t\t\tmaterial.emissive.r * material.emissiveIntensity,\n\t\t\tmaterial.emissive.g * material.emissiveIntensity,\n\t\t\tmaterial.emissive.b * material.emissiveIntensity\n\t\t);\n\t\tconst textureNodes = buildTextureNodes(\n\t\t\tmaterial.emissiveMap,\n\t\t\t'emissive',\n\t\t\temissiveColor\n\t\t);\n\t\ttextureNodes.forEach( ( node ) => materialNode.addChild( node ) );\n\n\t} else if ( material.emissive.getHex() > 0 ) {\n\n\t\tpreviewSurfaceNode.addProperty(\n\t\t\t`color3f inputs:emissiveColor = ${buildColor( material.emissive )}`\n\t\t);\n\n\t}\n\n\tif ( material.normalMap !== null ) {\n\n\t\tpreviewSurfaceNode.addProperty(\n\t\t\t`normal3f inputs:normal.connect = </Materials/Material_${material.id}/Texture_${material.normalMap.id}_normal.outputs:rgb>`\n\t\t);\n\n\t\tconst textureNodes = buildTextureNodes( material.normalMap, 'normal' );\n\t\ttextureNodes.forEach( ( node ) => materialNode.addChild( node ) );\n\n\t}\n\n\tif ( material.aoMap !== null ) {\n\n\t\tpreviewSurfaceNode.addProperty(\n\t\t\t`float inputs:occlusion.connect = </Materials/Material_${material.id}/Texture_${material.aoMap.id}_occlusion.outputs:r>`\n\t\t);\n\n\t\tconst aoColor = new Color(\n\t\t\tmaterial.aoMapIntensity,\n\t\t\tmaterial.aoMapIntensity,\n\t\t\tmaterial.aoMapIntensity\n\t\t);\n\t\tconst textureNodes = buildTextureNodes(\n\t\t\tmaterial.aoMap,\n\t\t\t'occlusion',\n\t\t\taoColor\n\t\t);\n\t\ttextureNodes.forEach( ( node ) => materialNode.addChild( node ) );\n\n\t}\n\n\tif ( material.roughnessMap !== null ) {\n\n\t\tpreviewSurfaceNode.addProperty(\n\t\t\t`float inputs:roughness.connect = </Materials/Material_${material.id}/Texture_${material.roughnessMap.id}_roughness.outputs:g>`\n\t\t);\n\n\t\tconst roughnessColor = new Color(\n\t\t\tmaterial.roughness,\n\t\t\tmaterial.roughness,\n\t\t\tmaterial.roughness\n\t\t);\n\t\tconst textureNodes = buildTextureNodes(\n\t\t\tmaterial.roughnessMap,\n\t\t\t'roughness',\n\t\t\troughnessColor\n\t\t);\n\t\ttextureNodes.forEach( ( node ) => materialNode.addChild( node ) );\n\n\t} else {\n\n\t\tpreviewSurfaceNode.addProperty(\n\t\t\t`float inputs:roughness = ${material.roughness}`\n\t\t);\n\n\t}\n\n\tif ( material.metalnessMap !== null ) {\n\n\t\tpreviewSurfaceNode.addProperty(\n\t\t\t`float inputs:metallic.connect = </Materials/Material_${material.id}/Texture_${material.metalnessMap.id}_metallic.outputs:b>`\n\t\t);\n\n\t\tconst metalnessColor = new Color(\n\t\t\tmaterial.metalness,\n\t\t\tmaterial.metalness,\n\t\t\tmaterial.metalness\n\t\t);\n\t\tconst textureNodes = buildTextureNodes(\n\t\t\tmaterial.metalnessMap,\n\t\t\t'metallic',\n\t\t\tmetalnessColor\n\t\t);\n\t\ttextureNodes.forEach( ( node ) => materialNode.addChild( node ) );\n\n\t} else {\n\n\t\tpreviewSurfaceNode.addProperty(\n\t\t\t`float inputs:metallic = ${material.metalness}`\n\t\t);\n\n\t}\n\n\tif ( material.alphaMap !== null ) {\n\n\t\tpreviewSurfaceNode.addProperty(\n\t\t\t`float inputs:opacity.connect = </Materials/Material_${material.id}/Texture_${material.alphaMap.id}_opacity.outputs:r>`\n\t\t);\n\t\tpreviewSurfaceNode.addProperty( 'float inputs:opacityThreshold = 0.0001' );\n\n\t\tconst textureNodes = buildTextureNodes( material.alphaMap, 'opacity' );\n\t\ttextureNodes.forEach( ( node ) => materialNode.addChild( node ) );\n\n\t} else {\n\n\t\tpreviewSurfaceNode.addProperty(\n\t\t\t`float inputs:opacity = ${material.opacity}`\n\t\t);\n\n\t}\n\n\tif ( material.isMeshPhysicalMaterial ) {\n\n\t\tif ( material.clearcoatMap !== null ) {\n\n\t\t\tpreviewSurfaceNode.addProperty(\n\t\t\t\t`float inputs:clearcoat.connect = </Materials/Material_${material.id}/Texture_${material.clearcoatMap.id}_clearcoat.outputs:r>`\n\t\t\t);\n\n\t\t\tconst clearcoatColor = new Color(\n\t\t\t\tmaterial.clearcoat,\n\t\t\t\tmaterial.clearcoat,\n\t\t\t\tmaterial.clearcoat\n\t\t\t);\n\t\t\tconst textureNodes = buildTextureNodes(\n\t\t\t\tmaterial.clearcoatMap,\n\t\t\t\t'clearcoat',\n\t\t\t\tclearcoatColor\n\t\t\t);\n\t\t\ttextureNodes.forEach( ( node ) => materialNode.addChild( node ) );\n\n\t\t} else {\n\n\t\t\tpreviewSurfaceNode.addProperty(\n\t\t\t\t`float inputs:clearcoat = ${material.clearcoat}`\n\t\t\t);\n\n\t\t}\n\n\t\tif ( material.clearcoatRoughnessMap !== null ) {\n\n\t\t\tpreviewSurfaceNode.addProperty(\n\t\t\t\t`float inputs:clearcoatRoughness.connect = </Materials/Material_${material.id}/Texture_${material.clearcoatRoughnessMap.id}_clearcoatRoughness.outputs:g>`\n\t\t\t);\n\n\t\t\tconst clearcoatRoughnessColor = new Color(\n\t\t\t\tmaterial.clearcoatRoughness,\n\t\t\t\tmaterial.clearcoatRoughness,\n\t\t\t\tmaterial.clearcoatRoughness\n\t\t\t);\n\t\t\tconst textureNodes = buildTextureNodes(\n\t\t\t\tmaterial.clearcoatRoughnessMap,\n\t\t\t\t'clearcoatRoughness',\n\t\t\t\tclearcoatRoughnessColor\n\t\t\t);\n\t\t\ttextureNodes.forEach( ( node ) => materialNode.addChild( node ) );\n\n\t\t} else {\n\n\t\t\tpreviewSurfaceNode.addProperty(\n\t\t\t\t`float inputs:clearcoatRoughness = ${material.clearcoatRoughness}`\n\t\t\t);\n\n\t\t}\n\n\t\tpreviewSurfaceNode.addProperty( `float inputs:ior = ${material.ior}` );\n\n\t}\n\n\tpreviewSurfaceNode.addProperty( 'int inputs:useSpecularWorkflow = 0' );\n\tpreviewSurfaceNode.addProperty( 'token outputs:surface' );\n\n\tmaterialNode.addChild( previewSurfaceNode );\n\n\tmaterialNode.addProperty(\n\t\t`token outputs:surface.connect = </Materials/Material_${material.id}/PreviewSurface.outputs:surface>`\n\t);\n\n\treturn materialNode;\n\n}\n\nfunction buildColor( color ) {\n\n\treturn `(${color.r}, ${color.g}, ${color.b})`;\n\n}\n\nfunction buildColor4( color ) {\n\n\treturn `(${color.r}, ${color.g}, ${color.b}, 1.0)`;\n\n}\n\nfunction buildVector2( vector ) {\n\n\treturn `(${vector.x}, ${vector.y})`;\n\n}\n\nfunction buildCamera( camera, usedNames ) {\n\n\tconst name = getName( camera, usedNames );\n\n\tconst transform = buildMatrix( camera.matrix );\n\n\tif ( camera.matrix.determinant() < 0 ) {\n\n\t\tconsole.warn(\n\t\t\t'THREE.USDZExporter: USDZ does not support negative scales',\n\t\t\tcamera\n\t\t);\n\n\t}\n\n\tconst node = new USDNode( name, 'Camera' );\n\tnode.addProperty( `matrix4d xformOp:transform = ${transform}` );\n\tnode.addProperty( 'uniform token[] xformOpOrder = [\"xformOp:transform\"]' );\n\n\tconst projection = camera.isOrthographicCamera\n\t\t? 'orthographic'\n\t\t: 'perspective';\n\tnode.addProperty( `token projection = \"${projection}\"` );\n\n\tconst clippingRange = `(${camera.near.toPrecision(\n\t\tPRECISION\n\t)}, ${camera.far.toPrecision( PRECISION )})`;\n\tnode.addProperty( `float2 clippingRange = ${clippingRange}` );\n\n\tlet horizontalAperture;\n\tif ( camera.isOrthographicCamera ) {\n\n\t\thorizontalAperture = (\n\t\t\t( Math.abs( camera.left ) + Math.abs( camera.right ) ) *\n\t\t\t10\n\t\t).toPrecision( PRECISION );\n\n\t} else {\n\n\t\thorizontalAperture = camera.getFilmWidth().toPrecision( PRECISION );\n\n\t}\n\n\tnode.addProperty( `float horizontalAperture = ${horizontalAperture}` );\n\n\tlet verticalAperture;\n\tif ( camera.isOrthographicCamera ) {\n\n\t\tverticalAperture = (\n\t\t\t( Math.abs( camera.top ) + Math.abs( camera.bottom ) ) *\n\t\t\t10\n\t\t).toPrecision( PRECISION );\n\n\t} else {\n\n\t\tverticalAperture = camera.getFilmHeight().toPrecision( PRECISION );\n\n\t}\n\n\tnode.addProperty( `float verticalAperture = ${verticalAperture}` );\n\n\tif ( camera.isPerspectiveCamera ) {\n\n\t\tconst focalLength = camera.getFocalLength().toPrecision( PRECISION );\n\t\tnode.addProperty( `float focalLength = ${focalLength}` );\n\n\t\tconst focusDistance = camera.focus.toPrecision( PRECISION );\n\t\tnode.addProperty( `float focusDistance = ${focusDistance}` );\n\n\t}\n\n\treturn node;\n\n}\n\n/**\n * Export options of `USDZExporter`.\n *\n * @typedef {Object} USDZExporter~Options\n * @property {number} [maxTextureSize=1024] - The maximum texture size that is going to be exported.\n * @property {boolean} [includeAnchoringProperties=true] - Whether to include anchoring properties or not.\n * @property {boolean} [onlyVisible=true] - Export only visible 3D objects.\n * @property {Object} [ar] - If `includeAnchoringProperties` is set to `true`, the anchoring type and alignment\n * can be configured via `ar.anchoring.type` and `ar.planeAnchoring.alignment`.\n * @property {boolean} [quickLookCompatible=false] - Whether to make the exported USDZ compatible to QuickLook\n * which means the asset is modified to accommodate the bugs FB10036297 and FB11442287 (Apple Feedback).\n **/\n\n/**\n * onDone callback of `USDZExporter`.\n *\n * @callback USDZExporter~OnDone\n * @param {ArrayBuffer} result - The generated USDZ.\n */\n\n/**\n * onError callback of `USDZExporter`.\n *\n * @callback USDZExporter~OnError\n * @param {Error} error - The error object.\n */\n\nexport { USDZExporter };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}