{"ast":null,"code":"/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { FrontSide, Sphere } from 'three';\nimport { $clone, $prepare, $preparedGLTF, GLTFInstance } from '../GLTFInstance.js';\nimport { CorrelatedSceneGraph } from './correlated-scene-graph.js';\nconst $correlatedSceneGraph = Symbol('correlatedSceneGraph');\n/**\n * This specialization of GLTFInstance collects all of the processing needed\n * to prepare a model and to clone it making special considerations for\n * <model-viewer> use cases.\n */\nexport class ModelViewerGLTFInstance extends GLTFInstance {\n  /**\n   * @override\n   */\n  static [$prepare](source) {\n    const prepared = super[$prepare](source);\n    if (prepared[$correlatedSceneGraph] == null) {\n      prepared[$correlatedSceneGraph] = CorrelatedSceneGraph.from(prepared);\n    }\n    const {\n      scene\n    } = prepared;\n    const nullSphere = new Sphere(undefined, Infinity);\n    scene.traverse(node => {\n      // Set a high renderOrder while we're here to ensure the model\n      // always renders on top of the sky sphere\n      node.renderOrder = 1000;\n      // Three.js seems to cull some animated models incorrectly. Since we\n      // expect to view our whole scene anyway, we turn off the frustum\n      // culling optimization here.\n      node.frustumCulled = false;\n      // Animations for objects without names target their UUID instead. When\n      // objects are cloned, they get new UUIDs which the animation can't\n      // find. To fix this, we assign their UUID as their name.\n      if (!node.name) {\n        node.name = node.uuid;\n      }\n      const mesh = node;\n      if (mesh.material) {\n        const {\n          geometry\n        } = mesh;\n        mesh.castShadow = true;\n        if (mesh.isSkinnedMesh) {\n          // Akin to disabling frustum culling above, we have to also manually\n          // disable the bounds to make raycasting correct for skinned meshes.\n          geometry.boundingSphere = nullSphere;\n          // The bounding box is set in GLTFLoader by the accessor bounds, which\n          // are not updated with animation.\n          geometry.boundingBox = null;\n        }\n        const material = mesh.material;\n        if (material.isMeshBasicMaterial === true) {\n          material.toneMapped = false;\n        }\n        // This makes shadows better for non-manifold meshes\n        material.shadowSide = FrontSide;\n        // Fixes an edge case with unused extra UV-coords being incorrectly\n        // referenced by three.js; remove when\n        // https://github.com/mrdoob/three.js/pull/23974 is merged.\n        if (material.aoMap) {\n          const {\n            gltf,\n            threeObjectMap\n          } = prepared[$correlatedSceneGraph];\n          const gltfRef = threeObjectMap.get(material);\n          if (gltf.materials != null && gltfRef != null && gltfRef.materials != null) {\n            const gltfMaterial = gltf.materials[gltfRef.materials];\n            if (gltfMaterial.occlusionTexture && gltfMaterial.occlusionTexture.texCoord === 0 && geometry.attributes.uv != null) {\n              geometry.setAttribute('uv2', geometry.attributes.uv);\n            }\n          }\n        }\n      }\n    });\n    return prepared;\n  }\n  get correlatedSceneGraph() {\n    return this[$preparedGLTF][$correlatedSceneGraph];\n  }\n  /**\n   * @override\n   */\n  [$clone]() {\n    const clone = super[$clone]();\n    const sourceUUIDToClonedMaterial = new Map();\n    clone.scene.traverse(node => {\n      // Materials aren't cloned when cloning meshes; geometry\n      // and materials are copied by reference. This is necessary\n      // for the same model to be used twice with different\n      // scene-graph operations.\n      const mesh = node;\n      if (mesh.material) {\n        const material = mesh.material;\n        if (material != null) {\n          if (sourceUUIDToClonedMaterial.has(material.uuid)) {\n            mesh.material = sourceUUIDToClonedMaterial.get(material.uuid);\n            return;\n          }\n          mesh.material = material.clone();\n          sourceUUIDToClonedMaterial.set(material.uuid, mesh.material);\n        }\n      }\n      const light = node;\n      if (light.target !== undefined) {\n        // The target's parent is lost in the cloning process, but in\n        // GLTFLoader, all light targets are children of their light.\n        light.add(light.target);\n      }\n    });\n    // Cross-correlate the scene graph by relying on information in the\n    // current scene graph; without this step, relationships between the\n    // Three.js object graph and the glTF scene graph will be lost.\n    clone[$correlatedSceneGraph] = CorrelatedSceneGraph.from(clone, this.correlatedSceneGraph);\n    return clone;\n  }\n}","map":{"version":3,"names":["FrontSide","Sphere","$clone","$prepare","$preparedGLTF","GLTFInstance","CorrelatedSceneGraph","$correlatedSceneGraph","Symbol","ModelViewerGLTFInstance","source","prepared","from","scene","nullSphere","undefined","Infinity","traverse","node","renderOrder","frustumCulled","name","uuid","mesh","material","geometry","castShadow","isSkinnedMesh","boundingSphere","boundingBox","isMeshBasicMaterial","toneMapped","shadowSide","aoMap","gltf","threeObjectMap","gltfRef","get","materials","gltfMaterial","occlusionTexture","texCoord","attributes","uv","setAttribute","correlatedSceneGraph","clone","sourceUUIDToClonedMaterial","Map","has","set","light","target","add"],"sources":["../../../src/three-components/gltf-instance/ModelViewerGLTFInstance.ts"],"sourcesContent":["/* @license\n * Copyright 2020 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {FrontSide, Material, Mesh, MeshStandardMaterial, Object3D, Sphere, SpotLight} from 'three';\nimport {GLTF} from 'three/examples/jsm/loaders/GLTFLoader.js';\n\nimport {$clone, $prepare, $preparedGLTF, GLTFInstance, PreparedGLTF} from '../GLTFInstance.js';\n\nimport {CorrelatedSceneGraph} from './correlated-scene-graph.js';\n\nconst $correlatedSceneGraph = Symbol('correlatedSceneGraph');\n\ninterface PreparedModelViewerGLTF extends PreparedGLTF {\n  [$correlatedSceneGraph]?: CorrelatedSceneGraph;\n}\n\n/**\n * This specialization of GLTFInstance collects all of the processing needed\n * to prepare a model and to clone it making special considerations for\n * <model-viewer> use cases.\n */\nexport class ModelViewerGLTFInstance extends GLTFInstance {\n  /**\n   * @override\n   */\n  protected static[$prepare](source: GLTF) {\n    const prepared = super[$prepare](source) as PreparedModelViewerGLTF;\n\n    if (prepared[$correlatedSceneGraph] == null) {\n      prepared[$correlatedSceneGraph] = CorrelatedSceneGraph.from(prepared);\n    }\n\n    const {scene} = prepared;\n\n    const nullSphere = new Sphere(undefined, Infinity);\n\n    scene.traverse((node: Object3D) => {\n      // Set a high renderOrder while we're here to ensure the model\n      // always renders on top of the sky sphere\n      node.renderOrder = 1000;\n\n      // Three.js seems to cull some animated models incorrectly. Since we\n      // expect to view our whole scene anyway, we turn off the frustum\n      // culling optimization here.\n      node.frustumCulled = false;\n      // Animations for objects without names target their UUID instead. When\n      // objects are cloned, they get new UUIDs which the animation can't\n      // find. To fix this, we assign their UUID as their name.\n      if (!node.name) {\n        node.name = node.uuid;\n      }\n      const mesh = node as Mesh;\n      if (mesh.material) {\n        const {geometry} = mesh;\n        mesh.castShadow = true;\n        if ((mesh as any).isSkinnedMesh) {\n          // Akin to disabling frustum culling above, we have to also manually\n          // disable the bounds to make raycasting correct for skinned meshes.\n          geometry.boundingSphere = nullSphere;\n          // The bounding box is set in GLTFLoader by the accessor bounds, which\n          // are not updated with animation.\n          geometry.boundingBox = null;\n        }\n\n        const material = mesh.material as MeshStandardMaterial;\n        if ((material as any).isMeshBasicMaterial === true) {\n          material.toneMapped = false;\n        }\n        // This makes shadows better for non-manifold meshes\n        material.shadowSide = FrontSide;\n\n        // Fixes an edge case with unused extra UV-coords being incorrectly\n        // referenced by three.js; remove when\n        // https://github.com/mrdoob/three.js/pull/23974 is merged.\n        if (material.aoMap) {\n          const {gltf, threeObjectMap} = prepared[$correlatedSceneGraph]!;\n          const gltfRef = threeObjectMap.get(material);\n          if (gltf.materials != null && gltfRef != null &&\n              gltfRef.materials != null) {\n            const gltfMaterial = gltf.materials[gltfRef.materials];\n            if (gltfMaterial.occlusionTexture &&\n                gltfMaterial.occlusionTexture.texCoord === 0 &&\n                geometry.attributes.uv != null) {\n              geometry.setAttribute('uv2', geometry.attributes.uv);\n            }\n          }\n        }\n      }\n    });\n\n    return prepared;\n  }\n\n  get correlatedSceneGraph() {\n    return (\n        this[$preparedGLTF] as PreparedModelViewerGLTF)[$correlatedSceneGraph]!;\n  }\n\n  /**\n   * @override\n   */\n  [$clone](): PreparedGLTF {\n    const clone: PreparedModelViewerGLTF = super[$clone]();\n    const sourceUUIDToClonedMaterial = new Map<string, Material>();\n\n    clone.scene.traverse((node: Object3D) => {\n      // Materials aren't cloned when cloning meshes; geometry\n      // and materials are copied by reference. This is necessary\n      // for the same model to be used twice with different\n      // scene-graph operations.\n      const mesh = node as Mesh;\n      if (mesh.material) {\n        const material = mesh.material as MeshStandardMaterial;\n        if (material != null) {\n          if (sourceUUIDToClonedMaterial.has(material.uuid)) {\n            mesh.material = sourceUUIDToClonedMaterial.get(material.uuid)!;\n            return;\n          }\n\n          mesh.material = material.clone() as MeshStandardMaterial;\n          sourceUUIDToClonedMaterial.set(material.uuid, mesh.material);\n        }\n      }\n\n      const light = node as SpotLight;\n      if (light.target !== undefined) {\n        // The target's parent is lost in the cloning process, but in\n        // GLTFLoader, all light targets are children of their light.\n        light.add(light.target);\n      }\n    });\n\n    // Cross-correlate the scene graph by relying on information in the\n    // current scene graph; without this step, relationships between the\n    // Three.js object graph and the glTF scene graph will be lost.\n    clone[$correlatedSceneGraph] =\n        CorrelatedSceneGraph.from(clone, this.correlatedSceneGraph);\n\n    return clone;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}