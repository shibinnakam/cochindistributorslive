{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Matrix4, Vector3 } from 'three';\nimport { $needsRender, $onModelLoad, $scene, $tick, toVector2D, toVector3D } from '../model-viewer-base.js';\nimport { Hotspot } from '../three-components/Hotspot.js';\nconst $hotspotMap = Symbol('hotspotMap');\nconst $mutationCallback = Symbol('mutationCallback');\nconst $observer = Symbol('observer');\nconst $addHotspot = Symbol('addHotspot');\nconst $removeHotspot = Symbol('removeHotspot');\nconst worldToModel = new Matrix4();\n/**\n * AnnotationMixin implements a declarative API to add hotspots and annotations.\n * Child elements of the <model-viewer> element that have a slot name that\n * begins with \"hotspot\" and data-position and data-normal attributes in\n * the format of the camera-target attribute will be added to the scene and\n * track the specified model coordinates.\n */\nexport const AnnotationMixin = ModelViewerElement => {\n  var _a, _b, _c;\n  class AnnotationModelViewerElement extends ModelViewerElement {\n    constructor() {\n      super(...arguments);\n      this[_a] = new Map();\n      this[_b] = mutations => {\n        mutations.forEach(mutation => {\n          // NOTE: Be wary that in ShadyDOM cases, the MutationRecord\n          // only has addedNodes and removedNodes (and no other details).\n          if (!(mutation instanceof MutationRecord) || mutation.type === 'childList') {\n            mutation.addedNodes.forEach(node => {\n              this[$addHotspot](node);\n            });\n            mutation.removedNodes.forEach(node => {\n              this[$removeHotspot](node);\n            });\n            this[$needsRender]();\n          }\n        });\n      };\n      this[_c] = new MutationObserver(this[$mutationCallback]);\n    }\n    connectedCallback() {\n      super.connectedCallback();\n      for (let i = 0; i < this.children.length; ++i) {\n        this[$addHotspot](this.children[i]);\n      }\n      const {\n        ShadyDOM\n      } = self;\n      if (ShadyDOM == null) {\n        this[$observer].observe(this, {\n          childList: true\n        });\n      } else {\n        this[$observer] = ShadyDOM.observeChildren(this, this[$mutationCallback]);\n      }\n    }\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      const {\n        ShadyDOM\n      } = self;\n      if (ShadyDOM == null) {\n        this[$observer].disconnect();\n      } else {\n        ShadyDOM.unobserveChildren(this[$observer]);\n      }\n    }\n    [(_a = $hotspotMap, _b = $mutationCallback, _c = $observer, $onModelLoad)]() {\n      super[$onModelLoad]();\n      const scene = this[$scene];\n      scene.forHotspots(hotspot => {\n        scene.updateSurfaceHotspot(hotspot);\n      });\n    }\n    [$tick](time, delta) {\n      super[$tick](time, delta);\n      const scene = this[$scene];\n      const {\n        annotationRenderer\n      } = scene;\n      const camera = scene.getCamera();\n      if (scene.shouldRender()) {\n        scene.animateSurfaceHotspots();\n        scene.updateHotspotsVisibility(camera.position);\n        annotationRenderer.domElement.style.display = '';\n        annotationRenderer.render(scene, camera);\n      }\n    }\n    /**\n     * Since the data-position and data-normal attributes are not observed, use\n     * this method to move a hotspot. Keep in mind that all hotspots with the\n     * same slot name use a single location and the first definition takes\n     * precedence, until updated with this method.\n     */\n    updateHotspot(config) {\n      const hotspot = this[$hotspotMap].get(config.name);\n      if (hotspot == null) {\n        return;\n      }\n      hotspot.updatePosition(config.position);\n      hotspot.updateNormal(config.normal);\n      hotspot.surface = config.surface;\n      this[$scene].updateSurfaceHotspot(hotspot);\n      this[$needsRender]();\n    }\n    /**\n     * This method returns in-scene data about a requested hotspot including\n     * its position in screen (canvas) space and its current visibility.\n     */\n    queryHotspot(name) {\n      const hotspot = this[$hotspotMap].get(name);\n      if (hotspot == null) {\n        return null;\n      }\n      const position = toVector3D(hotspot.position);\n      const normal = toVector3D(hotspot.normal);\n      const facingCamera = hotspot.facingCamera;\n      const scene = this[$scene];\n      const camera = scene.getCamera();\n      const vector = new Vector3();\n      vector.setFromMatrixPosition(hotspot.matrixWorld);\n      vector.project(camera);\n      const widthHalf = scene.width / 2;\n      const heightHalf = scene.height / 2;\n      vector.x = vector.x * widthHalf + widthHalf;\n      vector.y = -(vector.y * heightHalf) + heightHalf;\n      const canvasPosition = toVector3D(new Vector3(vector.x, vector.y, vector.z));\n      if (!Number.isFinite(canvasPosition.x) || !Number.isFinite(canvasPosition.y)) {\n        return null;\n      }\n      return {\n        position,\n        normal,\n        canvasPosition,\n        facingCamera\n      };\n    }\n    /**\n     * This method returns the model position, normal and texture coordinate\n     * of the point on the mesh corresponding to the input pixel coordinates\n     * given relative to the model-viewer element. The position and normal\n     * are returned as strings in the format suitable for putting in a\n     * hotspot's data-position and data-normal attributes. If the mesh is\n     * not hit, the result is null.\n     */\n    positionAndNormalFromPoint(pixelX, pixelY) {\n      const scene = this[$scene];\n      const ndcPosition = scene.getNDC(pixelX, pixelY);\n      const hit = scene.positionAndNormalFromPoint(ndcPosition);\n      if (hit == null) {\n        return null;\n      }\n      worldToModel.copy(scene.target.matrixWorld).invert();\n      const position = toVector3D(hit.position.applyMatrix4(worldToModel));\n      const normal = toVector3D(hit.normal.transformDirection(worldToModel));\n      let uv = null;\n      if (hit.uv != null) {\n        uv = toVector2D(hit.uv);\n      }\n      return {\n        position: position,\n        normal: normal,\n        uv: uv\n      };\n    }\n    /**\n     * This method returns a dynamic hotspot ID string of the point on the mesh\n     * corresponding to the input pixel coordinates given relative to the\n     * model-viewer element. The ID string can be used in the data-surface\n     * attribute of the hotspot to make it follow this point on the surface even\n     * as the model animates. If the mesh is not hit, the result is null.\n     */\n    surfaceFromPoint(pixelX, pixelY) {\n      const scene = this[$scene];\n      const ndcPosition = scene.getNDC(pixelX, pixelY);\n      return scene.surfaceFromPoint(ndcPosition);\n    }\n    [$addHotspot](node) {\n      if (!(node instanceof HTMLElement && node.slot.indexOf('hotspot') === 0)) {\n        return;\n      }\n      let hotspot = this[$hotspotMap].get(node.slot);\n      if (hotspot != null) {\n        hotspot.increment();\n      } else {\n        hotspot = new Hotspot({\n          name: node.slot,\n          position: node.dataset.position,\n          normal: node.dataset.normal,\n          surface: node.dataset.surface\n        });\n        this[$hotspotMap].set(node.slot, hotspot);\n        this[$scene].addHotspot(hotspot);\n      }\n      this[$scene].queueRender();\n    }\n    [$removeHotspot](node) {\n      if (!(node instanceof HTMLElement)) {\n        return;\n      }\n      const hotspot = this[$hotspotMap].get(node.slot);\n      if (!hotspot) {\n        return;\n      }\n      if (hotspot.decrement()) {\n        this[$scene].removeHotspot(hotspot);\n        this[$hotspotMap].delete(node.slot);\n      }\n      this[$scene].queueRender();\n    }\n  }\n  return AnnotationModelViewerElement;\n};","map":{"version":3,"names":["Matrix4","Vector3","$needsRender","$onModelLoad","$scene","$tick","toVector2D","toVector3D","Hotspot","$hotspotMap","Symbol","$mutationCallback","$observer","$addHotspot","$removeHotspot","worldToModel","AnnotationMixin","ModelViewerElement","AnnotationModelViewerElement","constructor","_a","Map","_b","mutations","forEach","mutation","MutationRecord","type","addedNodes","node","removedNodes","_c","MutationObserver","connectedCallback","i","children","length","ShadyDOM","self","observe","childList","observeChildren","disconnectedCallback","disconnect","unobserveChildren","scene","forHotspots","hotspot","updateSurfaceHotspot","time","delta","annotationRenderer","camera","getCamera","shouldRender","animateSurfaceHotspots","updateHotspotsVisibility","position","domElement","style","display","render","updateHotspot","config","get","name","updatePosition","updateNormal","normal","surface","queryHotspot","facingCamera","vector","setFromMatrixPosition","matrixWorld","project","widthHalf","width","heightHalf","height","x","y","canvasPosition","z","Number","isFinite","positionAndNormalFromPoint","pixelX","pixelY","ndcPosition","getNDC","hit","copy","target","invert","applyMatrix4","transformDirection","uv","surfaceFromPoint","HTMLElement","slot","indexOf","increment","dataset","set","addHotspot","queueRender","decrement","removeHotspot","delete"],"sources":["../../src/features/annotation.ts"],"sourcesContent":["\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {Matrix4, Vector3} from 'three';\n\nimport ModelViewerElementBase, {$needsRender, $onModelLoad, $scene, $tick, toVector2D, toVector3D, Vector2D, Vector3D} from '../model-viewer-base.js';\nimport {Hotspot, HotspotConfiguration} from '../three-components/Hotspot.js';\nimport {Constructor} from '../utilities.js';\n\nconst $hotspotMap = Symbol('hotspotMap');\nconst $mutationCallback = Symbol('mutationCallback');\nconst $observer = Symbol('observer');\nconst $addHotspot = Symbol('addHotspot');\nconst $removeHotspot = Symbol('removeHotspot');\n\nconst worldToModel = new Matrix4();\n\nexport declare type HotspotData = {\n  position: Vector3D,\n  normal: Vector3D,\n  canvasPosition: Vector3D,\n  facingCamera: boolean,\n}\n\nexport declare interface AnnotationInterface {\n  updateHotspot(config: HotspotConfiguration): void;\n  queryHotspot(name: string): HotspotData|null;\n  positionAndNormalFromPoint(pixelX: number, pixelY: number):\n      {position: Vector3D, normal: Vector3D, uv: Vector2D|null}|null;\n  surfaceFromPoint(pixelX: number, pixelY: number): string|null;\n}\n\n/**\n * AnnotationMixin implements a declarative API to add hotspots and annotations.\n * Child elements of the <model-viewer> element that have a slot name that\n * begins with \"hotspot\" and data-position and data-normal attributes in\n * the format of the camera-target attribute will be added to the scene and\n * track the specified model coordinates.\n */\nexport const AnnotationMixin = <T extends Constructor<ModelViewerElementBase>>(\n    ModelViewerElement: T): Constructor<AnnotationInterface>&T => {\n  class AnnotationModelViewerElement extends ModelViewerElement {\n    private[$hotspotMap] = new Map<string, Hotspot>();\n    private[$mutationCallback] = (mutations: Array<unknown>) => {\n      mutations.forEach((mutation) => {\n        // NOTE: Be wary that in ShadyDOM cases, the MutationRecord\n        // only has addedNodes and removedNodes (and no other details).\n        if (!(mutation instanceof MutationRecord) ||\n            mutation.type === 'childList') {\n          (mutation as MutationRecord).addedNodes.forEach((node) => {\n            this[$addHotspot](node);\n          });\n          (mutation as MutationRecord).removedNodes.forEach((node) => {\n            this[$removeHotspot](node);\n          });\n          this[$needsRender]();\n        }\n      });\n    };\n    private[$observer] = new MutationObserver(this[$mutationCallback]);\n\n    connectedCallback() {\n      super.connectedCallback();\n\n      for (let i = 0; i < this.children.length; ++i) {\n        this[$addHotspot](this.children[i]);\n      }\n\n      const {ShadyDOM} = self as any;\n\n      if (ShadyDOM == null) {\n        this[$observer].observe(this, {childList: true});\n      } else {\n        this[$observer] =\n            ShadyDOM.observeChildren(this, this[$mutationCallback]);\n      }\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n\n      const {ShadyDOM} = self as any;\n\n      if (ShadyDOM == null) {\n        this[$observer].disconnect();\n      } else {\n        ShadyDOM.unobserveChildren(this[$observer]);\n      }\n    }\n\n    [$onModelLoad]() {\n      super[$onModelLoad]();\n\n      const scene = this[$scene];\n      scene.forHotspots((hotspot) => {\n        scene.updateSurfaceHotspot(hotspot);\n      });\n    }\n\n    [$tick](time: number, delta: number) {\n      super[$tick](time, delta);\n      const scene = this[$scene];\n      const {annotationRenderer} = scene;\n      const camera = scene.getCamera();\n\n      if (scene.shouldRender()) {\n        scene.animateSurfaceHotspots();\n        scene.updateHotspotsVisibility(camera.position);\n        annotationRenderer.domElement.style.display = '';\n        annotationRenderer.render(scene, camera);\n      }\n    }\n\n    /**\n     * Since the data-position and data-normal attributes are not observed, use\n     * this method to move a hotspot. Keep in mind that all hotspots with the\n     * same slot name use a single location and the first definition takes\n     * precedence, until updated with this method.\n     */\n    updateHotspot(config: HotspotConfiguration) {\n      const hotspot = this[$hotspotMap].get(config.name);\n\n      if (hotspot == null) {\n        return;\n      }\n\n      hotspot.updatePosition(config.position);\n      hotspot.updateNormal(config.normal);\n      hotspot.surface = config.surface;\n      this[$scene].updateSurfaceHotspot(hotspot);\n      this[$needsRender]();\n    }\n\n    /**\n     * This method returns in-scene data about a requested hotspot including\n     * its position in screen (canvas) space and its current visibility.\n     */\n    queryHotspot(name: string): HotspotData|null {\n      const hotspot = this[$hotspotMap].get(name);\n      if (hotspot == null) {\n        return null;\n      }\n\n      const position = toVector3D(hotspot.position);\n      const normal = toVector3D(hotspot.normal);\n      const facingCamera = hotspot.facingCamera;\n\n      const scene = this[$scene];\n      const camera = scene.getCamera();\n      const vector = new Vector3();\n\n      vector.setFromMatrixPosition(hotspot.matrixWorld);\n      vector.project(camera);\n\n      const widthHalf = scene.width / 2;\n      const heightHalf = scene.height / 2;\n\n      vector.x = (vector.x * widthHalf) + widthHalf;\n      vector.y = -(vector.y * heightHalf) + heightHalf;\n\n      const canvasPosition =\n          toVector3D(new Vector3(vector.x, vector.y, vector.z));\n\n      if (!Number.isFinite(canvasPosition.x) ||\n          !Number.isFinite(canvasPosition.y)) {\n        return null;\n      }\n\n      return {position, normal, canvasPosition, facingCamera};\n    }\n\n    /**\n     * This method returns the model position, normal and texture coordinate\n     * of the point on the mesh corresponding to the input pixel coordinates\n     * given relative to the model-viewer element. The position and normal\n     * are returned as strings in the format suitable for putting in a\n     * hotspot's data-position and data-normal attributes. If the mesh is\n     * not hit, the result is null.\n     */\n    positionAndNormalFromPoint(pixelX: number, pixelY: number):\n        {position: Vector3D, normal: Vector3D, uv: Vector2D|null}|null {\n      const scene = this[$scene];\n      const ndcPosition = scene.getNDC(pixelX, pixelY);\n\n      const hit = scene.positionAndNormalFromPoint(ndcPosition);\n      if (hit == null) {\n        return null;\n      }\n\n      worldToModel.copy(scene.target.matrixWorld).invert();\n      const position = toVector3D(hit.position.applyMatrix4(worldToModel));\n      const normal = toVector3D(hit.normal.transformDirection(worldToModel));\n\n      let uv = null;\n      if (hit.uv != null) {\n        uv = toVector2D(hit.uv);\n      }\n\n      return {position: position, normal: normal, uv: uv};\n    }\n\n    /**\n     * This method returns a dynamic hotspot ID string of the point on the mesh\n     * corresponding to the input pixel coordinates given relative to the\n     * model-viewer element. The ID string can be used in the data-surface\n     * attribute of the hotspot to make it follow this point on the surface even\n     * as the model animates. If the mesh is not hit, the result is null.\n     */\n    surfaceFromPoint(pixelX: number, pixelY: number): string|null {\n      const scene = this[$scene];\n      const ndcPosition = scene.getNDC(pixelX, pixelY);\n\n      return scene.surfaceFromPoint(ndcPosition);\n    }\n\n    private[$addHotspot](node: Node) {\n      if (!(node instanceof HTMLElement &&\n            node.slot.indexOf('hotspot') === 0)) {\n        return;\n      }\n\n      let hotspot = this[$hotspotMap].get(node.slot);\n\n      if (hotspot != null) {\n        hotspot.increment();\n      } else {\n        hotspot = new Hotspot({\n          name: node.slot,\n          position: node.dataset.position,\n          normal: node.dataset.normal,\n          surface: node.dataset.surface,\n        });\n        this[$hotspotMap].set(node.slot, hotspot);\n        this[$scene].addHotspot(hotspot);\n      }\n      this[$scene].queueRender();\n    }\n\n    private[$removeHotspot](node: Node) {\n      if (!(node instanceof HTMLElement)) {\n        return;\n      }\n\n      const hotspot = this[$hotspotMap].get(node.slot);\n\n      if (!hotspot) {\n        return;\n      }\n\n      if (hotspot.decrement()) {\n        this[$scene].removeHotspot(hotspot);\n        this[$hotspotMap].delete(node.slot);\n      }\n      this[$scene].queueRender();\n    }\n  }\n\n  return AnnotationModelViewerElement;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}