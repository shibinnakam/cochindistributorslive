{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a, _b, _c;\nimport { normalizeUnit } from './conversions.js';\nimport { numberNode, ZERO } from './parsers.js';\nconst $evaluate = Symbol('evaluate');\nconst $lastValue = Symbol('lastValue');\n/**\n * An Evaluator is used to derive a computed style from part (or all) of a CSS\n * expression AST. This construct is particularly useful for complex ASTs\n * containing function calls such as calc, var and env. Such styles could be\n * costly to re-evaluate on every frame (and in some cases we may try to do\n * that). The Evaluator construct allows us to mark sub-trees of the AST as\n * constant, so that only the dynamic parts are re-evaluated. It also separates\n * one-time AST preparation work from work that necessarily has to happen upon\n * each evaluation.\n */\nexport class Evaluator {\n  constructor() {\n    this[_a] = null;\n  }\n  /**\n   * An Evaluatable is a NumberNode or an Evaluator that evaluates a NumberNode\n   * as the result of invoking its evaluate method. This is mainly used to\n   * ensure that CSS function nodes are cast to the corresponding Evaluators\n   * that will resolve the result of the function, but is also used to ensure\n   * that a percentage nested at arbitrary depth in the expression will always\n   * be evaluated against the correct basis.\n   */\n  static evaluatableFor(node, basis = ZERO) {\n    if (node instanceof Evaluator) {\n      return node;\n    }\n    if (node.type === 'number') {\n      if (node.unit === '%') {\n        return new PercentageEvaluator(node, basis);\n      }\n      return node;\n    }\n    switch (node.name.value) {\n      case 'calc':\n        return new CalcEvaluator(node, basis);\n      case 'env':\n        return new EnvEvaluator(node);\n    }\n    return ZERO;\n  }\n  /**\n   * If the input is an Evaluator, returns the result of evaluating it.\n   * Otherwise, returns the input.\n   *\n   * This is a helper to aide in resolving a NumberNode without conditionally\n   * checking if the Evaluatable is an Evaluator everywhere.\n   */\n  static evaluate(evaluatable) {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.evaluate();\n    }\n    return evaluatable;\n  }\n  /**\n   * If the input is an Evaluator, returns the value of its isConstant property.\n   * Returns true for all other input values.\n   */\n  static isConstant(evaluatable) {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.isConstant;\n    }\n    return true;\n  }\n  /**\n   * This method applies a set of structured intrinsic metadata to an evaluated\n   * result from a parsed CSS-like string of expressions. Intrinsics provide\n   * sufficient metadata (e.g., basis values, analogs for keywords) such that\n   * omitted values in the input string can be backfilled, and keywords can be\n   * converted to concrete numbers.\n   *\n   * The result of applying intrinsics is a tuple of NumberNode values whose\n   * units match the units used by the basis of the intrinsics.\n   *\n   * The following is a high-level description of how intrinsics are applied:\n   *\n   *  1. Determine the value of 'auto' for the current term\n   *  2. If there is no corresponding input value for this term, substitute the\n   *     'auto' value.\n   *  3. If the term is an IdentNode, treat it as a keyword and perform the\n   *     appropriate substitution.\n   *  4. If the term is still null, fallback to the 'auto' value\n   *  5. If the term is a percentage, apply it to the basis and return that\n   *     value\n   *  6. Normalize the unit of the term\n   *  7. If the term's unit does not match the basis unit, return the basis\n   *     value\n   *  8. Return the term as is\n   */\n  static applyIntrinsics(evaluated, intrinsics) {\n    const {\n      basis,\n      keywords\n    } = intrinsics;\n    const {\n      auto\n    } = keywords;\n    return basis.map((basisNode, index) => {\n      // Use an auto value if we have it, otherwise the auto value is the basis:\n      const autoSubstituteNode = auto[index] == null ? basisNode : auto[index];\n      // If the evaluated nodes do not have a node at the current\n      // index, fallback to the \"auto\" substitute right away:\n      let evaluatedNode = evaluated[index] ? evaluated[index] : autoSubstituteNode;\n      // Any ident node is considered a keyword:\n      if (evaluatedNode.type === 'ident') {\n        const keyword = evaluatedNode.value;\n        // Substitute any keywords for concrete values first:\n        if (keyword in keywords) {\n          evaluatedNode = keywords[keyword][index];\n        }\n      }\n      // If we don't have a NumberNode at this point, fall back to whatever\n      // is specified for auto:\n      if (evaluatedNode == null || evaluatedNode.type === 'ident') {\n        evaluatedNode = autoSubstituteNode;\n      }\n      // For percentages, we always apply the percentage to the basis value:\n      if (evaluatedNode.unit === '%') {\n        return numberNode(evaluatedNode.number / 100 * basisNode.number, basisNode.unit);\n      }\n      // Otherwise, normalize whatever we have:\n      evaluatedNode = normalizeUnit(evaluatedNode, basisNode);\n      // If the normalized units do not match, return the basis as a fallback:\n      if (evaluatedNode.unit !== basisNode.unit) {\n        return basisNode;\n      }\n      // Finally, return the evaluated node with intrinsics applied:\n      return evaluatedNode;\n    });\n  }\n  /**\n   * If true, the Evaluator will only evaluate its AST one time. If false, the\n   * Evaluator will re-evaluate the AST each time that the public evaluate\n   * method is invoked.\n   */\n  get isConstant() {\n    return false;\n  }\n  /**\n   * Evaluate the Evaluator and return the result. If the Evaluator is constant,\n   * the corresponding AST will only be evaluated once, and the result of\n   * evaluating it the first time will be returned on all subsequent\n   * evaluations.\n   */\n  evaluate() {\n    if (!this.isConstant || this[$lastValue] == null) {\n      this[$lastValue] = this[$evaluate]();\n    }\n    return this[$lastValue];\n  }\n}\n_a = $lastValue;\nconst $percentage = Symbol('percentage');\nconst $basis = Symbol('basis');\n/**\n * A PercentageEvaluator scales a given basis value by a given percentage value.\n * The evaluated result is always considered to be constant.\n */\nexport class PercentageEvaluator extends Evaluator {\n  constructor(percentage, basis) {\n    super();\n    this[$percentage] = percentage;\n    this[$basis] = basis;\n  }\n  get isConstant() {\n    return true;\n  }\n  [$evaluate]() {\n    return numberNode(this[$percentage].number / 100 * this[$basis].number, this[$basis].unit);\n  }\n}\nconst $identNode = Symbol('identNode');\n/**\n * Evaluator for CSS-like env() functions. Currently, only one environment\n * variable is accepted as an argument for such functions: window-scroll-y.\n *\n * The env() Evaluator is explicitly dynamic because it always refers to\n * external state that changes as the user scrolls, so it should always be\n * re-evaluated to ensure we get the most recent value.\n *\n * Some important notes about this feature include:\n *\n *  - There is no such thing as a \"window-scroll-y\" CSS environment variable in\n *    any stable browser at the time that this comment is being written.\n *  - The actual CSS env() function accepts a second argument as a fallback for\n *    the case that the specified first argument isn't set; our syntax does not\n *    support this second argument.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/env\n */\nexport class EnvEvaluator extends Evaluator {\n  constructor(envFunction) {\n    super();\n    this[_b] = null;\n    const identNode = envFunction.arguments.length ? envFunction.arguments[0].terms[0] : null;\n    if (identNode != null && identNode.type === 'ident') {\n      this[$identNode] = identNode;\n    }\n  }\n  get isConstant() {\n    return false;\n  }\n  [(_b = $identNode, $evaluate)]() {\n    if (this[$identNode] != null) {\n      switch (this[$identNode].value) {\n        case 'window-scroll-y':\n          const verticalScrollPosition = window.pageYOffset;\n          const verticalScrollMax = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);\n          const scrollY = verticalScrollPosition / (verticalScrollMax - window.innerHeight) || 0;\n          return {\n            type: 'number',\n            number: scrollY,\n            unit: null\n          };\n      }\n    }\n    return ZERO;\n  }\n}\nconst IS_MULTIPLICATION_RE = /[\\*\\/]/;\nconst $evaluator = Symbol('evaluator');\n/**\n * Evaluator for CSS-like calc() functions. Our implementation of calc()\n * evaluation currently support nested function calls, an unlimited number of\n * terms, and all four algebraic operators (+, -, * and /).\n *\n * The Evaluator is marked as constant unless the calc expression contains an\n * internal env expression at any depth, in which case it will be marked as\n * dynamic.\n *\n * @see https://www.w3.org/TR/css-values-3/#calc-syntax\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\nexport class CalcEvaluator extends Evaluator {\n  constructor(calcFunction, basis = ZERO) {\n    super();\n    this[_c] = null;\n    if (calcFunction.arguments.length !== 1) {\n      return;\n    }\n    const terms = calcFunction.arguments[0].terms.slice();\n    const secondOrderTerms = [];\n    while (terms.length) {\n      const term = terms.shift();\n      if (secondOrderTerms.length > 0) {\n        const previousTerm = secondOrderTerms[secondOrderTerms.length - 1];\n        if (previousTerm.type === 'operator' && IS_MULTIPLICATION_RE.test(previousTerm.value)) {\n          const operator = secondOrderTerms.pop();\n          const leftValue = secondOrderTerms.pop();\n          if (leftValue == null) {\n            return;\n          }\n          secondOrderTerms.push(new OperatorEvaluator(operator, Evaluator.evaluatableFor(leftValue, basis), Evaluator.evaluatableFor(term, basis)));\n          continue;\n        }\n      }\n      secondOrderTerms.push(term.type === 'operator' ? term : Evaluator.evaluatableFor(term, basis));\n    }\n    while (secondOrderTerms.length > 2) {\n      const [left, operator, right] = secondOrderTerms.splice(0, 3);\n      if (operator.type !== 'operator') {\n        return;\n      }\n      secondOrderTerms.unshift(new OperatorEvaluator(operator, Evaluator.evaluatableFor(left, basis), Evaluator.evaluatableFor(right, basis)));\n    }\n    // There should only be one combined evaluator at this point:\n    if (secondOrderTerms.length === 1) {\n      this[$evaluator] = secondOrderTerms[0];\n    }\n  }\n  get isConstant() {\n    return this[$evaluator] == null || Evaluator.isConstant(this[$evaluator]);\n  }\n  [(_c = $evaluator, $evaluate)]() {\n    return this[$evaluator] != null ? Evaluator.evaluate(this[$evaluator]) : ZERO;\n  }\n}\nconst $operator = Symbol('operator');\nconst $left = Symbol('left');\nconst $right = Symbol('right');\n/**\n * An Evaluator for the operators found inside CSS calc() functions.\n * The evaluator accepts an operator and left/right operands. The operands can\n * be any valid expression term typically allowed inside a CSS calc function.\n *\n * As detail of this implementation, the only supported unit types are angles\n * expressed as radians or degrees, and lengths expressed as meters, centimeters\n * or millimeters.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\nexport class OperatorEvaluator extends Evaluator {\n  constructor(operator, left, right) {\n    super();\n    this[$operator] = operator;\n    this[$left] = left;\n    this[$right] = right;\n  }\n  get isConstant() {\n    return Evaluator.isConstant(this[$left]) && Evaluator.isConstant(this[$right]);\n  }\n  [$evaluate]() {\n    const leftNode = normalizeUnit(Evaluator.evaluate(this[$left]));\n    const rightNode = normalizeUnit(Evaluator.evaluate(this[$right]));\n    const {\n      number: leftValue,\n      unit: leftUnit\n    } = leftNode;\n    const {\n      number: rightValue,\n      unit: rightUnit\n    } = rightNode;\n    // Disallow operations for mismatched normalized units e.g., m and rad:\n    if (rightUnit != null && leftUnit != null && rightUnit != leftUnit) {\n      return ZERO;\n    }\n    // NOTE(cdata): rules for calc type checking are defined here\n    // https://drafts.csswg.org/css-values-3/#calc-type-checking\n    // This is a simplification and may not hold up once we begin to support\n    // additional unit types:\n    const unit = leftUnit || rightUnit;\n    let value;\n    switch (this[$operator].value) {\n      case '+':\n        value = leftValue + rightValue;\n        break;\n      case '-':\n        value = leftValue - rightValue;\n        break;\n      case '/':\n        value = leftValue / rightValue;\n        break;\n      case '*':\n        value = leftValue * rightValue;\n        break;\n      default:\n        return ZERO;\n    }\n    return {\n      type: 'number',\n      number: value,\n      unit\n    };\n  }\n}\nconst $evaluatables = Symbol('evaluatables');\nconst $intrinsics = Symbol('intrinsics');\n/**\n * A VectorEvaluator evaluates a series of numeric terms that usually represent\n * a data structure such as a multi-dimensional vector or a spherical\n *\n * The form of the evaluator's result is determined by the Intrinsics that are\n * given to it when it is constructed. For example, spherical intrinsics would\n * establish two angle terms and a length term, so the result of evaluating the\n * evaluator that is configured with spherical intrinsics is a three element\n * array where the first two elements represent angles in radians and the third\n * element representing a length in meters.\n */\nexport class StyleEvaluator extends Evaluator {\n  constructor(expressions, intrinsics) {\n    super();\n    this[$intrinsics] = intrinsics;\n    const firstExpression = expressions[0];\n    const terms = firstExpression != null ? firstExpression.terms : [];\n    this[$evaluatables] = intrinsics.basis.map((basisNode, index) => {\n      const term = terms[index];\n      if (term == null) {\n        return {\n          type: 'ident',\n          value: 'auto'\n        };\n      }\n      if (term.type === 'ident') {\n        return term;\n      }\n      return Evaluator.evaluatableFor(term, basisNode);\n    });\n  }\n  get isConstant() {\n    for (const evaluatable of this[$evaluatables]) {\n      if (!Evaluator.isConstant(evaluatable)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  [$evaluate]() {\n    const evaluated = this[$evaluatables].map(evaluatable => Evaluator.evaluate(evaluatable));\n    return Evaluator.applyIntrinsics(evaluated, this[$intrinsics]).map(numberNode => numberNode.number);\n  }\n}","map":{"version":3,"names":["normalizeUnit","numberNode","ZERO","$evaluate","Symbol","$lastValue","Evaluator","constructor","_a","evaluatableFor","node","basis","type","unit","PercentageEvaluator","name","value","CalcEvaluator","EnvEvaluator","evaluate","evaluatable","isConstant","applyIntrinsics","evaluated","intrinsics","keywords","auto","map","basisNode","index","autoSubstituteNode","evaluatedNode","keyword","number","$percentage","$basis","percentage","$identNode","envFunction","_b","identNode","arguments","length","terms","verticalScrollPosition","window","pageYOffset","verticalScrollMax","Math","max","document","body","scrollHeight","offsetHeight","documentElement","clientHeight","scrollY","innerHeight","IS_MULTIPLICATION_RE","$evaluator","calcFunction","_c","slice","secondOrderTerms","term","shift","previousTerm","test","operator","pop","leftValue","push","OperatorEvaluator","left","right","splice","unshift","$operator","$left","$right","leftNode","rightNode","leftUnit","rightValue","rightUnit","$evaluatables","$intrinsics","StyleEvaluator","expressions","firstExpression"],"sources":["../../src/styles/evaluators.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {normalizeUnit} from './conversions.js';\nimport {ExpressionNode, ExpressionTerm, FunctionNode, IdentNode, NumberNode, numberNode, OperatorNode, Percentage, Unit, ZERO} from './parsers.js';\n\nexport type Evaluatable<T> = Evaluator<T>|T;\n\n/**\n * A NumberNodeSequence is a vector of NumberNodes with a specified\n * sequence of units.\n */\nexport type NumberNodeSequence<T extends Array<Unit>, U = never> = {\n  [I in keyof T]:\n      NumberNode&{\n        unit: T[I]|U;\n      };\n};\n\nexport type Sparse<T> = {\n  [I in keyof T]: null|T[I];\n};\n\n/**\n * Intrinsics describe the metadata required to do four things for any given\n * type of number-based CSS expression:\n *\n *  1. Establish the expected units of a final, evaluated result\n *  2. Provide a foundational value that percentages should scale against\n *  3. Describe the analog number values that correspond to various keywords\n *  4. Have an available concrete value to fallback to when needed\n *\n * Intrinsics must always specify a basis and the substitute values for the\n * keyword 'auto'.\n *\n * Intrinsics may optionally specify the substitute values for any additional\n * number of keywords.\n */\nexport interface Intrinsics<T extends Array<Unit> = []> {\n  basis: NumberNodeSequence<T>;\n  keywords: {\n    auto: Sparse<NumberNodeSequence<T, Percentage>>;\n    [index: string]: Sparse<NumberNodeSequence<T, Percentage>>;\n  };\n}\n\nconst $evaluate = Symbol('evaluate');\nconst $lastValue = Symbol('lastValue');\n\n/**\n * An Evaluator is used to derive a computed style from part (or all) of a CSS\n * expression AST. This construct is particularly useful for complex ASTs\n * containing function calls such as calc, var and env. Such styles could be\n * costly to re-evaluate on every frame (and in some cases we may try to do\n * that). The Evaluator construct allows us to mark sub-trees of the AST as\n * constant, so that only the dynamic parts are re-evaluated. It also separates\n * one-time AST preparation work from work that necessarily has to happen upon\n * each evaluation.\n */\nexport abstract class Evaluator<T> {\n  /**\n   * An Evaluatable is a NumberNode or an Evaluator that evaluates a NumberNode\n   * as the result of invoking its evaluate method. This is mainly used to\n   * ensure that CSS function nodes are cast to the corresponding Evaluators\n   * that will resolve the result of the function, but is also used to ensure\n   * that a percentage nested at arbitrary depth in the expression will always\n   * be evaluated against the correct basis.\n   */\n  static evaluatableFor(\n      node: ExpressionTerm|Evaluator<NumberNode>,\n      basis: NumberNode = ZERO): Evaluatable<NumberNode> {\n    if (node instanceof Evaluator) {\n      return node;\n    }\n\n    if (node.type === 'number') {\n      if (node.unit === '%') {\n        return new PercentageEvaluator(node as NumberNode<'%'>, basis);\n      }\n      return node;\n    }\n\n    switch ((node as FunctionNode).name.value) {\n      case 'calc':\n        return new CalcEvaluator(node as FunctionNode, basis);\n      case 'env':\n        return new EnvEvaluator(node as FunctionNode);\n    }\n\n    return ZERO;\n  }\n\n  /**\n   * If the input is an Evaluator, returns the result of evaluating it.\n   * Otherwise, returns the input.\n   *\n   * This is a helper to aide in resolving a NumberNode without conditionally\n   * checking if the Evaluatable is an Evaluator everywhere.\n   */\n  static evaluate<T extends NumberNode|IdentNode>(evaluatable: Evaluatable<T>):\n      T {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.evaluate();\n    }\n\n    return evaluatable;\n  }\n\n  /**\n   * If the input is an Evaluator, returns the value of its isConstant property.\n   * Returns true for all other input values.\n   */\n  static isConstant<T>(evaluatable: Evaluatable<T>): boolean {\n    if (evaluatable instanceof Evaluator) {\n      return evaluatable.isConstant;\n    }\n    return true;\n  }\n\n  /**\n   * This method applies a set of structured intrinsic metadata to an evaluated\n   * result from a parsed CSS-like string of expressions. Intrinsics provide\n   * sufficient metadata (e.g., basis values, analogs for keywords) such that\n   * omitted values in the input string can be backfilled, and keywords can be\n   * converted to concrete numbers.\n   *\n   * The result of applying intrinsics is a tuple of NumberNode values whose\n   * units match the units used by the basis of the intrinsics.\n   *\n   * The following is a high-level description of how intrinsics are applied:\n   *\n   *  1. Determine the value of 'auto' for the current term\n   *  2. If there is no corresponding input value for this term, substitute the\n   *     'auto' value.\n   *  3. If the term is an IdentNode, treat it as a keyword and perform the\n   *     appropriate substitution.\n   *  4. If the term is still null, fallback to the 'auto' value\n   *  5. If the term is a percentage, apply it to the basis and return that\n   *     value\n   *  6. Normalize the unit of the term\n   *  7. If the term's unit does not match the basis unit, return the basis\n   *     value\n   *  8. Return the term as is\n   */\n  static applyIntrinsics<T extends Array<Unit>>(\n      evaluated: Array<any>, intrinsics: Intrinsics<T>): NumberNodeSequence<T> {\n    const {basis, keywords} = intrinsics;\n    const {auto} = keywords;\n\n    return basis.map<NumberNode>((basisNode, index) => {\n      // Use an auto value if we have it, otherwise the auto value is the basis:\n      const autoSubstituteNode = auto[index] == null ? basisNode : auto[index];\n\n      // If the evaluated nodes do not have a node at the current\n      // index, fallback to the \"auto\" substitute right away:\n      let evaluatedNode =\n          evaluated[index] ? evaluated[index] : autoSubstituteNode;\n\n      // Any ident node is considered a keyword:\n      if (evaluatedNode.type === 'ident') {\n        const keyword = evaluatedNode.value;\n        // Substitute any keywords for concrete values first:\n        if (keyword in keywords) {\n          evaluatedNode = keywords[keyword][index];\n        }\n      }\n\n      // If we don't have a NumberNode at this point, fall back to whatever\n      // is specified for auto:\n      if (evaluatedNode == null || evaluatedNode.type === 'ident') {\n        evaluatedNode = autoSubstituteNode;\n      }\n\n      // For percentages, we always apply the percentage to the basis value:\n      if (evaluatedNode.unit === '%') {\n        return numberNode(\n            evaluatedNode.number / 100 * basisNode.number, basisNode.unit);\n      }\n\n      // Otherwise, normalize whatever we have:\n      evaluatedNode = normalizeUnit(evaluatedNode, basisNode);\n\n      // If the normalized units do not match, return the basis as a fallback:\n      if (evaluatedNode.unit !== basisNode.unit) {\n        return basisNode;\n      }\n\n      // Finally, return the evaluated node with intrinsics applied:\n      return evaluatedNode;\n    }) as NumberNodeSequence<T>;\n  }\n\n  /**\n   * If true, the Evaluator will only evaluate its AST one time. If false, the\n   * Evaluator will re-evaluate the AST each time that the public evaluate\n   * method is invoked.\n   */\n  get isConstant(): boolean {\n    return false;\n  }\n\n  protected[$lastValue]: T|null = null;\n\n  /**\n   * This method must be implemented by subclasses. Its implementation should be\n   * the actual steps to evaluate the AST, and should return the evaluated\n   * result.\n   */\n  protected abstract[$evaluate](): T;\n\n  /**\n   * Evaluate the Evaluator and return the result. If the Evaluator is constant,\n   * the corresponding AST will only be evaluated once, and the result of\n   * evaluating it the first time will be returned on all subsequent\n   * evaluations.\n   */\n  evaluate(): T {\n    if (!this.isConstant || this[$lastValue] == null) {\n      this[$lastValue] = this[$evaluate]();\n    }\n    return this[$lastValue]!;\n  }\n}\n\n\nconst $percentage = Symbol('percentage');\nconst $basis = Symbol('basis');\n\n\n/**\n * A PercentageEvaluator scales a given basis value by a given percentage value.\n * The evaluated result is always considered to be constant.\n */\nexport class PercentageEvaluator extends Evaluator<NumberNode> {\n  protected[$percentage]: NumberNode<'%'>;\n  protected[$basis]: NumberNode;\n\n  constructor(percentage: NumberNode<'%'>, basis: NumberNode) {\n    super();\n\n    this[$percentage] = percentage;\n    this[$basis] = basis;\n  }\n\n  get isConstant() {\n    return true;\n  }\n\n  [$evaluate]() {\n    return numberNode(\n        this[$percentage].number / 100 * this[$basis].number,\n        this[$basis].unit);\n  }\n}\n\n\nconst $identNode = Symbol('identNode');\n\n/**\n * Evaluator for CSS-like env() functions. Currently, only one environment\n * variable is accepted as an argument for such functions: window-scroll-y.\n *\n * The env() Evaluator is explicitly dynamic because it always refers to\n * external state that changes as the user scrolls, so it should always be\n * re-evaluated to ensure we get the most recent value.\n *\n * Some important notes about this feature include:\n *\n *  - There is no such thing as a \"window-scroll-y\" CSS environment variable in\n *    any stable browser at the time that this comment is being written.\n *  - The actual CSS env() function accepts a second argument as a fallback for\n *    the case that the specified first argument isn't set; our syntax does not\n *    support this second argument.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/env\n */\nexport class EnvEvaluator extends Evaluator<NumberNode> {\n  protected[$identNode]: IdentNode|null = null;\n\n  constructor(envFunction: FunctionNode) {\n    super();\n\n    const identNode =\n        envFunction.arguments.length ? envFunction.arguments[0].terms[0] : null;\n\n    if (identNode != null && identNode.type === 'ident') {\n      this[$identNode] = identNode;\n    }\n  }\n\n  get isConstant(): boolean {\n    return false;\n  };\n\n  [$evaluate](): NumberNode {\n    if (this[$identNode] != null) {\n      switch (this[$identNode]!.value) {\n        case 'window-scroll-y':\n          const verticalScrollPosition = window.pageYOffset;\n          const verticalScrollMax = Math.max(\n              document.body.scrollHeight,\n              document.body.offsetHeight,\n              document.documentElement.clientHeight,\n              document.documentElement.scrollHeight,\n              document.documentElement.offsetHeight);\n          const scrollY = verticalScrollPosition /\n                  (verticalScrollMax - window.innerHeight) ||\n              0;\n\n          return {type: 'number', number: scrollY, unit: null};\n      }\n    }\n\n    return ZERO;\n  }\n}\n\n\nconst IS_MULTIPLICATION_RE = /[\\*\\/]/;\nconst $evaluator = Symbol('evaluator');\n\n/**\n * Evaluator for CSS-like calc() functions. Our implementation of calc()\n * evaluation currently support nested function calls, an unlimited number of\n * terms, and all four algebraic operators (+, -, * and /).\n *\n * The Evaluator is marked as constant unless the calc expression contains an\n * internal env expression at any depth, in which case it will be marked as\n * dynamic.\n *\n * @see https://www.w3.org/TR/css-values-3/#calc-syntax\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\nexport class CalcEvaluator extends Evaluator<NumberNode> {\n  protected[$evaluator]: Evaluator<NumberNode>|null = null;\n\n  constructor(calcFunction: FunctionNode, basis: NumberNode = ZERO) {\n    super();\n\n    if (calcFunction.arguments.length !== 1) {\n      return;\n    }\n\n    const terms: Array<ExpressionTerm> =\n        calcFunction.arguments[0].terms.slice();\n    const secondOrderTerms: Array<ExpressionTerm|Evaluator<NumberNode>> = [];\n\n    while (terms.length) {\n      const term: ExpressionTerm = terms.shift()!;\n\n      if (secondOrderTerms.length > 0) {\n        const previousTerm =\n            secondOrderTerms[secondOrderTerms.length - 1] as ExpressionTerm;\n        if (previousTerm.type === 'operator' &&\n            IS_MULTIPLICATION_RE.test(previousTerm.value)) {\n          const operator = secondOrderTerms.pop() as OperatorNode;\n          const leftValue = secondOrderTerms.pop();\n\n          if (leftValue == null) {\n            return;\n          }\n\n          secondOrderTerms.push(new OperatorEvaluator(\n              operator,\n              Evaluator.evaluatableFor(leftValue, basis),\n              Evaluator.evaluatableFor(term, basis)));\n          continue;\n        }\n      }\n\n      secondOrderTerms.push(\n          term.type === 'operator' ? term :\n                                     Evaluator.evaluatableFor(term, basis));\n    }\n\n    while (secondOrderTerms.length > 2) {\n      const [left, operator, right] = secondOrderTerms.splice(0, 3);\n      if ((operator as ExpressionTerm).type !== 'operator') {\n        return;\n      }\n\n      secondOrderTerms.unshift(new OperatorEvaluator(\n          operator as OperatorNode,\n          Evaluator.evaluatableFor(left, basis),\n          Evaluator.evaluatableFor(right, basis)));\n    }\n\n    // There should only be one combined evaluator at this point:\n    if (secondOrderTerms.length === 1) {\n      this[$evaluator] = secondOrderTerms[0] as Evaluator<NumberNode>;\n    }\n  }\n\n  get isConstant() {\n    return this[$evaluator] == null || Evaluator.isConstant(this[$evaluator]!);\n  }\n\n  [$evaluate]() {\n    return this[$evaluator] != null ? Evaluator.evaluate(this[$evaluator]!) :\n                                      ZERO;\n  }\n}\n\n\n\nconst $operator = Symbol('operator');\nconst $left = Symbol('left');\nconst $right = Symbol('right');\n\n/**\n * An Evaluator for the operators found inside CSS calc() functions.\n * The evaluator accepts an operator and left/right operands. The operands can\n * be any valid expression term typically allowed inside a CSS calc function.\n *\n * As detail of this implementation, the only supported unit types are angles\n * expressed as radians or degrees, and lengths expressed as meters, centimeters\n * or millimeters.\n *\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/calc\n */\nexport class OperatorEvaluator extends Evaluator<NumberNode> {\n  protected[$operator]: OperatorNode;\n  protected[$left]: Evaluatable<NumberNode>;\n  protected[$right]: Evaluatable<NumberNode>;\n\n  constructor(\n      operator: OperatorNode, left: Evaluatable<NumberNode>,\n      right: Evaluatable<NumberNode>) {\n    super();\n    this[$operator] = operator;\n    this[$left] = left;\n    this[$right] = right;\n  }\n\n  get isConstant() {\n    return Evaluator.isConstant(this[$left]) &&\n        Evaluator.isConstant(this[$right]);\n  }\n\n  [$evaluate](): NumberNode {\n    const leftNode = normalizeUnit(Evaluator.evaluate(this[$left]));\n    const rightNode = normalizeUnit(Evaluator.evaluate(this[$right]));\n    const {number: leftValue, unit: leftUnit} = leftNode;\n    const {number: rightValue, unit: rightUnit} = rightNode;\n\n    // Disallow operations for mismatched normalized units e.g., m and rad:\n    if (rightUnit != null && leftUnit != null && rightUnit != leftUnit) {\n      return ZERO;\n    }\n\n    // NOTE(cdata): rules for calc type checking are defined here\n    // https://drafts.csswg.org/css-values-3/#calc-type-checking\n    // This is a simplification and may not hold up once we begin to support\n    // additional unit types:\n    const unit = leftUnit || rightUnit;\n    let value;\n\n    switch (this[$operator].value) {\n      case '+':\n        value = leftValue + rightValue;\n        break;\n      case '-':\n        value = leftValue - rightValue;\n        break;\n      case '/':\n        value = leftValue / rightValue;\n        break;\n      case '*':\n        value = leftValue * rightValue;\n        break;\n      default:\n        return ZERO;\n    }\n\n    return {type: 'number', number: value, unit};\n  }\n}\n\n\nexport type EvaluatedStyle<T extends Intrinsics<Array<Unit>>> = {\n  [I in keyof T['basis']]: number;\n}&Array<never>;\n\nconst $evaluatables = Symbol('evaluatables');\nconst $intrinsics = Symbol('intrinsics');\n\n/**\n * A VectorEvaluator evaluates a series of numeric terms that usually represent\n * a data structure such as a multi-dimensional vector or a spherical\n *\n * The form of the evaluator's result is determined by the Intrinsics that are\n * given to it when it is constructed. For example, spherical intrinsics would\n * establish two angle terms and a length term, so the result of evaluating the\n * evaluator that is configured with spherical intrinsics is a three element\n * array where the first two elements represent angles in radians and the third\n * element representing a length in meters.\n */\nexport class StyleEvaluator<T extends Intrinsics<Array<any>>> extends\n    Evaluator<EvaluatedStyle<T>> {\n  protected[$intrinsics]: T;\n  protected[$evaluatables]: Array<Evaluatable<NumberNode|IdentNode>>;\n\n  constructor(expressions: Array<ExpressionNode>, intrinsics: T) {\n    super();\n\n    this[$intrinsics] = intrinsics;\n\n    const firstExpression = expressions[0];\n    const terms = firstExpression != null ? firstExpression.terms : [];\n\n    this[$evaluatables] =\n        intrinsics.basis.map<Evaluatable<NumberNode|IdentNode>>(\n            (basisNode, index) => {\n              const term = terms[index];\n              if (term == null) {\n                return {type: 'ident', value: 'auto'};\n              }\n\n              if (term.type === 'ident') {\n                return term;\n              }\n\n              return Evaluator.evaluatableFor(term, basisNode);\n            });\n  }\n\n  get isConstant(): boolean {\n    for (const evaluatable of this[$evaluatables]) {\n      if (!Evaluator.isConstant(evaluatable)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  [$evaluate]() {\n    const evaluated = this[$evaluatables].map<NumberNode|IdentNode>(\n        evaluatable => Evaluator.evaluate(evaluatable));\n    return Evaluator.applyIntrinsics(evaluated, this[$intrinsics])\n               .map<number>(numberNode => numberNode.number) as\n        EvaluatedStyle<T>;\n  }\n}\n\n// SphericalIntrinsics are Intrinsics that expect two angle terms\n// and one length term\nexport type SphericalIntrinsics = Intrinsics<['rad', 'rad', 'm']>;\n// Vector3Intrinsics expect three length terms\nexport type Vector3Intrinsics = Intrinsics<['m', 'm', 'm']>;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}