{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\n/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { parseExpressions } from './parsers.js';\n/**\n * For our purposes, an enumeration is a fixed set of CSS-expression-compatible\n * names. When serialized, a selected subset of the members may be specified as\n * whitespace-separated strings. An enumeration deserializer is a function that\n * parses a serialized subset of an enumeration and returns any members that are\n * found as a Set.\n *\n * The following example will produce a deserializer for the days of the\n * week:\n *\n * const deserializeDaysOfTheWeek = enumerationDeserializer([\n *   'Monday',\n *   'Tuesday',\n *   'Wednesday',\n *   'Thursday',\n *   'Friday',\n *   'Saturday',\n *   'Sunday'\n * ]);\n */\nexport const enumerationDeserializer = allowedNames => valueString => {\n  try {\n    const expressions = parseExpressions(valueString);\n    const names = (expressions.length ? expressions[0].terms : []).filter(valueNode => valueNode && valueNode.type === 'ident').map(valueNode => valueNode.value).filter(name => allowedNames.indexOf(name) > -1);\n    return new Set(names);\n  } catch (_error) {}\n  return new Set();\n};","map":{"version":3,"names":["parseExpressions","enumerationDeserializer","allowedNames","valueString","expressions","names","length","terms","filter","valueNode","type","map","value","name","indexOf","Set","_error"],"sources":["../../src/styles/deserializers.ts"],"sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {IdentNode, parseExpressions} from './parsers.js';\n\n\n/**\n * For our purposes, an enumeration is a fixed set of CSS-expression-compatible\n * names. When serialized, a selected subset of the members may be specified as\n * whitespace-separated strings. An enumeration deserializer is a function that\n * parses a serialized subset of an enumeration and returns any members that are\n * found as a Set.\n *\n * The following example will produce a deserializer for the days of the\n * week:\n *\n * const deserializeDaysOfTheWeek = enumerationDeserializer([\n *   'Monday',\n *   'Tuesday',\n *   'Wednesday',\n *   'Thursday',\n *   'Friday',\n *   'Saturday',\n *   'Sunday'\n * ]);\n */\nexport const enumerationDeserializer = <T extends string>(allowedNames: T[]) =>\n    (valueString: string): Set<T> => {\n      try {\n        const expressions = parseExpressions(valueString);\n        const names = (expressions.length ? expressions[0].terms : [])\n                          .filter<IdentNode>(\n                              (valueNode): valueNode is IdentNode =>\n                                  valueNode && valueNode.type === 'ident')\n                          .map(valueNode => valueNode.value as T)\n                          .filter(name => allowedNames.indexOf(name) > -1);\n\n        return new Set<T>(names);\n      } catch (_error) {\n      }\n      return new Set();\n    };"],"mappings":";;;;;;;;;;AAAA;;;;;;;;;;;;;;AAeA,SAAmBA,gBAAgB,QAAO,cAAc;AAGxD;;;;;;;;;;;;;;;;;;;;AAoBA,OAAO,MAAMC,uBAAuB,GAAsBC,YAAiB,IACtEC,WAAmB,IAAY;EAC9B,IAAI;IACF,MAAMC,WAAW,GAAGJ,gBAAgB,CAACG,WAAW,CAAC;IACjD,MAAME,KAAK,GAAG,CAACD,WAAW,CAACE,MAAM,GAAGF,WAAW,CAAC,CAAC,CAAC,CAACG,KAAK,GAAG,EAAE,EAC1CC,MAAM,CACFC,SAAS,IACNA,SAAS,IAAIA,SAAS,CAACC,IAAI,KAAK,OAAO,CAAC,CAC/CC,GAAG,CAACF,SAAS,IAAIA,SAAS,CAACG,KAAU,CAAC,CACtCJ,MAAM,CAACK,IAAI,IAAIX,YAAY,CAACY,OAAO,CAACD,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;IAElE,OAAO,IAAIE,GAAG,CAAIV,KAAK,CAAC;EAC1B,CAAC,CAAC,OAAOW,MAAM,EAAE,CACjB;EACA,OAAO,IAAID,GAAG,EAAE;AAClB,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}